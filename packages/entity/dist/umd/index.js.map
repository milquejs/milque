{"version":3,"file":"index.js","sources":["../../src/component/ComponentFactory.js","../../src/local/ComponentInstanceMap.js","../../src/local/EntityId.js","../../src/match/MatchFilter.js","../../src/match/MatchFinder.js","../../src/local/LocalEntityPool.js","../../src/EntityManager.js"],"sourcesContent":["/**\n * @template T\n * @param {string} name\n * @param {() => T} newCallback \n * @param {(instance: T) => void} deleteCallback\n * @returns {import('./ComponentTypes').ComponentFactory<T>}\n */\nexport function create(name, newCallback, deleteCallback) {\n  return {\n    name,\n    new: newCallback,\n    delete: deleteCallback,\n  };\n}\n\n/**\n * @template T\n * @param {import('./ComponentTypes').ComponentClass<T>} componentClass \n */\nexport function newComponentInstance(componentClass) {\n  if ('new' in componentClass) {\n    return componentClass.new();\n  } else {\n    return new componentClass();\n  }\n}\n\n/**\n * @template T\n * @param {import('./ComponentTypes').ComponentClass<T>} componentClass \n * @param {T} instance \n */\nexport function deleteComponentInstance(componentClass, instance) {\n  if ('delete' in componentClass && typeof componentClass.delete === 'function') {\n    componentClass.delete(instance);\n  }\n}\n\n/**\n * @param {import('./ComponentTypes').ComponentClass<any>} componentClass \n * @param {import('./ComponentTypes').ComponentClass<any>} otherClass\n */\nexport function isSameComponentClass(componentClass, otherClass) {\n  return componentClass\n    && otherClass\n    && 'name' in componentClass\n    && 'name' in otherClass\n    && componentClass.name === otherClass.name;\n}\n","import { deleteComponentInstance, newComponentInstance } from '../component/ComponentFactory';\n\n/** @type {import('./EntityId').EntityId} */\nexport const MIN_ENTITY_ID = 1;\n/** @type {import('./EntityId').EntityId} */\nexport const MAX_ENTITY_ID = 4_294_967_295;\n\n/**\n * A sparse map of entityId-to-component instances (for a component class).\n *\n * @see https://skypjack.github.io/2019-03-07-ecs-baf-part-2/\n * @template T\n */\nexport class ComponentInstanceMap {\n  /**\n   * @param {import('../component').ComponentClass<T>} componentClass\n   * @param {number} [initialCapacity]\n   * @param {number} [maxCapacity]\n   */\n  constructor(componentClass, initialCapacity = 16, maxCapacity = 10_000) {\n    /**\n     * @readonly\n     * @type {import('../component').ComponentClass<T>}\n     */\n    this.componentClass = componentClass;\n\n    if (maxCapacity <= 0) {\n      throw new Error(\n        `Max capacity must be positive, but was \"${maxCapacity}\".`\n      );\n    }\n    if (initialCapacity > maxCapacity) {\n      throw new Error(`Cannot initialize capacity over max \"${maxCapacity}\".`);\n    }\n\n    const SparseTypedArray = typeOfUnsignedTypedArrayByMaxValue(maxCapacity);\n    const sparseBuffer = new ArrayBuffer(initialCapacity, {\n      maxByteLength: SparseTypedArray.BYTES_PER_ELEMENT * MAX_ENTITY_ID,\n    });\n    /**\n     * The sparse array of entityId-to-index\n     *\n     * @private\n     */\n    this.sparse = new SparseTypedArray(sparseBuffer);\n\n    const EntityIdTypedArray =\n      typeOfUnsignedTypedArrayByMaxValue(MAX_ENTITY_ID);\n    const entityIdBuffer = new ArrayBuffer(initialCapacity, {\n      maxByteLength: EntityIdTypedArray.BYTES_PER_ELEMENT * maxCapacity,\n    });\n    /**\n     * The dense array of index-to-entityId\n     * @private\n     */\n    this.entityIds = new EntityIdTypedArray(entityIdBuffer);\n    /** @private */\n    this.entityIdArrayType = EntityIdTypedArray;\n\n    /**\n     * The dense array of instance objects by index\n     *\n     * @private\n     * @type {Array<T>}\n     */\n    this.instances = new Array();\n\n    this.size = 0;\n\n    /** @readonly */\n    this.maxCapacity = maxCapacity;\n  }\n\n  get capacity() {\n    return Math.trunc(\n      this.entityIds.buffer.byteLength /\n        this.entityIdArrayType.BYTES_PER_ELEMENT\n    );\n  }\n\n  /**\n   * @param {number} newIndex\n   * @param {import('./EntityId').EntityId} newEntityId\n   */\n  ensureCapacity(newIndex, newEntityId) {\n    if (newEntityId >= this.sparse.length) {\n      const nearestByteLength = Math.pow(2, Math.ceil(Math.log2(newEntityId + 1)));\n      const currentByteLength = this.sparse.byteLength;\n      const byteLength = Math.min(\n        this.sparse.buffer.maxByteLength,\n        Math.max(this.sparse.BYTES_PER_ELEMENT, Math.max(currentByteLength * 2, nearestByteLength))\n      );\n      this.sparse.buffer.resize(byteLength);\n    }\n    const newSize = Math.max(this.size, newIndex + 1);\n    if (newSize > this.maxCapacity) {\n      throw new Error(\n        `Exceeded max capacity - cannot insert more objects than \"${this.maxCapacity}\".`\n      );\n    }\n    if (newSize > this.instances.length) {\n      this.size = newSize;\n      this.instances.length = newSize;\n    }\n    if (newSize >= this.entityIds.length) {\n      const nearestByteLength = Math.pow(2, Math.ceil(Math.log2(newSize)));\n      const currentByteLength = this.entityIds.byteLength;\n      const byteLength = Math.min(\n        this.entityIds.buffer.maxByteLength,\n        Math.max(this.entityIds.BYTES_PER_ELEMENT, Math.max(currentByteLength * 2, nearestByteLength))\n      );\n      this.entityIds.buffer.resize(byteLength);\n    }\n  }\n\n  /**\n   * @param {number} entityId\n   * @param {T} [instance]\n   */\n  insert(entityId, instance = undefined) {\n    if (typeof instance === 'undefined') {\n      instance = newComponentInstance(this.componentClass);\n    }\n    const prev = this.sparse[entityId];\n    if (prev >= 0 && this.entityIds[prev] === entityId) {\n      // This entity is already in this set, so just replace the instance.\n      this.instances[prev] = instance;\n      return instance;\n    }\n    // ...increase by 1 size...\n    const index = this.size;\n    this.ensureCapacity(index, entityId);\n    // ...and insert it at the end...\n    this.sparse[entityId] = index;\n    this.instances[index] = instance;\n    this.entityIds[index] = entityId;\n    return instance;\n  }\n\n  /**\n   * @param {number} entityId\n   */\n  delete(entityId) {\n    if (this.size <= 0) {\n      // Cannot delete from empty.\n      return false;\n    }\n    const prev = this.sparse[entityId];\n    if (!(prev >= 0 && this.entityIds[prev] === entityId)) {\n      // This entity is NOT in this set. Skip it.\n      return false;\n    }\n    let prevInstance = this.instances[prev];\n    this.sparse[entityId] = 0;\n    deleteComponentInstance(this.componentClass, prevInstance);\n    if (this.size > 1) {\n      const end = this.size - 1;\n      const endInstance = this.instances[end];\n      const endEntityId = this.entityIds[end];\n      // ...move last object to replace deleted entity...\n      this.sparse[endEntityId] = prev;\n      this.instances[prev] = endInstance;\n      this.entityIds[prev] = endEntityId;\n    }\n    // ...reduce by 1 size.\n    this.size -= 1;\n    this.instances.length = this.size;\n    return true;\n  }\n\n  clear() {\n    let result = Array.from(this.entityIds);\n    for(let entityId of result) {\n      this.delete(entityId);\n    }\n  }\n\n  /**\n   * Assumes the entity id exists in this map, otherwise you must check has() before this call.\n   * \n   * @param {number} entityId\n   */\n  lookup(entityId) {\n    return this.instances[this.sparse[entityId]];\n  }\n\n  /**\n   * @param {T} instance \n   * @returns {import('./EntityId').EntityId}\n   */\n  keyOf(instance) {\n    return this.entityIds[this.instances.indexOf(instance)];\n  }\n\n  /**\n   * @param {number} entityId\n   */\n  has(entityId) {\n    return this.entityIds[this.sparse[entityId]] === entityId;\n  }\n\n  /** @returns {Iterable<import('./EntityId').EntityId> & ArrayLike<import('./EntityId').EntityId>} Iterable of entity ids */\n  keys() {\n    return this.createEntityIdBufferView();\n  }\n\n  /** @returns {Iterable<T> & ArrayLike<T>} Iterable of component instances */\n  values() {\n    return this.instances;\n  }\n\n  /** @private */\n  createEntityIdBufferView() {\n    const TypedArray = this.entityIdArrayType;\n    return new TypedArray(this.entityIds.buffer, 0, this.size);\n  }\n}\n\n/**\n * @param {number} maxValue\n */\nfunction typeOfUnsignedTypedArrayByMaxValue(maxValue) {\n  if (maxValue <= 256) {\n    return Uint8Array;\n  } else if (maxValue <= 65_536) {\n    return Uint16Array;\n  } else if (maxValue <= 4_294_967_296) {\n    return Uint32Array;\n  } else {\n    throw new Error(\n      `Max value is too big - no typed uint array big enough for value \"${maxValue}\".`\n    );\n  }\n}\n","\n/** @typedef {number} EntityId */\n\n/**\n * Used to match for entity id in query result.\n * \n * @param {number} [value]\n */\nexport function EntityId(value) {\n  return /** @type {EntityId} */ (Math.trunc(Number(value ?? 0)));\n}\n\nEntityId.NONE = EntityId(0);\n","/**\n * @template {import('./MatchTypes').MatchClass<any>[]} Components\n * @typedef {MatchFilter<'SomeOf', Components, InstanceType<Components[number]> | null>} MatchFilterSomeOf\n */\n\n/**\n * @template {import('./MatchTypes').MatchClass<any>[]} Components\n * @typedef {MatchFilter<'NoneOf', Components, null>} MatchFilterNoneOf\n */\n\n/**\n * @template {'SomeOf'|'NoneOf'} Name\n * @template {import('./MatchTypes').MatchClass<any>[]} Components\n * @template OutputType\n */\nexport class MatchFilter {\n\n  /**\n   * Match some or none of the matching components.\n   * \n   * @template {import('./MatchTypes').MatchClass<any>[]} T\n   * @param {T} componentClasses \n   * @returns {MatchFilterSomeOf<T>}\n   */\n  static SomeOf(...componentClasses) {\n    return new MatchFilter('SomeOf', componentClasses, /** @type {InstanceType<T[number]> | null} */ (null));\n  }\n\n  /**\n   * Match none of the matching components.\n   * \n   * @template {import('./MatchTypes').MatchClass<any>[]} T\n   * @param {T} componentClasses \n   * @returns {MatchFilterNoneOf<T>}\n   */\n  static NoneOf(...componentClasses) {\n    return new MatchFilter('NoneOf', componentClasses, null);\n  }\n\n  /** @readonly */\n  name;\n  /** @readonly */\n  keys;\n  /** @readonly */\n  output;\n\n  /**\n   * @param {Name} name \n   * @param {Components} keys\n   * @param {OutputType} output\n   */\n  constructor(name, keys, output) {\n    this.name = name;\n    this.keys = keys;\n    this.output = output;\n  }\n}\n","import { EntityId } from '../local/EntityId';\nimport { MatchFilter } from './MatchFilter';\n\n/**\n * @template {import('./MatchTypes').MatchTemplate} T\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {T} selector\n * @param {EntityId} [entityId]\n * @returns {import('./MatchTypes').MatchResult<T>|null}\n */\nexport function find(entityPool, selector, entityId = undefined) {\n  const allKeys = Object.keys(selector);\n  if (allKeys.length <= 0) {\n    return null;\n  }\n  const allEntries = Object.entries(selector);\n  const allValues = Object.values(selector);\n  if (typeof entityId === 'undefined') {\n    const smallest = findSmallestComponentClassByMapSize(\n      entityPool,\n      allValues\n    );\n    if (!smallest) {\n      return null;\n    }\n    entityId = entityPool.components[smallest.name]?.keys()[0];\n  }\n  /** @type {any} */\n  let result = {};\n  // Prepare this early...\n  for(let key of allKeys) {\n    result[key] = null;\n  }\n  forComponents:\n  for (let [key, componentClass] of allEntries) {\n    const componentName = componentClass.name;\n    switch(componentName) {\n      case EntityId.name:\n        result[key] = entityId;\n        // This is processed now. Next component...\n        continue forComponents;\n      case MatchFilter.NoneOf.name:\n        for (let matchedKey of /** @type {import('./MatchFilter').MatchFilterNoneOf<import('../component').ComponentClass<unknown>[]>} */ (componentClass).keys) {\n          const matchedName = matchedKey.name;\n          const instanceMap = entityPool.components[matchedName];\n          if (instanceMap.has(entityId)) {\n            // This is a none matcher! Exclude this entity...\n            return null;\n          }\n        }\n        break;\n      case MatchFilter.SomeOf.name:\n        for (let matchedKey of /** @type {import('./MatchFilter').MatchFilterSomeOf<import('../component').ComponentClass<unknown>[]>} */ (componentClass).keys) {\n          const matchedName = matchedKey.name;\n          const instanceMap = entityPool.components[matchedName];\n          if (instanceMap.has(entityId)) {\n            // This is an optional matcher and we found something! Next required component...\n            result[key] = instanceMap.lookup(entityId);\n            continue forComponents;\n          }\n        }\n        // ...or we did not find anything, but okay since optional. Next component...\n        result[key] = null;\n        break;\n      default:\n        const instanceMap = entityPool.components[componentName];\n        if (!instanceMap.has(entityId)) {\n          // This is not a matching entity :( Skip this entity...\n          return null;\n        }\n        result[key] = instanceMap.lookup(entityId);\n    }\n  }\n  return asMatchResult(result);\n}\n\n/**\n * @template T\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {import('../component').ComponentClass<T>} componentClass\n * @param {EntityId} [entityId]\n * @returns {T|null}\n */\nexport function findOne(entityPool, componentClass, entityId = undefined) {\n  const map = entityPool.components[componentClass.name];\n  if (!map) {\n    return null;\n  }\n  const keys = map.keys();\n  if (keys.length <= 0) {\n    return null;\n  }\n  if (typeof entityId === 'undefined') {\n    entityId = keys[0];\n  }\n  return map.lookup(entityId);\n}\n\n/**\n * @template {import('./MatchTypes').MatchTemplate} T\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {T} selector\n * @returns {Generator<import('./MatchTypes').MatchResult<T>>}\n */\nexport function* findAll(entityPool, selector) {\n  const templateKeys = Object.keys(selector);\n  if (templateKeys.length <= 0) {\n    return;\n  }\n  const templateEntries = Object.entries(selector);\n  const templateValues = Object.values(selector);\n  const smallest = findSmallestComponentClassByMapSize(\n    entityPool,\n    templateValues\n  );\n  if (!smallest) {\n    return;\n  }\n  /** @type {any} */\n  let result = {};\n  // Prepare this early...\n  for(let key of templateKeys) {\n    result[key] = null;\n  }\n  forEntityIds:\n  for (let entityId of entityPool.components[smallest.name]?.keys()) {\n    forComponents:\n    for (let [key, componentClass] of templateEntries) {\n      const componentName = componentClass.name;\n      switch(componentName) {\n        case EntityId.name:\n          result[key] = entityId;\n          // This is processed now. Next component...\n          continue forComponents;\n        case MatchFilter.NoneOf.name:\n          for (let matchedKey of /** @type {import('./MatchFilter').MatchFilterNoneOf<import('../component').ComponentClass<unknown>[]>} */ (componentClass).keys) {\n            const matchedName = matchedKey.name;\n            const instanceMap = entityPool.components[matchedName];\n            if (instanceMap.has(entityId)) {\n              // This is a none matcher! Exclude this entity...\n              continue forEntityIds;\n            }\n          }\n          break;\n        case MatchFilter.SomeOf.name:\n          for (let matchedKey of /** @type {import('./MatchFilter').MatchFilterSomeOf<import('../component').ComponentClass<unknown>[]>} */ (componentClass).keys) {\n            const matchedName = matchedKey.name;\n            const instanceMap = entityPool.components[matchedName];\n            if (instanceMap.has(entityId)) {\n              // This is an optional matcher and we found something! Next required component...\n              result[key] = instanceMap.lookup(entityId);\n              continue forComponents;\n            }\n          }\n          // ...or we did not find anything, but okay since optional. Next component...\n          result[key] = null;\n          break;\n        default:\n          const instanceMap = entityPool.components[componentName];\n          if (!instanceMap.has(entityId)) {\n            // This is not a matching entity :( Skip this entity...\n            continue forEntityIds;\n          }\n          result[key] = instanceMap.lookup(entityId);\n      }\n    }\n    yield asMatchResult(result);\n  }\n}\n\n/**\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {Array<import('../component').ComponentClass<any>>} componentClasses\n */\nfunction findSmallestComponentClassByMapSize(\n  entityPool,\n  componentClasses\n) {\n  let smallest = null;\n  let smallestSize = Number.POSITIVE_INFINITY;\n  for (let nextClass of componentClasses) {\n    const nextClassName = nextClass.name;\n    if (nextClassName === EntityId.name) {\n      continue;\n    }\n    let instanceMap = entityPool.components[nextClassName];\n    if (!instanceMap) {\n      // NOTE: There's a component class with NO entities. This query will never succeed with results.\n      return null;\n    }\n    let nextSize = instanceMap.size;\n    if (nextSize < smallestSize) {\n      smallest = nextClass;\n      smallestSize = nextSize;\n    }\n  }\n  if (!smallest) {\n    // This was an empty or only-entity-id query. This should not happen since we checked during construction.\n    throw new Error(\n      'Cannot find any non-EntityId component class to match for query.'\n    );\n  }\n  return smallest;\n}\n\n/**\n * @template {import('./MatchTypes').MatchTemplate} T\n * @param {Record<string, any>} out\n * @returns {import('./MatchTypes').MatchResult<T>}\n */\nfunction asMatchResult(out) {\n  return /** @type {import('./MatchTypes').MatchResult<any>} */ (out);\n}\n","import { ComponentInstanceMap } from './ComponentInstanceMap';\nimport { EntityId } from './EntityId';\n\n// This is not usual, but for the api, we will export it here.\nexport * from '../match/MatchFinder';\n\n/** @returns {import('./EntityTypes').EntityPoolLike} */\nexport function createPool() {\n  return {\n    components: {},\n    nextAvailableEntityId: 1,\n    unclaimedEntityIds: [],\n    deadEntityIds: [],\n  };\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool\n */\nexport function resetPool(entityPool) {\n  for(let instanceMap of Object.values(entityPool.components)) {\n    instanceMap.clear();\n  }\n  entityPool.nextAvailableEntityId = 1;\n  entityPool.unclaimedEntityIds.length = 0;\n  entityPool.deadEntityIds.length = 0;\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool\n * @returns {import('./EntityId').EntityId}\n */\nexport function newEntity(entityPool) {\n  let result = entityPool.unclaimedEntityIds.pop();\n  if (typeof result === 'undefined') {\n    result = entityPool.nextAvailableEntityId;\n    entityPool.nextAvailableEntityId += 1;\n  }\n  return result;\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId \n */\nexport function deleteEntity(entityPool, entityId) {\n  entityPool.deadEntityIds.push(entityId);\n  for (let instanceMap of Object.values(entityPool.components)) {\n    instanceMap.delete(entityId);\n  }\n  entityPool.deadEntityIds.splice(entityPool.deadEntityIds.indexOf(entityId), 1);\n  entityPool.unclaimedEntityIds.push(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n * @returns {T}\n */\nexport function attachComponent(entityPool, entityId, componentClass) {\n  if (entityPool.deadEntityIds.includes(entityId)) {\n    // NOTE: This makes sure that when executing clean-up code, we don't re-add anything back in.\n    throw new Error('Cannot attach components to a dead entity.');\n  }\n  if (!(componentClass.name in entityPool.components)) {\n    let result = new ComponentInstanceMap(componentClass);\n    entityPool.components[componentClass.name] = /** @type {any} */ (result);\n  }\n  return entityPool.components[componentClass.name].insert(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n */\nexport function detachComponent(entityPool, entityId, componentClass) {\n  if (!(componentClass.name in entityPool.components)) {\n    throw new Error(`Cannot detach component - no mapping exists for component class \"${componentClass.name}\".`);\n  }\n  return entityPool.components[componentClass.name].delete(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n * @returns {T|null}\n */\nexport function lookupComponent(entityPool, entityId, componentClass) {\n  let instanceMap = entityPool.components[componentClass.name];\n  if (!instanceMap?.has(entityId)) {\n    return null;\n  }\n  return instanceMap.lookup(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass\n * @param {T} componentInstance\n * @returns {import('./EntityId').EntityId}\n */\nexport function lookupEntity(entityPool, componentClass, componentInstance) {\n  let instanceMap = entityPool.components[componentClass.name];\n  return instanceMap.keyOf(componentInstance);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass \n * @returns {Iterable<EntityId> & ArrayLike<EntityId>}\n */\nexport function keysOf(entityPool, componentClass) {\n  return entityPool.components[componentClass.name]?.keys() ?? [];\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass \n * @returns {Iterable<T> & ArrayLike<T>}\n */\nexport function instancesOf(entityPool, componentClass) {\n  return entityPool.components[componentClass.name]?.values() ?? [];\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass \n * @returns {number}\n */\nexport function countComponents(entityPool, componentClass) {\n  return entityPool.components[componentClass.name]?.values().length ?? 0;\n}\n","import { EntityId, LocalEntityPool } from './local';\n\nexport class EntityManager {\n\n  /** @type {import('./local').EntityPoolLike['components']} */\n  components = {};\n  /** @type {import('./local').EntityPoolLike['nextAvailableEntityId']} */\n  nextAvailableEntityId = 1;\n  /** @type {import('./local').EntityPoolLike['unclaimedEntityIds']} */\n  unclaimedEntityIds = [];\n  /** @type {import('./local').EntityPoolLike['deadEntityIds']} */\n  deadEntityIds = [];\n\n  newEntity() {\n    return LocalEntityPool.newEntity(this);\n  }\n\n  /**\n   * @param {EntityId} entityId\n   */\n  deleteEntity(entityId) {\n    LocalEntityPool.deleteEntity(this, entityId);\n  }\n\n  /**\n   * @template T\n   * @param {EntityId} entityId \n   * @param {import('./component').ComponentClass<T>} componentClass \n   */\n  attachComponent(entityId, componentClass) {\n    return LocalEntityPool.attachComponent(this, entityId, componentClass);\n  }\n\n  /**\n   * @template T\n   * @param {EntityId} entityId \n   * @param {import('./component').ComponentClass<T>} componentClass \n   */\n  detachComponent(entityId, componentClass) {\n    return LocalEntityPool.detachComponent(this, entityId, componentClass);\n  }\n\n  /**\n   * @template T\n   * @param {EntityId} entityId \n   * @param {import('./component').ComponentClass<T>} componentClass \n   */\n  lookupComponent(entityId, componentClass) {\n    return LocalEntityPool.lookupComponent(this, entityId, componentClass);\n  }\n\n  /**\n   * @template T\n   * @param {import('./component').ComponentClass<T>} componetClass \n   * @param {T} instance \n   */\n  lookupEntity(componetClass, instance) {\n    return LocalEntityPool.lookupEntity(this, componetClass, instance);\n  }\n\n  /**\n   * @template T\n   * @param {import('./component').ComponentClass<T>} componentClass \n   */\n  countComponents(componentClass) {\n    return LocalEntityPool.countComponents(this, componentClass);\n  }\n\n  /**\n   * @template T\n   * @param {import('./component').ComponentClass<T>} componentClass\n   */\n  keysOf(componentClass) {\n    return LocalEntityPool.keysOf(this, componentClass);\n  }\n\n  /**\n   * @template T\n   * @param {import('./component').ComponentClass<T>} componentClass\n   */\n  instancesOf(componentClass) {\n    return LocalEntityPool.instancesOf(this, componentClass);\n  }\n\n  /**\n   * @template {import('./match').MatchTemplate} T\n   * @param {T} selector \n   * @param {EntityId} [entityId]\n   */\n  find(selector, entityId) {\n    return LocalEntityPool.find(this, selector, entityId);\n  }\n\n  /**\n   * @template T\n   * @param {import('./component').ComponentClass<T>} componentClass \n   * @param {EntityId} [entityId]\n   */\n  findOne(componentClass, entityId) {\n    return LocalEntityPool.findOne(this, componentClass, entityId);\n  }\n\n  /**\n   * @template {import('./match').MatchTemplate} T\n   * @param {T} selector \n   */\n  *findAll(selector) {\n    yield* LocalEntityPool.findAll(this, selector);\n  }\n\n  resetPool() {\n    LocalEntityPool.resetPool(this);\n  }\n}\n"],"names":["newComponentInstance","componentClass","new","deleteComponentInstance","instance","delete","name","newCallback","deleteCallback","otherClass","MAX_ENTITY_ID","ComponentInstanceMap","constructor","initialCapacity","maxCapacity","this","Error","SparseTypedArray","typeOfUnsignedTypedArrayByMaxValue","sparseBuffer","ArrayBuffer","maxByteLength","BYTES_PER_ELEMENT","sparse","EntityIdTypedArray","entityIdBuffer","entityIds","entityIdArrayType","instances","Array","size","capacity","Math","trunc","buffer","byteLength","ensureCapacity","newIndex","newEntityId","length","nearestByteLength","pow","ceil","log2","currentByteLength","min","max","resize","newSize","insert","entityId","undefined","prev","index","prevInstance","end","endInstance","endEntityId","clear","result","from","lookup","keyOf","indexOf","has","keys","createEntityIdBufferView","values","TypedArray","maxValue","Uint8Array","Uint16Array","Uint32Array","EntityId","value","Number","NONE","MatchFilter","SomeOf","componentClasses","NoneOf","output","find","entityPool","selector","allKeys","Object","allEntries","entries","allValues","smallest","findSmallestComponentClassByMapSize","components","key","forComponents","componentName","matchedKey","matchedName","instanceMap","findOne","map","findAll","templateKeys","templateEntries","forEntityIds","asMatchResult","smallestSize","POSITIVE_INFINITY","nextClass","nextClassName","nextSize","out","resetPool","nextAvailableEntityId","unclaimedEntityIds","deadEntityIds","newEntity","pop","deleteEntity","push","splice","attachComponent","includes","detachComponent","lookupComponent","lookupEntity","componentInstance","keysOf","instancesOf","countComponents","LocalEntityPool.newEntity","LocalEntityPool.deleteEntity","LocalEntityPool.attachComponent","LocalEntityPool.detachComponent","LocalEntityPool.lookupComponent","componetClass","LocalEntityPool.lookupEntity","LocalEntityPool.countComponents","LocalEntityPool.keysOf","LocalEntityPool.instancesOf","LocalEntityPool.find","LocalEntityPool.findOne","LocalEntityPool.findAll","LocalEntityPool.resetPool"],"mappings":"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"}