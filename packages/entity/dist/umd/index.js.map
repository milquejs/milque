{"version":3,"file":"index.js","sources":["../../src/component/ComponentFactory.js","../../src/local/ComponentInstanceMap.js","../../src/local/LocalEntityPool.js","../../src/local/EntityId.js","../../src/match/MatchFactory.js","../../src/match/MatchQuery.js","../../src/archetype/Archetype.js"],"sourcesContent":["/**\n * @template T\n * @param {string} name\n * @param {() => T} newCallback \n * @param {(instance: T) => void} deleteCallback\n * @returns {import('./ComponentTypes').ComponentFactory<T>}\n */\nexport function create(name, newCallback, deleteCallback) {\n  return {\n    name,\n    new: newCallback,\n    delete: deleteCallback,\n  };\n}\n\n/**\n * @template T\n * @param {import('./ComponentTypes').ComponentClass<T>} componentClass \n */\nexport function newComponentInstance(componentClass) {\n  if ('new' in componentClass) {\n    return componentClass.new();\n  } else {\n    return new componentClass();\n  }\n}\n\n/**\n * @template T\n * @param {import('./ComponentTypes').ComponentClass<T>} componentClass \n * @param {T} instance \n */\nexport function deleteComponentInstance(componentClass, instance) {\n  if ('delete' in componentClass && typeof componentClass.delete === 'function') {\n    componentClass.delete(instance);\n  }\n}\n\n/**\n * @param {import('./ComponentTypes').ComponentClass<any>} componentClass \n * @param {import('./ComponentTypes').ComponentClass<any>} otherClass\n */\nexport function isSameComponentClass(componentClass, otherClass) {\n  return componentClass\n    && otherClass\n    && 'name' in componentClass\n    && 'name' in otherClass\n    && componentClass.name === otherClass.name;\n}\n","import { deleteComponentInstance, newComponentInstance } from '../component/ComponentFactory';\n\n/** @type {import('./EntityId').EntityId} */\nexport const MIN_ENTITY_ID = 1;\n/** @type {import('./EntityId').EntityId} */\nexport const MAX_ENTITY_ID = 4_294_967_295;\n\n/**\n * A sparse map of entityId-to-component instances (for a component class).\n *\n * @see https://skypjack.github.io/2019-03-07-ecs-baf-part-2/\n * @template T\n */\nexport class ComponentInstanceMap {\n  /**\n   * @param {import('../component').ComponentClass<T>} componentClass\n   * @param {number} [initialCapacity]\n   * @param {number} [maxCapacity]\n   */\n  constructor(componentClass, initialCapacity = 16, maxCapacity = 10_000) {\n    /**\n     * @readonly\n     * @type {import('../component').ComponentClass<T>}\n     */\n    this.componentClass = componentClass;\n\n    if (maxCapacity <= 0) {\n      throw new Error(\n        `Max capacity must be positive, but was \"${maxCapacity}\".`\n      );\n    }\n    if (initialCapacity > maxCapacity) {\n      throw new Error(`Cannot initialize capacity over max \"${maxCapacity}\".`);\n    }\n\n    const SparseTypedArray = typeOfUnsignedTypedArrayByMaxValue(maxCapacity);\n    const sparseBuffer = new ArrayBuffer(initialCapacity, {\n      maxByteLength: SparseTypedArray.BYTES_PER_ELEMENT * MAX_ENTITY_ID,\n    });\n    /**\n     * The sparse array of entityId-to-index\n     *\n     * @private\n     */\n    this.sparse = new SparseTypedArray(sparseBuffer);\n\n    const EntityIdTypedArray =\n      typeOfUnsignedTypedArrayByMaxValue(MAX_ENTITY_ID);\n    const entityIdBuffer = new ArrayBuffer(initialCapacity, {\n      maxByteLength: EntityIdTypedArray.BYTES_PER_ELEMENT * maxCapacity,\n    });\n    /**\n     * The dense array of index-to-entityId\n     * @private\n     */\n    this.entityIds = new EntityIdTypedArray(entityIdBuffer);\n    /** @private */\n    this.entityIdArrayType = EntityIdTypedArray;\n\n    /**\n     * The dense array of instance objects by index\n     *\n     * @private\n     * @type {Array<T>}\n     */\n    this.instances = new Array();\n\n    this.size = 0;\n\n    /** @readonly */\n    this.maxCapacity = maxCapacity;\n  }\n\n  get capacity() {\n    return Math.trunc(\n      this.entityIds.buffer.byteLength /\n        this.entityIdArrayType.BYTES_PER_ELEMENT\n    );\n  }\n\n  /**\n   * @param {number} newIndex\n   * @param {import('./EntityId').EntityId} newEntityId\n   */\n  ensureCapacity(newIndex, newEntityId) {\n    if (newEntityId >= this.sparse.length) {\n      const nearestByteLength = Math.pow(2, Math.ceil(Math.log2(newEntityId + 1)));\n      const currentByteLength = this.sparse.byteLength;\n      const byteLength = Math.min(\n        this.sparse.buffer.maxByteLength,\n        Math.max(this.sparse.BYTES_PER_ELEMENT, Math.max(currentByteLength * 2, nearestByteLength))\n      );\n      this.sparse.buffer.resize(byteLength);\n    }\n    const newSize = Math.max(this.size, newIndex + 1);\n    if (newSize > this.maxCapacity) {\n      throw new Error(\n        `Exceeded max capacity - cannot insert more objects than \"${this.maxCapacity}\".`\n      );\n    }\n    if (newSize > this.instances.length) {\n      this.size = newSize;\n      this.instances.length = newSize;\n    }\n    if (newSize >= this.entityIds.length) {\n      const nearestByteLength = Math.pow(2, Math.ceil(Math.log2(newSize)));\n      const currentByteLength = this.entityIds.byteLength;\n      const byteLength = Math.min(\n        this.entityIds.buffer.maxByteLength,\n        Math.max(this.entityIds.BYTES_PER_ELEMENT, Math.max(currentByteLength * 2, nearestByteLength))\n      );\n      this.entityIds.buffer.resize(byteLength);\n    }\n  }\n\n  /**\n   * @param {number} entityId\n   * @param {T} [instance]\n   */\n  insert(entityId, instance = undefined) {\n    if (typeof instance === 'undefined') {\n      instance = newComponentInstance(this.componentClass);\n    }\n    const prev = this.sparse[entityId];\n    if (prev >= 0 && this.entityIds[prev] === entityId) {\n      // This entity is already in this set, so just replace the instance.\n      this.instances[prev] = instance;\n      return instance;\n    }\n    // ...increase by 1 size...\n    const index = this.size;\n    this.ensureCapacity(index, entityId);\n    // ...and insert it at the end...\n    this.sparse[entityId] = index;\n    this.instances[index] = instance;\n    this.entityIds[index] = entityId;\n    return instance;\n  }\n\n  /**\n   * @param {number} entityId\n   */\n  delete(entityId) {\n    if (this.size <= 0) {\n      // Cannot delete from empty.\n      return false;\n    }\n    const prev = this.sparse[entityId];\n    if (!(prev >= 0 && this.entityIds[prev] === entityId)) {\n      // This entity is NOT in this set. Skip it.\n      return false;\n    }\n    let prevInstance = this.instances[prev];\n    this.sparse[entityId] = 0;\n    deleteComponentInstance(this.componentClass, prevInstance);\n    if (this.size > 1) {\n      const end = this.size - 1;\n      const endInstance = this.instances[end];\n      const endEntityId = this.entityIds[end];\n      // ...move last object to replace deleted entity...\n      this.sparse[endEntityId] = prev;\n      this.instances[prev] = endInstance;\n      this.entityIds[prev] = endEntityId;\n    }\n    // ...reduce by 1 size.\n    this.size -= 1;\n    this.instances.length = this.size;\n    return true;\n  }\n\n  clear() {\n    let result = Array.from(this.entityIds);\n    for(let entityId of result) {\n      this.delete(entityId);\n    }\n  }\n\n  /**\n   * Assumes the entity id exists in this map, otherwise you must check has() before this call.\n   * \n   * @param {number} entityId\n   */\n  lookup(entityId) {\n    return this.instances[this.sparse[entityId]];\n  }\n\n  /**\n   * @param {T} instance \n   * @returns {import('./EntityId').EntityId}\n   */\n  keyOf(instance) {\n    return this.entityIds[this.instances.indexOf(instance)];\n  }\n\n  /**\n   * @param {number} entityId\n   */\n  has(entityId) {\n    return this.entityIds[this.sparse[entityId]] === entityId;\n  }\n\n  /** @returns {Iterable<import('./EntityId').EntityId> & ArrayLike<import('./EntityId').EntityId>} Iterable of entity ids */\n  keys() {\n    return this.createEntityIdBufferView();\n  }\n\n  /** @returns {Iterable<T> & ArrayLike<T>} Iterable of component instances */\n  values() {\n    return this.instances;\n  }\n\n  /** @private */\n  createEntityIdBufferView() {\n    const TypedArray = this.entityIdArrayType;\n    return new TypedArray(this.entityIds.buffer, 0, this.size);\n  }\n}\n\n/**\n * @param {number} maxValue\n */\nfunction typeOfUnsignedTypedArrayByMaxValue(maxValue) {\n  if (maxValue <= 256) {\n    return Uint8Array;\n  } else if (maxValue <= 65_536) {\n    return Uint16Array;\n  } else if (maxValue <= 4_294_967_296) {\n    return Uint32Array;\n  } else {\n    throw new Error(\n      `Max value is too big - no typed uint array big enough for value \"${maxValue}\".`\n    );\n  }\n}\n","import { ComponentInstanceMap } from './ComponentInstanceMap';\n\n/** @returns {import('./EntityTypes').EntityPoolLike} */\nexport function createPool() {\n  return {\n    components: {},\n    nextAvailableEntityId: 1,\n    unclaimedEntityIds: [],\n    deadEntityIds: [],\n  };\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool\n */\nexport function resetPool(entityPool) {\n  for(let instanceMap of Object.values(entityPool.components)) {\n    instanceMap.clear();\n  }\n  entityPool.nextAvailableEntityId = 1;\n  entityPool.unclaimedEntityIds.length = 0;\n  entityPool.deadEntityIds.length = 0;\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool\n * @returns {import('./EntityId').EntityId}\n */\nexport function newEntity(entityPool) {\n  let result = entityPool.unclaimedEntityIds.pop();\n  if (typeof result === 'undefined') {\n    result = entityPool.nextAvailableEntityId;\n    entityPool.nextAvailableEntityId += 1;\n  }\n  return result;\n}\n\n/**\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId \n */\nexport function deleteEntity(entityPool, entityId) {\n  entityPool.deadEntityIds.push(entityId);\n  for (let instanceMap of Object.values(entityPool.components)) {\n    instanceMap.delete(entityId);\n  }\n  entityPool.deadEntityIds.splice(entityPool.deadEntityIds.indexOf(entityId), 1);\n  entityPool.unclaimedEntityIds.push(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n * @returns {T}\n */\nexport function attachComponent(entityPool, entityId, componentClass) {\n  if (entityPool.deadEntityIds.includes(entityId)) {\n    // NOTE: This makes sure that when executing clean-up code, we don't re-add anything back in.\n    throw new Error('Cannot attach components to a dead entity.');\n  }\n  if (!(componentClass.name in entityPool.components)) {\n    let result = new ComponentInstanceMap(componentClass);\n    entityPool.components[componentClass.name] = /** @type {any} */ (result);\n  }\n  return entityPool.components[componentClass.name].insert(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n */\nexport function detachComponent(entityPool, entityId, componentClass) {\n  if (!(componentClass.name in entityPool.components)) {\n    throw new Error(`Cannot detach component - no mapping exists for component class \"${componentClass.name}\".`);\n  }\n  return entityPool.components[componentClass.name].delete(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('./EntityId').EntityId} entityId\n * @param {import('../component').ComponentClass<T>} componentClass\n * @returns {T|null}\n */\nexport function lookupComponent(entityPool, entityId, componentClass) {\n  let instanceMap = entityPool.components[componentClass.name];\n  if (!instanceMap?.has(entityId)) {\n    return null;\n  }\n  return instanceMap.lookup(entityId);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass\n * @param {T} componentInstance\n * @returns {import('./EntityId').EntityId}\n */\nexport function lookupEntity(entityPool, componentClass, componentInstance) {\n  let instanceMap = entityPool.components[componentClass.name];\n  return instanceMap.keyOf(componentInstance);\n}\n\n/**\n * @template T\n * @param {import('./EntityTypes').EntityPoolLike} entityPool \n * @param {import('../component').ComponentClass<T>} componentClass \n * @returns {Iterable<T>}\n */\nexport function values(entityPool, componentClass) {\n  return entityPool.components[componentClass.name]?.values() ?? [];\n}\n","\n/** @typedef {number} EntityId */\n\n/**\n * Used to match for entity id in query result.\n * \n * @param {number} [value]\n */\nexport function EntityId(value) {\n  return /** @type {EntityId} */ (Math.trunc(Number(value ?? 0)));\n}\n\nEntityId.NONE = EntityId(0);\n","import { EntityId } from '../local';\n\n/**\n * @template {Record<string, import('./MatchTypes').MatchClass<any>>} T\n * @param {T} template\n * @returns {import('./MatchTypes').Match<T>}\n */\nexport function createMatch(template) {\n  /** @type {Array<import('./MatchTypes').MatchClass<any>>} */\n  const all = [];\n  /** @type {Array<import('./MatchTypes').MatchClass<any>>} */\n  const any = [];\n  /** @type {Array<import('./MatchTypes').MatchClass<any>>} */\n  const none = [];\n  /** @type {Array<import('./MatchTypes').MatchClass<any>>} */\n  const maybe = [];\n\n  for (let [_, value] of Object.entries(template)) {\n    // TODO: For now, everything is AND'ed together.\n    all.push(value);\n  }\n\n  if (all.length === 1 && all[0].name === EntityId.name) {\n    throw new Error(\n      'Cannot match only for EntityId, must include at least 1 other component class!'\n    );\n  }\n\n  const matchId = matchIdFrom(all, any, none);\n  return {\n    matchId,\n    template,\n    all,\n    any,\n    none,\n    maybe,\n  };\n}\n\n/**\n * @param {Array<import('./MatchTypes').MatchClass<any>>} all\n * @param {Array<import('./MatchTypes').MatchClass<any>>} any\n * @param {Array<import('./MatchTypes').MatchClass<any>>} none\n */\nfunction matchIdFrom(all, any, none) {\n  return [\n    ...all.map((c) => `&${c.name}`),\n    ...any.map((c) => `|${c.name}`),\n    ...none.map((c) => `~${c.name}`),\n  ].sort().join('');\n}\n","import { EntityId } from '../local';\n\n/**\n * @template {object} T\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {import('./MatchTypes').Match<T>} match\n * @param {EntityId} [entityId]\n * @returns {import('./MatchTypes').MatchResult<T>|null}\n */\nexport function queryMatch(entityPool, match, entityId = undefined) {\n  const template = match.template;\n  const templateEntries = Object.entries(template);\n  const templateValues = Object.values(template);\n  if (templateValues.length <= 0) {\n    return null;\n  }\n  const smallest = findSmallestComponentClassByMapSize(\n    entityPool,\n    templateValues\n  );\n  if (!smallest) {\n    return null;\n  }\n  if (typeof entityId === 'undefined') {\n    entityId = entityPool.components[smallest.name]?.keys()[0];\n  }\n  /** @type {any} */\n  let result = {};\n  for (let [key, componentClass] of templateEntries) {\n    const componentName = componentClass.name;\n    if (componentName === EntityId.name) {\n      result[key] = entityId;\n      continue;\n    }\n    const instanceMap = entityPool.components[componentName];\n    if (!instanceMap.has(entityId)) {\n      // This is not a matching entity :(\n      return null;\n    }\n    result[key] = instanceMap.lookup(entityId);\n  }\n  return asMatchResult(result);\n}\n\n/**\n * @template {object} T\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {import('./MatchTypes').Match<T>} match\n * @returns {Generator<import('./MatchTypes').MatchResult<T>>}\n */\nexport function* queryMatchAll(entityPool, match) {\n  const template = match.template;\n  const templateEntries = Object.entries(template);\n  const templateValues = Object.values(template);\n  if (templateValues.length <= 0) {\n    return;\n  }\n  const smallest = findSmallestComponentClassByMapSize(\n    entityPool,\n    templateValues\n  );\n  if (!smallest) {\n    return;\n  }\n  for (let entityId of entityPool.components[smallest.name]?.keys()) {\n    /** @type {any} */\n    let result = {};\n    for (let [key, componentClass] of templateEntries) {\n      const componentName = componentClass.name;\n      if (componentName === EntityId.name) {\n        result[key] = entityId;\n        continue;\n      }\n      const instanceMap = entityPool.components[componentName];\n      if (!instanceMap.has(entityId)) {\n        // This is not a matching entity :(\n        continue;\n      }\n      result[key] = instanceMap.lookup(entityId);\n    }\n    yield asMatchResult(result);\n  }\n}\n\n/**\n * @param {import('../local').EntityPoolLike} entityPool\n * @param {Array<import('../component').ComponentClass<any>>} componentClasses\n */\nfunction findSmallestComponentClassByMapSize(\n  entityPool,\n  componentClasses\n) {\n  let smallest = null;\n  let smallestSize = Number.POSITIVE_INFINITY;\n  for (let nextClass of componentClasses) {\n    const nextClassName = nextClass.name;\n    if (nextClassName === EntityId.name) {\n      continue;\n    }\n    let instanceMap = entityPool.components[nextClassName];\n    if (!instanceMap) {\n      // NOTE: There's a component class with NO entities. This query will never succeed with results.\n      return null;\n    }\n    let nextSize = instanceMap.size;\n    if (nextSize < smallestSize) {\n      smallest = nextClass;\n      smallestSize = nextSize;\n    }\n  }\n  if (!smallest) {\n    // This was an empty or only-entity-id query. This should not happen since we checked during construction.\n    throw new Error(\n      'Cannot find any non-EntityId component class to match for query.'\n    );\n  }\n  return smallest;\n}\n\n/**\n * @template {object} T\n * @param {Record<string, any>} out\n * @returns {import('./MatchTypes').MatchResult<T>}\n */\nfunction asMatchResult(out) {\n  return /** @type {import('./MatchTypes').MatchResult<any>} */ (out);\n}\n","import { EntityId, LocalEntityPool } from '../local';\nimport { MatchFactory, queryMatch, queryMatchAll } from '../match';\n\n/**\n * @template {import('../match').MatchTemplate} T\n */\nexport class Archetype {\n\n  /**\n   * @template {import('../match').MatchTemplate} T\n   * @param {T} components\n   */\n  static from(components) {\n    return new Archetype(components);\n  }\n\n  /**\n   * @private\n   * @param {T} components\n   */\n  constructor(components) {\n    /** @private */\n    this.components = components;\n    this.match = MatchFactory.createMatch(components);\n  }\n\n  /**\n   * @param {import('../local').EntityPoolLike} entityPool\n   * @returns {import('../match').MatchResult<T>}\n   */\n  newEntity(entityPool) {\n    let entityId = LocalEntityPool.newEntity(entityPool);\n    /** @type {any} */\n    let result = {};\n    for(let [key, componentClass] of Object.entries(this.components)) {\n      const componentName = componentClass.name;\n      if (componentName === EntityId.name) {\n        result[key] = entityId;\n        continue;\n      }\n      result[key] = LocalEntityPool.attachComponent(entityPool, entityId, componentClass);\n    }\n    return result;\n  }\n\n  /**\n   * @param {import('../local').EntityPoolLike} entityPool\n   * @param {EntityId} [entityId] \n   */\n  query(entityPool, entityId = undefined) {\n    return queryMatch(entityPool, this.match, entityId);\n  }\n\n  /**\n   * @param {import('../local').EntityPoolLike} entityPool\n   */\n  queryAll(entityPool) {\n    return queryMatchAll(entityPool, this.match);\n  }\n\n  asMatch() {\n    return this.match;\n  }\n}\n"],"names":["newComponentInstance","componentClass","new","deleteComponentInstance","instance","delete","name","newCallback","deleteCallback","otherClass","MAX_ENTITY_ID","ComponentInstanceMap","constructor","initialCapacity","maxCapacity","this","Error","SparseTypedArray","typeOfUnsignedTypedArrayByMaxValue","sparseBuffer","ArrayBuffer","maxByteLength","BYTES_PER_ELEMENT","sparse","EntityIdTypedArray","entityIdBuffer","entityIds","entityIdArrayType","instances","Array","size","capacity","Math","trunc","buffer","byteLength","ensureCapacity","newIndex","newEntityId","length","nearestByteLength","pow","ceil","log2","currentByteLength","min","max","resize","newSize","insert","entityId","undefined","prev","index","prevInstance","end","endInstance","endEntityId","clear","result","from","lookup","keyOf","indexOf","has","keys","createEntityIdBufferView","values","TypedArray","maxValue","Uint8Array","Uint16Array","Uint32Array","newEntity","entityPool","unclaimedEntityIds","pop","nextAvailableEntityId","attachComponent","deadEntityIds","includes","components","push","instanceMap","Object","splice","componentInstance","EntityId","value","Number","createMatch","template","all","any","none","_","entries","matchId","map","c","sort","join","matchIdFrom","maybe","NONE","queryMatch","match","templateEntries","templateValues","smallest","findSmallestComponentClassByMapSize","key","componentName","queryMatchAll","asMatchResult","componentClasses","smallestSize","POSITIVE_INFINITY","nextClass","nextClassName","nextSize","out","Archetype","MatchFactory.createMatch","LocalEntityPool.newEntity","LocalEntityPool.attachComponent","query","queryAll","asMatch"],"mappings":"6OAmBO,SAASA,EAAqBC,GACnC,MAAI,QAASA,EACJA,EAAeC,MAEf,IAAID,CAEf,CAOO,SAASE,EAAwBF,EAAgBG,GAClD,WAAYH,GAAmD,mBAA1BA,EAAeI,QACtDJ,EAAeI,OAAOD,EAE1B,4CA7BO,SAAgBE,EAAMC,EAAaC,GACxC,MAAO,CACLF,OACAJ,IAAKK,EACLF,OAAQG,EAEZ,iDA6BO,SAA8BP,EAAgBQ,GACnD,OAAOR,GACFQ,GACA,SAAUR,GACV,SAAUQ,GACVR,EAAeK,OAASG,EAAWH,IAC1C,2BC3CO,MAAMI,EAAgB,WAQtB,MAAMC,EAMX,WAAAC,CAAYX,EAAgBY,EAAkB,GAAIC,EAAc,KAO9D,GAFAC,KAAKd,eAAiBA,EAElBa,GAAe,EACjB,MAAM,IAAIE,MACR,2CAA2CF,OAG/C,GAAID,EAAkBC,EACpB,MAAM,IAAIE,MAAM,wCAAwCF,OAG1D,MAAMG,EAAmBC,EAAmCJ,GACtDK,EAAe,IAAIC,YAAYP,EAAiB,CACpDQ,cAAeJ,EAAiBK,kBAAoBZ,IAOtDK,KAAKQ,OAAS,IAAIN,EAAiBE,GAEnC,MAAMK,EACJN,EAAmCR,GAC/Be,EAAiB,IAAIL,YAAYP,EAAiB,CACtDQ,cAAeG,EAAmBF,kBAAoBR,IAMxDC,KAAKW,UAAY,IAAIF,EAAmBC,GAExCV,KAAKY,kBAAoBH,EAQzBT,KAAKa,UAAY,IAAIC,MAErBd,KAAKe,KAAO,EAGZf,KAAKD,YAAcA,CACrB,CAEA,YAAIiB,GACF,OAAOC,KAAKC,MACVlB,KAAKW,UAAUQ,OAAOC,WACpBpB,KAAKY,kBAAkBL,kBAE7B,CAMA,cAAAc,CAAeC,EAAUC,GACvB,GAAIA,GAAevB,KAAKQ,OAAOgB,OAAQ,CACrC,MAAMC,EAAoBR,KAAKS,IAAI,EAAGT,KAAKU,KAAKV,KAAKW,KAAKL,EAAc,KAClEM,EAAoB7B,KAAKQ,OAAOY,WAChCA,EAAaH,KAAKa,IACtB9B,KAAKQ,OAAOW,OAAOb,cACnBW,KAAKc,IAAI/B,KAAKQ,OAAOD,kBAAmBU,KAAKc,IAAwB,EAApBF,EAAuBJ,KAE1EzB,KAAKQ,OAAOW,OAAOa,OAAOZ,EAC5B,CACA,MAAMa,EAAUhB,KAAKc,IAAI/B,KAAKe,KAAMO,EAAW,GAC/C,GAAIW,EAAUjC,KAAKD,YACjB,MAAM,IAAIE,MACR,4DAA4DD,KAAKD,iBAOrE,GAJIkC,EAAUjC,KAAKa,UAAUW,SAC3BxB,KAAKe,KAAOkB,EACZjC,KAAKa,UAAUW,OAASS,GAEtBA,GAAWjC,KAAKW,UAAUa,OAAQ,CACpC,MAAMC,EAAoBR,KAAKS,IAAI,EAAGT,KAAKU,KAAKV,KAAKW,KAAKK,KACpDJ,EAAoB7B,KAAKW,UAAUS,WACnCA,EAAaH,KAAKa,IACtB9B,KAAKW,UAAUQ,OAAOb,cACtBW,KAAKc,IAAI/B,KAAKW,UAAUJ,kBAAmBU,KAAKc,IAAwB,EAApBF,EAAuBJ,KAE7EzB,KAAKW,UAAUQ,OAAOa,OAAOZ,EAC/B,CACF,CAMA,MAAAc,CAAOC,EAAU9C,OAAW+C,QACF,IAAb/C,IACTA,EAAWJ,EAAqBe,KAAKd,iBAEvC,MAAMmD,EAAOrC,KAAKQ,OAAO2B,GACzB,GAAIE,GAAQ,GAAKrC,KAAKW,UAAU0B,KAAUF,EAGxC,OADAnC,KAAKa,UAAUwB,GAAQhD,EAChBA,EAGT,MAAMiD,EAAQtC,KAAKe,KAMnB,OALAf,KAAKqB,eAAeiB,EAAOH,GAE3BnC,KAAKQ,OAAO2B,GAAYG,EACxBtC,KAAKa,UAAUyB,GAASjD,EACxBW,KAAKW,UAAU2B,GAASH,EACjB9C,CACT,CAKA,OAAO8C,GACL,GAAInC,KAAKe,MAAQ,EAEf,OAAO,EAET,MAAMsB,EAAOrC,KAAKQ,OAAO2B,GACzB,KAAME,GAAQ,GAAKrC,KAAKW,UAAU0B,KAAUF,GAE1C,OAAO,EAET,IAAII,EAAevC,KAAKa,UAAUwB,GAGlC,GAFArC,KAAKQ,OAAO2B,GAAY,EACxB/C,EAAwBY,KAAKd,eAAgBqD,GACzCvC,KAAKe,KAAO,EAAG,CACjB,MAAMyB,EAAMxC,KAAKe,KAAO,EAClB0B,EAAczC,KAAKa,UAAU2B,GAC7BE,EAAc1C,KAAKW,UAAU6B,GAEnCxC,KAAKQ,OAAOkC,GAAeL,EAC3BrC,KAAKa,UAAUwB,GAAQI,EACvBzC,KAAKW,UAAU0B,GAAQK,CACzB,CAIA,OAFA1C,KAAKe,MAAQ,EACbf,KAAKa,UAAUW,OAASxB,KAAKe,MACtB,CACT,CAEA,KAAA4B,GACE,IAAIC,EAAS9B,MAAM+B,KAAK7C,KAAKW,WAC7B,IAAI,IAAIwB,KAAYS,EAClB5C,KAAKV,OAAO6C,EAEhB,CAOA,MAAAW,CAAOX,GACL,OAAOnC,KAAKa,UAAUb,KAAKQ,OAAO2B,GACpC,CAMA,KAAAY,CAAM1D,GACJ,OAAOW,KAAKW,UAAUX,KAAKa,UAAUmC,QAAQ3D,GAC/C,CAKA,GAAA4D,CAAId,GACF,OAAOnC,KAAKW,UAAUX,KAAKQ,OAAO2B,MAAeA,CACnD,CAGA,IAAAe,GACE,OAAOlD,KAAKmD,0BACd,CAGA,MAAAC,GACE,OAAOpD,KAAKa,SACd,CAGA,wBAAAsC,GAEE,OAAO,IAAIE,EADQrD,KAAKY,mBACFZ,KAAKW,UAAUQ,OAAQ,EAAGnB,KAAKe,KACvD,EAMF,SAASZ,EAAmCmD,GAC1C,GAAIA,GAAY,IACd,OAAOC,WACF,GAAID,GAAY,MACrB,OAAOE,YACF,GAAIF,GAAY,WACrB,OAAOG,YAEP,MAAM,IAAIxD,MACR,oEAAoEqD,MAG1E,CC7MO,SAASI,EAAUC,GACxB,IAAIf,EAASe,EAAWC,mBAAmBC,MAK3C,YAJsB,IAAXjB,IACTA,EAASe,EAAWG,sBACpBH,EAAWG,uBAAyB,GAE/BlB,CACT,CAsBO,SAASmB,EAAgBJ,EAAYxB,EAAUjD,GACpD,GAAIyE,EAAWK,cAAcC,SAAS9B,GAEpC,MAAM,IAAIlC,MAAM,8CAElB,KAAMf,EAAeK,QAAQoE,EAAWO,YAAa,CACnD,IAAItB,EAAS,IAAIhD,EAAqBV,GACtCyE,EAAWO,WAAWhF,EAAeK,MAAK,CAC5C,CACA,OAAOoE,EAAWO,WAAWhF,EAAeK,MAAM2C,OAAOC,EAC3D,kEAhEO,WACL,MAAO,CACL+B,WAAY,CAAA,EACZJ,sBAAuB,EACvBF,mBAAoB,GACpBI,cAAe,GAEnB,eA+BO,SAAsBL,EAAYxB,GACvCwB,EAAWK,cAAcG,KAAKhC,GAC9B,IAAK,IAAIiC,KAAeC,OAAOjB,OAAOO,EAAWO,YAC/CE,EAAY9E,OAAO6C,GAErBwB,EAAWK,cAAcM,OAAOX,EAAWK,cAAchB,QAAQb,GAAW,GAC5EwB,EAAWC,mBAAmBO,KAAKhC,EACrC,kBA2BO,SAAyBwB,EAAYxB,EAAUjD,GACpD,KAAMA,EAAeK,QAAQoE,EAAWO,YACtC,MAAM,IAAIjE,MAAM,oEAAoEf,EAAeK,UAErG,OAAOoE,EAAWO,WAAWhF,EAAeK,MAAMD,OAAO6C,EAC3D,kBASO,SAAyBwB,EAAYxB,EAAUjD,GACpD,IAAIkF,EAAcT,EAAWO,WAAWhF,EAAeK,MACvD,OAAK6E,GAAanB,IAAId,GAGfiC,EAAYtB,OAAOX,GAFjB,IAGX,eASO,SAAsBwB,EAAYzE,EAAgBqF,GAEvD,OADkBZ,EAAWO,WAAWhF,EAAeK,MACpCwD,MAAMwB,EAC3B,wBA5FO,SAAmBZ,GACxB,IAAI,IAAIS,KAAeC,OAAOjB,OAAOO,EAAWO,YAC9CE,EAAYzB,QAEdgB,EAAWG,sBAAwB,EACnCH,EAAWC,mBAAmBpC,OAAS,EACvCmC,EAAWK,cAAcxC,OAAS,CACpC,SA6FO,SAAgBmC,EAAYzE,GACjC,OAAOyE,EAAWO,WAAWhF,EAAeK,OAAO6D,UAAY,EACjE,IC7GO,SAASoB,EAASC,GACvB,OAAgCxD,KAAKC,MAAMwD,OAAOD,GAAS,GAC7D,CCHO,SAASE,EAAYC,GAE1B,MAAMC,EAAM,GAENC,EAAM,GAENC,EAAO,GAIb,IAAK,IAAKC,EAAGP,KAAUJ,OAAOY,QAAQL,GAEpCC,EAAIV,KAAKM,GAGX,GAAmB,IAAfI,EAAIrD,QAAgBqD,EAAI,GAAGtF,OAASiF,EAASjF,KAC/C,MAAM,IAAIU,MACR,kFAIJ,MAAMiF,EAgBR,SAAqBL,EAAKC,EAAKC,GAC7B,MAAO,IACFF,EAAIM,IAAKC,GAAM,IAAIA,EAAE7F,WACrBuF,EAAIK,IAAKC,GAAM,IAAIA,EAAE7F,WACrBwF,EAAKI,IAAKC,GAAM,IAAIA,EAAE7F,SACzB8F,OAAOC,KAAK,GAChB,CAtBkBC,CAAYV,EAAKC,EAAKC,GACtC,MAAO,CACLG,UACAN,WACAC,MACAC,MACAC,OACAS,MApBY,GAsBhB,CDzBAhB,EAASiB,KAAOjB,EAAS,uDEHlB,SAASkB,EAAW/B,EAAYgC,EAAOxD,OAAWC,GACvD,MAAMwC,EAAWe,EAAMf,SACjBgB,EAAkBvB,OAAOY,QAAQL,GACjCiB,EAAiBxB,OAAOjB,OAAOwB,GACrC,GAAIiB,EAAerE,QAAU,EAC3B,OAAO,KAET,MAAMsE,EAAWC,EACfpC,EACAkC,GAEF,IAAKC,EACH,OAAO,UAEe,IAAb3D,IACTA,EAAWwB,EAAWO,WAAW4B,EAASvG,OAAO2D,OAAO,IAG1D,IAAIN,EAAS,CAAA,EACb,IAAK,IAAKoD,EAAK9G,KAAmB0G,EAAiB,CACjD,MAAMK,EAAgB/G,EAAeK,KACrC,GAAI0G,IAAkBzB,EAASjF,KAAM,CACnCqD,EAAOoD,GAAO7D,EACd,QACF,CACA,MAAMiC,EAAcT,EAAWO,WAAW+B,GAC1C,IAAK7B,EAAYnB,IAAId,GAEnB,OAAO,KAETS,EAAOoD,GAAO5B,EAAYtB,OAAOX,EACnC,CACA,OAAqBS,CACvB,CAQO,SAAUsD,EAAcvC,EAAYgC,GACzC,MAAMf,EAAWe,EAAMf,SACjBgB,EAAkBvB,OAAOY,QAAQL,GACjCiB,EAAiBxB,OAAOjB,OAAOwB,GACrC,GAAIiB,EAAerE,QAAU,EAC3B,OAEF,MAAMsE,EAAWC,EACfpC,EACAkC,GAEF,GAAKC,EAGL,IAAK,IAAI3D,KAAYwB,EAAWO,WAAW4B,EAASvG,OAAO2D,OAAQ,CAEjE,IAAIN,EAAS,CAAA,EACb,IAAK,IAAKoD,EAAK9G,KAAmB0G,EAAiB,CACjD,MAAMK,EAAgB/G,EAAeK,KACrC,GAAI0G,IAAkBzB,EAASjF,KAAM,CACnCqD,EAAOoD,GAAO7D,EACd,QACF,CACA,MAAMiC,EAAcT,EAAWO,WAAW+B,GACrC7B,EAAYnB,IAAId,KAIrBS,EAAOoD,GAAO5B,EAAYtB,OAAOX,GACnC,OACMgE,EAAcvD,EACtB,CACF,CAMA,SAASmD,EACPpC,EACAyC,GAEA,IAAIN,EAAW,KACXO,EAAe3B,OAAO4B,kBAC1B,IAAK,IAAIC,KAAaH,EAAkB,CACtC,MAAMI,EAAgBD,EAAUhH,KAChC,GAAIiH,IAAkBhC,EAASjF,KAC7B,SAEF,IAAI6E,EAAcT,EAAWO,WAAWsC,GACxC,IAAKpC,EAEH,OAAO,KAET,IAAIqC,EAAWrC,EAAYrD,KACvB0F,EAAWJ,IACbP,EAAWS,EACXF,EAAeI,EAEnB,CACA,IAAKX,EAEH,MAAM,IAAI7F,MACR,oEAGJ,OAAO6F,CACT,CAOA,SAASK,EAAcO,GACrB,QACF,CCxHO,MAAMC,EAMX,WAAO9D,CAAKqB,GACV,OAAO,IAAIyC,EAAUzC,EACvB,CAMA,WAAArE,CAAYqE,GAEVlE,KAAKkE,WAAaA,EAClBlE,KAAK2F,MAAQiB,EAAyB1C,EACxC,CAMA,SAAAR,CAAUC,GACR,IAAIxB,EAAW0E,EAA0BlD,GAErCf,EAAS,CAAA,EACb,IAAI,IAAKoD,EAAK9G,KAAmBmF,OAAOY,QAAQjF,KAAKkE,YAAa,CAC1ChF,EAAeK,OACfiF,EAASjF,KAI/BqD,EAAOoD,GAAOc,EAAgCnD,EAAYxB,EAAUjD,GAHlE0D,EAAOoD,GAAO7D,CAIlB,CACA,OAAOS,CACT,CAMA,KAAAmE,CAAMpD,EAAYxB,OAAWC,GAC3B,OAAOsD,EAAW/B,EAAY3D,KAAK2F,MAAOxD,EAC5C,CAKA,QAAA6E,CAASrD,GACP,OAAOuC,EAAcvC,EAAY3D,KAAK2F,MACxC,CAEA,OAAAsB,GACE,OAAOjH,KAAK2F,KACd"}