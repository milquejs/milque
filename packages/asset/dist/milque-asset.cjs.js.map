{"version":3,"file":"milque-asset.cjs.js","sources":["../src/GlobExp.js","../src/AssetStore.js","../src/AssetRef.js","../src/loaders/BMFontLoader.js","../src/AssetManager.js","../src/loaders/AtlasLoader.js","../src/loaders/AudioBufferLoader.js","../src/loaders/ImageLoader.js","../src/loaders/JSONLoader.js","../src/loaders/OBJLoader.js","../src/loaders/TextLoader.js","../src/AssetHelper.js"],"sourcesContent":["import { makeRe } from 'picomatch';\n\nexport class GlobExp {\n    /**\n     * @param {string|GlobExp} pattern \n     */\n    constructor(pattern) {\n        let source;\n        if (typeof pattern === 'object' && pattern instanceof GlobExp) {\n            source = pattern.source;\n        } else {\n            source = String(pattern);\n        }\n        this.source = source;\n\n        /** @private */\n        this._re = makeRe(source);\n    }\n\n    /**\n     * @param {string} string \n     * @returns {boolean}\n     */\n    test(string) {\n        return this._re.test(string);\n    }\n}\n","import { GlobExp } from './GlobExp.js';\n\n/**\n * @typedef AssetStore\n * @property {Record<string, object>} store\n * @property {Record<string, Loading>} loadings\n * @property {Array<Fallback>} defaults\n */\n\n/**\n * @template T\n * @template {object} S\n * @callback AssetLoader\n * @param {string|ArrayBuffer} src\n * @param {S} [opts]\n * @returns {Promise<T>}\n */\n\nconst FILE_URI_PREFIX_PATTERN = /^([_\\w\\d]+)\\:\\/\\//;\n\n/**\n * Load asset using a loader with the given src.\n * - If loading to transform a cached asset, the cached uri must start with `res://` (or equivalent).\n * - If loading to transform cached raw buffers from an asset pack, use `raw://`.\n * - Otherwise, it will call `fetch()` on src.\n * \n * @template T, S\n * @param {AssetStore} assets\n * @param {string} uri \n * @param {string} src\n * @param {AssetLoader<T, S>} loader\n * @param {S} opts\n * @param {number} timeout\n * @returns {Promise<T>}\n */\n export async function loadInStore(assets, uri, src, loader, opts, timeout) {\n    const { loadings } = assets;\n    \n    let loading;\n    if (uri in loadings) {\n        loading = loadings[uri];\n    } else {\n        loading = new Loading(timeout);\n        loadings[uri] = loading;\n    }\n\n    const attempt = Loading.nextAttempt(loading);\n\n    /** @type {Array<Promise<T>>} */\n    let promises = [loading.promise];\n    if (FILE_URI_PREFIX_PATTERN.test(src)) {\n        // Loading from cached file\n        promises.push(getLoadedInStore(assets, src, timeout)\n            .then(cached => loader(cached, opts))\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    } else {\n        // Just load it\n        promises.push(loader(src)\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    }\n    return await Promise.race(promises);\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {T} value\n * @returns {T}\n */\nexport function cacheInStore(assets, uri, value) {\n    const { store, loadings } = assets;\n    store[uri] = value;\n    // Send asset to awaiting loaders...\n    if (uri in loadings) {\n        loadings[uri].resolve(value);\n        delete loadings[uri];\n    }\n    return value;\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n * @param {T} value\n * @returns {T}\n */\nexport function cacheDefaultInStore(assets, glob, value) {\n    const { defaults } = assets;\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const uri = `__default://[${defaults.length}]`;\n    cacheInStore(assets, uri, value);\n    defaults.push(new Fallback(glob, uri));\n    return value;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n */\nexport function unloadInStore(assets, uri) {\n    const { store, loadings } = assets;\n    if (uri in loadings) {\n        loadings[uri].reject(new Error('Stop loading to delete asset.'));\n        delete loadings[uri];\n    }\n    if (uri in store) {\n        delete store[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n */\nexport function clearInStore(assets, glob) {\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const { store, loadings } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        if (glob.test(uri)) {\n            loading.reject(new Error(`Stop loading to clear assets matching ${glob}`));\n            delete loadings[uri];\n        }\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        if (glob.test(uri)) {\n            delete store[uri];\n        }\n    }\n}\n\n/**\n * @param {AssetStore} assets \n */\nexport function resetStore(assets) {\n    const { store, loadings, defaults } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        delete store[uri];\n    }\n    // Clear defaults\n    defaults.length = 0;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {Promise<object>}\n */\nexport function getLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {AssetStore} assets \n * @param {string} uri \n */\nexport function cancelLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {number} timeout\n * @returns {Promise<object>}\n */\nexport async function getLoadedInStore(assets, uri, timeout) {\n    const { store, loadings } = assets;\n    if (uri in store) {\n        return store[uri];\n    } else if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        let loading = new Loading(timeout);\n        loadings[uri] = loading;\n        return loading.promise;\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {object}\n */\nexport function getDefaultInStore(assets, uri) {\n    const { defaults } = assets;\n    for (let def of defaults) {\n        if (def.glob.test(uri)) {\n            return getCurrentInStore(assets, def.uri);\n        }\n    }\n    return null;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {object}\n */\nexport function getCurrentInStore(assets, uri) {\n    return assets.store[uri];\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function hasInStore(assets, uri) {\n    return Boolean(assets.store[uri]);\n}\n\n/**\n * @param {AssetStore} assets\n * @returns {Array<string>}\n */\nexport function keysInStore(assets) {\n    return Object.keys(assets.store);\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetCachedInStore(assets, uri) {\n    return uri in assets.store;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetLoadingInStore(assets, uri) {\n    return uri in assets.loadings;\n}\n\nclass Fallback {\n    /**\n     * @param {GlobExp} glob \n     * @param {string} uri \n     */\n    constructor(glob, uri) {\n        this.glob = glob;\n        this.uri = uri;\n    }\n}\n\nclass Loading {\n\n    /**\n     * @param {Loading} loading\n     */\n    static nextAttempt(loading) {\n        return ++loading._promiseHandle;\n    }\n\n    /**\n     * @param {Loading} loading \n     * @param {number} attempt\n     */\n    static isCurrentAttempt(loading, attempt) {\n        return loading._promiseHandle === attempt;\n    }\n\n    constructor(timeout) {\n        /** @private */\n        this._promiseHandle = 0;\n        /** @private */\n        this._resolve = null;\n        /** @private */\n        this._reject = null;\n        /** @private */\n        this._reason = null;\n        /** @private */\n        this._value = null;\n        /** @private */\n        this._timeoutHandle =\n            Number.isFinite(timeout) && timeout > 0\n                ? setTimeout(() => {\n                    this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n                }, timeout)\n                : null;\n        /** @private */\n        this._promise = new Promise((resolve, reject) => {\n            if (this._value) {\n                resolve(this._value);\n            } else {\n                this._resolve = resolve;\n            }\n            if (this._reason) {\n                reject(this._reason);\n            } else {\n                this._reject = reject;\n            }\n        });\n    }\n\n    get promise() {\n        return this._promise;\n    }\n\n    resolve(value) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._resolve) {\n            this._resolve(value);\n        } else {\n            this._value = value;\n        }\n    }\n\n    reject(reason) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._reject) {\n            this._reject(reason);\n        } else {\n            this._reason = reason;\n        }\n    }\n}\n","import { AssetManager } from './AssetManager';\n\nconst DEFAULT_TIMEOUT = 5000;\n\n/** @template T, S */\nexport class AssetRef {\n\n    /**\n     * @param {string} uri \n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} [opts] \n     * @param {string} [filepath]\n     * @param {T|AssetRef<T>} [initial]\n     */\n    constructor(uri, loader, opts = undefined, filepath = uri, initial = null) {\n        this.uri = uri;\n        this.loader = loader;\n        this.opts = opts;\n\n        /** @private */\n        this.initial = initial;\n        /** @private */\n        this.filepath = filepath;\n\n        /** @type {AssetManager} */\n        this.source = null;\n        /** @type {T} */\n        this.current = null;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {T} value \n     */\n    cache(assetManager, value) {\n        assetManager.cache(this.uri, value);\n        this.source = assetManager;\n        this.current = value;\n        return this;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @returns {T}\n     */\n    get(assetManager) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            if (this.initial && this.initial instanceof AssetRef) {\n                result = this.initial.get(assetManager);\n            } else {\n                result = this.initial;\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout]\n     */\n    async load(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            result = await assetManager.load(this.uri, this.filepath, this.loader, this.opts, timeout);\n            if (!result) {\n                if (this.initial && this.initial instanceof AssetRef) {\n                    let initial = this.initial;\n                    result = await assetManager.load(initial.uri, initial.filepath, initial.loader, initial.opts, timeout);\n                } else {\n                    result = this.initial;\n                }\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout] \n     */\n    async reload(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result = await assetManager.reload(this.uri, this.filepath, this.loader, this.opts, timeout);\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n}\n","/**\n * @typedef BMFontChar\n * @property {number} id The character id.\n * @property {number} x The left position of the character image in the texture.\n * @property {number} y The top position of the character image in the texture.\n * @property {number} width The width of the character image in the texture.\n * @property {number} height The height of the character image in the texture.\n * @property {number} xoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} yoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} xadvance How much the current position should be advanced\n *                             after drawing the character.\n * @property {number} page The texture page where the character image is found.\n * @property {number} chnl The texture channel where the character image is\n *                         found (1 = blue, 2 = green, 4 = red, 8 = alpha,\n *                         15 = all channels).\n *\n * @typedef BMFontKerning\n * @property {number} first The first character id.\n * @property {number} second The second character id.\n * @property {number} amount How much the x position should be adjusted when\n *                           drawing the second character immediately following\n *                           the first.\n *\n * @typedef BMFontData\n * @property {object} info              This tag holds information on how the\n *                                      font was generated.\n * @property {string} info.face         This is the name of the true type font.\n * @property {number} info.size         The size of the true type font.\n * @property {number} info.bold         The font is bold.\n * @property {number} info.italic\t    The font is italic.\n * @property {string} info.charset\t    The name of the OEM charset used (when\n *                                      not unicode).\n * @property {number} info.unicode\t    Set to 1 if it is the unicode charset.\n * @property {number} info.stretchH\t    The font height stretch in percentage.\n *                                      100% means no stretch.\n * @property {number} info.smooth\t    Set to 1 if smoothing was turned on.\n * @property {number} info.aa\t        The supersampling level used. 1 means no\n *                                      supersampling was used.\n * @property {number} info.padding\t    The padding for each character\n *                                      (up, right, down, left).\n * @property {number} info.spacing\t    The spacing for each character\n *                                      (horizontal, vertical).\n * @property {number} info.outline\t    The outline thickness for the characters.\n * @property {object} common            This tag holds information common to all\n *                                      characters.\n * @property {number} common.lineHeight This is the distance in pixels between\n *                                      each line of text.\n * @property {number} common.base\t    The number of pixels from the absolute\n *                                      top of the line to the base of the characters.\n * @property {number} common.scaleW\t    The width of the texture, normally used\n *                                      to scale the x pos of the character image.\n * @property {number} common.scaleH\t    The height of the texture, normally used\n *                                      to scale the y pos of the character image.\n * @property {number} common.pages\t    The number of texture pages included in\n *                                      the font.\n * @property {number} common.packed\t    Set to 1 if the monochrome characters\n *                                      have been packed into each of the texture\n *                                      channels. In this case alphaChnl describes\n *                                      what is stored in each channel.\n * @property {number} common.alphaChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.redChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.greenChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.blueChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {object} page              This tag gives the name of a texture\n *                                      file. There is one for each page in the font.\n * @property {number} page.id\t        The page id.\n * @property {number} page.file\t        The texture file name.\n * @property {Array<BMFontChar>} chars  This tag describes characters in the font.\n *                                      There is one for each included character\n *                                      in the font.\n * @property {Array<BMFontKerning>} kernings The kerning information is used to adjust\n *                                           the distance between certain characters,\n *                                           e.g. some characters should be placed\n *                                           closer to each other than others.\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<BMFontData>}\n */\nexport async function BMFontLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return BMFontLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\nconst TAG_PATTERN = /(.+?)\\s+(.*)/;\nconst LINE_PATTERN = /(.+)=(.+)/;\n\n/**\n * @param {string} string\n * @returns {BMFontData}\n */\nfunction parse(string) {\n  let lines = string.split('\\n');\n  let info = {};\n  let common = {};\n  let page = {};\n  let chars = [];\n  let kernings = [];\n  for (let line of lines) {\n    let array = TAG_PATTERN.exec(line);\n    if (!array) {\n      continue;\n    }\n    let [_, tag, props] = array;\n    switch (tag) {\n      case 'info':\n        parseBMLine(info, props);\n        break;\n      case 'common':\n        parseBMLine(common, props);\n        break;\n      case 'page':\n        parseBMLine(page, props);\n        break;\n      case 'chars':\n        // This only has count info. Ignore it.\n        break;\n      case 'char':\n        let char = {};\n        parseBMLine(char, props);\n        if ('id' in char) {\n          chars.push(char);\n        }\n        break;\n      case 'kerning':\n        let kerning = {};\n        parseBMLine(kerning, props);\n        if ('first' in kerning) {\n          kernings.push(kerning);\n        }\n        break;\n      default:\n      // Unknown tag.\n    }\n  }\n  let data = /** @type {BMFontData} */ ({\n    info,\n    common,\n    page,\n    chars,\n    kernings,\n  });\n  return data;\n}\n\nfunction parseBMLine(out, line) {\n  let props = line.split(/\\s+/);\n  for (let prop of props) {\n    let array = LINE_PATTERN.exec(prop);\n    if (!array) {\n      continue;\n    }\n    let [_, key, value] = array;\n    let result = JSON.parse(`[${value}]`);\n    if (result.length === 1) {\n      out[key] = result[0];\n    } else {\n      out[key] = result;\n    }\n  }\n}\n","import { cacheDefaultInStore, cacheInStore, clearInStore, getCurrentInStore, getDefaultInStore, getLoadedInStore, getLoadingInStore, hasInStore, isAssetCachedInStore, isAssetLoadingInStore, keysInStore, loadInStore, resetStore, unloadInStore } from './AssetStore.js';\nimport { GlobExp } from './GlobExp.js';\n\n/**\n * @template T, S\n * @typedef {import('./AssetStore').AssetLoader<T, S>} AssetLoader\n */\n\nexport class AssetManager {\n\n    /**\n     * @param {AssetManager} [parent] \n     */\n    constructor(parent = null) {\n        this.parent = parent;\n        /** @private */\n        this.store = {};\n        /** @private */\n        this.loadings = {};\n        /** @private */\n        this.defaults = [];\n    }\n\n    /**\n     * @param {string} uri \n     * @returns {any}\n     */\n    get(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        }\n        let def = getDefaultInStore(assets, uri);\n        if (def) {\n            return def;\n        }\n        throw new Error(`Asset '${uri}' not found.`);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout \n     * @returns {Promise<T>}\n     */\n    async resolve(uri, filepath, loader, opts, timeout) {\n        return this.get(uri) || await this.load(uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T\n     * @param {string|GlobExp} uriGlob \n     * @param {T} value \n     * @returns {T}\n     */\n    fallback(uriGlob, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheDefaultInStore(assets, uriGlob, value);\n    }\n\n    /**\n     * @template T\n     * @param {string} uri \n     * @param {T} value \n     * @returns {T}\n     */\n    cache(uri, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheInStore(assets, uri, value);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async load(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        } else if (isAssetLoadingInStore(assets, uri)) {\n            return await getLoadedInStore(assets, uri, timeout);\n        }\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async reload(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    unload(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        unloadInStore(assets, uri);\n    }\n\n    /**\n     * @param {string|GlobExp} uriGlob \n     */\n    clear(uriGlob) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        clearInStore(assets, uriGlob);\n    }\n\n    /**\n     * @param {string} uri\n     */\n    current(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return getCurrentInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    exists(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return hasInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    loading(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetLoadingInStore(assets, uri)) {\n            return getLoadingInStore(assets, uri);\n        } else {\n            return null;\n        }\n    }\n\n    keys() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return keysInStore(assets);\n    }\n\n    reset() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        resetStore(assets);\n    }\n}\n","/**\n * @typedef {Record<string, AtlasSpriteData>} Atlas\n * \n * @typedef AtlasSpriteData\n * @property {number} u\n * @property {number} v\n * @property {number} w\n * @property {number} h\n * @property {number} frames\n * @property {number} cols\n * @property {number} rows\n * @property {string} name\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @param {{ onprogress: (value: number, loaded: number, total: number) => void }} opts\n * @returns {Promise<Atlas>}\n */\nexport async function AtlasLoader(src, opts = { onprogress: undefined }) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AtlasLoader(arrayBuffer, opts);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  const string = new TextDecoder().decode(arrayBuffer);\n  /** @type {Atlas} */\n  let result = {};\n  let lines = string.split('\\n');\n  let progressTotal = lines.length;\n  let progressLoaded = 0;\n  if (opts.onprogress) {\n    opts.onprogress(0, 0, progressTotal);\n  }\n  for (let line of lines) {\n    ++progressLoaded;\n    line = line.trim();\n    if (line.length <= 0) continue;\n    if (line.startsWith('#')) continue;\n    if (line.startsWith('//')) continue;\n\n    let args = [];\n    let i = 0;\n    let j = line.indexOf(' ');\n    while (j >= 0) {\n      args.push(line.substring(i, j));\n      i = j + 1;\n      j = line.indexOf(' ', i);\n    }\n    args.push(line.substring(i));\n\n    let name = args[0];\n    let u = Number.parseInt(args[1]);\n    let v = Number.parseInt(args[2]);\n    let w = Number.parseInt(args[3]);\n    let h = Number.parseInt(args[4]);\n    let frames =\n      args.length >= 6\n        ? Number.parseInt(args[5]) // User-defined\n        : 1; // Default 1 frame\n    let cols =\n      args.length >= 7\n        ? Number.parseInt(args[6]) // User-defined\n        : frames; // Default same as frame count\n    let rows =\n      args.length >= 8\n        ? Number.parseInt(args[7]) // User-defined\n        : frames > cols // If more frames than cols...\n        ? Math.ceil(frames / cols) // ...then expect more rows\n        : 1; // Otherwise, default single row\n\n    result[name] = {\n      u,\n      v,\n      w,\n      h,\n      frames,\n      cols,\n      rows,\n      name,\n    };\n\n    if (opts.onprogress) {\n      opts.onprogress(progressLoaded / progressTotal, progressLoaded, progressTotal);\n    }\n  }\n  if (opts.onprogress) {\n    opts.onprogress(1, progressLoaded, progressLoaded);\n  }\n  return result;\n}\n","/**\n * @param {ArrayBuffer|Uint8Array|string} src\n * @param {object} opts\n * @param {AudioContext} opts.audioContext\n * @returns {Promise<AudioBuffer>}\n */\nexport async function AudioBufferLoader(src, opts) {\n  const { audioContext } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AudioBufferLoader(arrayBuffer, { audioContext });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  let audioArrayBuffer = new ArrayBuffer(arrayBuffer.byteLength);\n  // @ts-ignore\n  new Uint8Array(audioArrayBuffer).set(arrayBuffer);\n  let audioBuffer = await audioContext.decodeAudioData(audioArrayBuffer);\n  return audioBuffer;\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @param {object} [opts]\n * @param {string} [opts.imageType]\n * @returns {Promise<HTMLImageElement>}\n */\nexport async function ImageLoader(src, opts = undefined) {\n  let { imageType = undefined } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    if (typeof imageType === 'undefined') {\n      let i = src.lastIndexOf('.');\n      if (i < 0) {\n        throw new Error('Cannot load from url - unknown image type.');\n      } else {\n        imageType = 'image/' + src.slice(i + 1);\n      }\n    }\n    return ImageLoader(arrayBuffer, { ...opts, imageType });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  if (typeof imageType === 'undefined') {\n    imageType = 'image/png';\n  }\n  let blob = new Blob([arrayBuffer], { type: imageType });\n  let imageUrl = URL.createObjectURL(blob);\n  let image = new Image();\n  return new Promise((resolve, reject) => {\n    image.addEventListener('load', () => {\n      resolve(image);\n    });\n    image.addEventListener('error', (e) => {\n      reject(e);\n    });\n    image.src = imageUrl;\n  });\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<object>}\n */\nexport async function JSONLoader(src) {\n    if (typeof src === 'string') {\n        const response = await fetch(src);\n        const arrayBuffer = await response.arrayBuffer();\n        return JSONLoader(arrayBuffer);\n    } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n        throw new Error(\n            `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n        );\n    }\n    /** @type {ArrayBuffer} */\n    const arrayBuffer = src;\n    return JSON.parse(new TextDecoder().decode(arrayBuffer));\n}\n","/**\n * @typedef MeshData\n * @property {Float32Array} positions\n * @property {Float32Array} texcoords\n * @property {Float32Array} normals\n * @property {Uint16Array} indices\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<MeshData>}\n */\nexport async function OBJLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return OBJLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      `Cannot load from source - must be an ArrayBuffer or fetchable url, but got instead: ${src}`\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\n/**\n * @param {string} string\n * @returns {MeshData}\n */\nfunction parse(string) {\n  const vertexList = [];\n  const texcoordList = [];\n  const normalList = [];\n\n  const vertexIndices = [];\n  const texcoordIndices = [];\n  const normalIndices = [];\n\n  // # comments\n  const commentPattern = /^#.*/g;\n  // v float float float\n  const vertexPattern = /v\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vn float float float\n  const normalPattern = /vn\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vt float float float\n  const texcoordPattern = /vt\\s+(\\S+)\\s+(\\S+)/g;\n  // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n  const facePattern =\n    /f\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))(\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*)))?/g;\n  // f float float float\n  const faceVertexPattern = /f\\s+([^/\\s]+)\\s+([^/\\s]+)\\s+([^/\\s]+)/g;\n\n  let quad = false;\n  let result = null;\n  let x, y, z, w;\n\n  // Remove all comments\n  string = string.replace(commentPattern, '');\n\n  // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = vertexPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    vertexList.push(x);\n    vertexList.push(y);\n    vertexList.push(z);\n  }\n\n  // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = normalPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    normalList.push(x);\n    normalList.push(y);\n    normalList.push(z);\n  }\n\n  // [\"vt 1.0 2.0\", \"1.0\", \"2.0\"]\n  while ((result = texcoordPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    texcoordList.push(x);\n    texcoordList.push(y);\n  }\n\n  // [\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1\", \"1\", \"1\", \"1\", \"2/2/2\", \"2\", \"2\", \"2\", \"3/3/3\", \"3\", \"3\", \"3\", \"4/4/4\", \"4\", \"4\", \"4\"]\n  while ((result = facePattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    if (Number.isNaN(x)) x = 1;\n    y = Number.parseInt(result[6]);\n    if (Number.isNaN(y)) y = 1;\n    z = Number.parseInt(result[10]);\n    if (Number.isNaN(z)) z = 1;\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // Normal indices\n    x = Number.parseInt(result[4]);\n    if (Number.isNaN(x)) {\n      // No UVs.\n      x = Number.parseInt(result[3]);\n      y = Number.parseInt(result[7]);\n      z = Number.parseInt(result[11]);\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n    } else {\n      // Maybe UVs.\n      y = Number.parseInt(result[8]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[12]);\n      if (Number.isNaN(z)) z = 1;\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      // UV indices\n      x = Number.parseInt(result[3]);\n      if (Number.isNaN(x)) x = 1;\n      y = Number.parseInt(result[7]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[11]);\n      if (Number.isNaN(z)) z = 1;\n      texcoordIndices.push(x);\n      texcoordIndices.push(y);\n      texcoordIndices.push(z);\n    }\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[15]);\n      if (Number.isNaN(w)) w = 1;\n      vertexIndices.push(w);\n\n      // Normal indices\n      w = Number.parseInt(result[17]);\n      if (Number.isNaN(w)) {\n        // No UVs.\n        w = Number.parseInt(result[16]);\n        normalIndices.push(w);\n        texcoordIndices.push(1);\n      } else {\n        // Maybe UVs.\n        normalIndices.push(w);\n\n        w = Number.parseInt(result[16]);\n        texcoordIndices.push(w);\n      }\n\n      quad = true;\n    }\n  }\n\n  // [\"f 1 2 3 4\", \"1\", \"2\", \"3\", \"4\"]\n  while ((result = faceVertexPattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    y = Number.parseInt(result[6]);\n    z = Number.parseInt(result[10]);\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // UV indices\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n\n    // Normal indices\n    normalIndices.push(1);\n    normalIndices.push(1);\n    normalIndices.push(1);\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[14]);\n      vertexIndices.push(w);\n\n      // UV indices\n      texcoordIndices.push(1);\n      // Normal indices\n      normalIndices.push(1);\n\n      quad = true;\n    }\n  }\n\n  let index, size;\n\n  size = vertexIndices.length;\n  const positions = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = vertexIndices[i] - 1;\n    positions[i * 3 + 0] = vertexList[index * 3 + 0];\n    positions[i * 3 + 1] = vertexList[index * 3 + 1];\n    positions[i * 3 + 2] = vertexList[index * 3 + 2];\n  }\n\n  size = texcoordIndices.length;\n  const texcoords = new Float32Array(size * 2);\n  for (let i = 0; i < size; ++i) {\n    index = texcoordIndices[i] - 1;\n    texcoords[i * 2 + 0] = texcoordList[index * 2 + 0];\n    texcoords[i * 2 + 1] = texcoordList[index * 2 + 1];\n  }\n\n  size = normalIndices.length;\n  const normals = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = normalIndices[i] - 1;\n    normals[i * 3 + 0] = normalList[index * 3 + 0];\n    normals[i * 3 + 1] = normalList[index * 3 + 1];\n    normals[i * 3 + 2] = normalList[index * 3 + 2];\n  }\n\n  // Must be either unsigned short or unsigned byte.\n  size = vertexIndices.length;\n  const indices = new Uint16Array(size);\n  for (let i = 0; i < size; ++i) {\n    indices[i] = i;\n  }\n\n  if (quad) {\n    console.warn('WebGL does not support quad faces, only triangles.');\n  }\n\n  return {\n    positions,\n    texcoords,\n    normals,\n    indices,\n  };\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<string>}\n */\nexport async function TextLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return TextLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return new TextDecoder().decode(arrayBuffer);\n}\n","import { unzip } from 'fflate';\n\nimport { cacheInStore } from './AssetStore.js';\nimport { AssetManager } from './AssetManager.js';\nimport { AssetRef } from './AssetRef.js';\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {string} url\n * @param {(src: Uint8Array, path: string) => void} callback\n */\nexport async function loadAssetPack(url, callback) {\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    callback(buf, path);\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {AssetManager} assets\n * @param {string} url\n * @param {(src: Uint8Array, uri: string, path: string) => void} [callback]\n */\nexport async function cacheAssetPackAsRaw(assets, url, callback = undefined) {\n    const assetStore = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (assets));\n    let rootPath = 'raw://';\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    // Remove the zip directory name\n                    let i = path.indexOf('/');\n                    if (i >= 0) {\n                        path = path.substring(i + 1);\n                    }\n                    // Put the raw file in cache\n                    let uri = rootPath + path;\n                    cacheInStore(assetStore, uri, buf);\n                    if (callback) {\n                        callback(buf, uri, path);\n                    }\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * This is the same as calling `await AssetRef.load()` for each ref.\n * \n * @param {AssetManager} assets\n * @param {Array<AssetRef<?, ?>>} refs \n * @param {number} [timeout] \n */\nexport async function preloadAssetRefs(assets, refs, timeout = 5000) {\n    let promises = [];\n    for (let ref of refs) {\n        promises.push(ref.load(assets, timeout));\n    }\n    await Promise.allSettled(promises);\n}\n"],"names":["GlobExp","constructor","pattern","source","String","this","_re","makeRe","test","string","FILE_URI_PREFIX_PATTERN","async","loadInStore","assets","uri","src","loader","opts","timeout","loadings","loading","Loading","attempt","nextAttempt","promises","promise","push","getLoadedInStore","then","cached","value","isCurrentAttempt","cacheInStore","undefined","Promise","race","store","resolve","getCurrentInStore","isAssetCachedInStore","isAssetLoadingInStore","Fallback","glob","static","_promiseHandle","_resolve","_reject","_reason","_value","_timeoutHandle","Number","isFinite","setTimeout","reject","_promise","clearTimeout","reason","AssetRef","filepath","initial","current","cache","assetManager","get","result","exists","load","reload","TAG_PATTERN","LINE_PATTERN","parseBMLine","out","line","props","split","prop","array","exec","_","key","JSON","parse","length","parent","defaults","def","getDefaultInStore","Error","fallback","uriGlob","cacheDefaultInStore","unload","unloadInStore","clear","Object","entries","keys","clearInStore","Boolean","hasInStore","getLoadingInStore","keysInStore","reset","resetStore","AtlasLoader","onprogress","response","fetch","arrayBuffer","ArrayBuffer","isView","lines","TextDecoder","decode","progressTotal","progressLoaded","trim","startsWith","args","i","j","indexOf","substring","name","u","parseInt","v","w","h","frames","cols","rows","Math","ceil","AudioBufferLoader","audioContext","audioArrayBuffer","byteLength","Uint8Array","set","decodeAudioData","BMFontLoader","info","common","page","chars","kernings","tag","char","kerning","ImageLoader","imageType","lastIndexOf","slice","blob","Blob","type","imageUrl","URL","createObjectURL","image","Image","addEventListener","e","JSONLoader","OBJLoader","vertexList","texcoordList","normalList","vertexIndices","texcoordIndices","normalIndices","commentPattern","vertexPattern","normalPattern","texcoordPattern","facePattern","faceVertexPattern","x","y","z","index","size","quad","replace","parseFloat","isNaN","positions","Float32Array","texcoords","normals","indices","Uint16Array","console","warn","TextLoader","url","callback","assetStore","unzip","err","data","path","buf","replaceAll","refs","ref","allSettled"],"mappings":"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"}