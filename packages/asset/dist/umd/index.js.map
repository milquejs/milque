{"version":3,"file":"index.js","sources":["../../../../node_modules/picomatch/lib/constants.js","../../../../node_modules/picomatch/lib/utils.js","../../../../node_modules/picomatch/lib/scan.js","../../../../node_modules/picomatch/lib/parse.js","../../../../node_modules/picomatch/lib/picomatch.js","../../../../node_modules/picomatch/index.js","../../src/GlobExp.js","../../src/local/LocalAssetStore.js","../../src/local/LocalAsset.js","../../src/Asset.js"],"sourcesContent":["'use strict';\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst SEP = '/';\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR,\n  SEP\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n  SEP: '\\\\'\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    __proto__: null,\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","/*global navigator*/\n'use strict';\n\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.isWindows = () => {\n  if (typeof navigator !== 'undefined' && navigator.platform) {\n    const platform = navigator.platform.toLowerCase();\n    return platform === 'win32' || platform === 'windows';\n  }\n\n  if (typeof process !== 'undefined' && process.platform) {\n    return process.platform === 'win32';\n  }\n\n  return false;\n};\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\nexports.basename = (path, { windows } = {}) => {\n  const segs = path.split(windows ? /[\\\\/]/ : '/');\n  const last = segs[segs.length - 1];\n\n  if (last === '') {\n    return segs[segs.length - 2];\n  }\n\n  return last;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = opts.windows;\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(utils.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst pico = require('./lib/picomatch');\nconst utils = require('./lib/utils');\n\nfunction picomatch(glob, options, returnState = false) {\n  // default to os.platform()\n  if (options && (options.windows === null || options.windows === undefined)) {\n    // don't mutate the original options object\n    options = { ...options, windows: utils.isWindows() };\n  }\n\n  return pico(glob, options, returnState);\n}\n\nObject.assign(picomatch, pico);\nmodule.exports = picomatch;\n","import { makeRe } from 'picomatch';\n\nexport class GlobExp {\n  /**\n   * @param {string|GlobExp} pattern\n   */\n  constructor(pattern) {\n    let source;\n    if (typeof pattern === 'object' && pattern instanceof GlobExp) {\n      source = String(pattern.source);\n    } else {\n      source = String(pattern);\n    }\n    /** @type {string} */\n    this.source = source;\n\n    /** @private */\n    this.re = makeRe(source);\n  }\n\n  /**\n   * @param {string} string\n   * @returns {boolean}\n   */\n  test(string) {\n    return this.re.test(string);\n  }\n}\n","import { GlobExp } from '../GlobExp';\n\nexport function createStore() {\n  return {\n    /** @type {Record<string, any>} */\n    cached: {},\n    /** @type {Record<string, Loading>} */\n    loadings: {},\n    /** @type {Array<Fallback>} */\n    defaults: [],\n  };\n}\n\n/**\n * Load asset using a loader with the given filePath.\n * \n * @private\n * @template T\n * @template {object} Options\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @param {string} filePath\n * @param {import('../AssetTypes').AssetLoader<T, Options>} loader\n * @param {Options} opts\n * @param {number} timeout\n * @returns {Promise<T>}\n */\nexport async function loadThenCache(assets, uri, filePath, loader, opts, timeout) {\n  const { loadings } = assets;\n\n  /** @type {Loading} */\n  let loading;\n  if (uri in loadings) {\n    loading = loadings[uri];\n  } else {\n    loading = new Loading(timeout);\n    loadings[uri] = loading;\n  }\n\n  const attempt = Loading.nextAttempt(loading);\n\n  /** @type {Array<Promise<T|undefined>>} */\n  let promises = [loading.promise];\n  // Just load it\n  promises.push(\n    loader(filePath, opts, assets).then((value) => {\n      if (Loading.isCurrentAttempt(loading, attempt)) {\n        cacheAndResolve(assets, uri, value);\n        return value;\n      } else {\n        return undefined;\n      }\n    }),\n  );\n  let result = await Promise.race(promises);\n  if (!result) {\n    // It must be loading in a different attempt.\n    throw new Error('Failed to load asset - already loaded!');\n  }\n  return result;\n}\n\n/**\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets \n * @param {Array<import('../AssetTypes').AssetLike<?, ?>>} targets \n * @param {number} timeout\n */\nexport async function loadAll(assets, targets, timeout) {\n  await Promise.all(targets.map(target => loadThenCache(\n    assets, target.uri, target.uri, target.loader, target.opts, timeout)));\n}\n\n/**\n * @internal\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @param {T} value\n */\nexport function cacheAndResolve(assets, uri, value) {\n  const { cached, loadings } = assets;\n  cached[uri] = value;\n  // Send asset to awaiting loaders...\n  if (uri in loadings) {\n    loadings[uri].resolve(value);\n    delete loadings[uri];\n  }\n}\n\n/**\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string|GlobExp} glob\n * @param {T} value\n */\nexport function fallbackFor(assets, glob, value) {\n  const { defaults } = assets;\n  if (typeof glob === 'string') {\n    glob = new GlobExp(glob);\n  }\n  const uri = `__default://[${defaults.length}]`;\n  cacheAndResolve(assets, uri, value);\n  defaults.push(new Fallback(glob, uri));\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n */\nexport function deleteAndReject(assets, uri) {\n  const { cached } = assets;\n  cancelAndReject(assets, uri, \"Cancel loading since deleting asset.\");\n  if (uri in cached) {\n    delete cached[uri];\n  }\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string|GlobExp} glob\n */\nexport function deleteAndRejectByGlob(assets, glob) {\n  if (typeof glob === 'string') {\n    glob = new GlobExp(glob);\n  }\n  const { cached, loadings } = assets;\n  // Clear loadings\n  for (let uri of Object.keys(loadings)) {\n    if (glob.test(uri)) {\n      cancelAndReject(assets, uri, `Cancel loading since deleting all assets for \"${glob}\".`);\n    }\n  }\n  // Clear cache\n  for (let uri of Object.keys(cached)) {\n    if (glob.test(uri)) {\n      delete cached[uri];\n    }\n  }\n}\n\n/**\n * Cancel loading the uri, if loading. Otherwise, do nothing and return false.\n * \n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @param {string} [rejectMessage]\n */\nexport function cancelAndReject(assets, uri, rejectMessage = 'Cancel loading asset.') {\n  const { loadings } = assets;\n  if (uri in loadings) {\n    const loading = loadings[uri];\n    loading.reject(new Error(rejectMessage));\n    delete loadings[uri];\n    return true;\n  }\n  return false;\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets \n * @param {string} uri \n * @param {number} timeout\n * @returns {Promise<object>}\n */\nexport async function promiseWhenLoaded(assets, uri, timeout) {\n  const { loadings } = assets;\n  if (uri in loadings) {\n    return loadings[uri].promise;\n  } else {\n    let loading = new Loading(timeout);\n    loadings[uri] = loading;\n    return loading.promise;\n  }\n}\n\n/**\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n */\nexport function resetStore(assets) {\n  const { cached, loadings, defaults } = assets;\n  // Clear loadings\n  for (let uri of Object.keys(loadings)) {\n    cancelAndReject(assets, uri, \"Cancel loading asset - clearing all.\");\n  }\n  // Clear cache\n  for (let uri of Object.keys(cached)) {\n    delete cached[uri];\n  }\n  // Clear defaults\n  defaults.length = 0;\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @returns {Promise<object>}\n */\nexport function currentLoading(assets, uri) {\n  const { loadings } = assets;\n  if (uri in loadings) {\n    return loadings[uri].promise;\n  } else {\n    throw new Error(`No loading promise in store for uri \"${uri}\".`);\n  }\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @returns {object|null}\n */\nexport function currentFallback(assets, uri) {\n  const { defaults } = assets;\n  for (let def of defaults) {\n    if (def.glob.test(uri) && hasCurrentValue(assets, def.uri)) {\n      return currentValue(assets, def.uri);\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @returns {object}\n */\nexport function currentValue(assets, uri) {\n  if (uri in assets.cached) {\n    return assets.cached[uri];\n  } else {\n    throw new Error(`No current asset cached for uri \"${uri}\".`);\n  }\n}\n\n/**\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @returns {Array<string>}\n */\nexport function keys(assets) {\n  return Object.keys(assets.cached);\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @returns {boolean}\n */\nexport function hasCurrentValue(assets, uri) {\n  return uri in assets.cached;\n}\n\n/**\n * @internal\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {string} uri\n * @returns {boolean}\n */\nexport function isCurrentLoading(assets, uri) {\n  return uri in assets.loadings;\n}\n\nexport class Fallback {\n  /**\n   * @param {GlobExp} glob\n   * @param {string} uri\n   */\n  constructor(glob, uri) {\n    this.glob = glob;\n    this.uri = uri;\n  }\n}\n\nexport class Loading {\n  /**\n   * @param {Loading} loading\n   */\n  static nextAttempt(loading) {\n    return ++loading.promiseHandle;\n  }\n\n  /**\n   * @param {Loading} loading\n   * @param {number} attempt\n   */\n  static isCurrentAttempt(loading, attempt) {\n    return loading.promiseHandle === attempt;\n  }\n\n  /**\n   * @param {number} timeout\n   */\n  constructor(timeout) {\n    /**\n     * @private\n     * @type {((value: any) => void)|null}\n     */\n    this._resolve = null;\n    /**\n     * @private\n     * @type {((reason?: any) => void)|null}\n     */\n    this._reject = null;\n    /** @private */\n    this._reason = null;\n    /** @private */\n    this._value = null;\n\n    /** @private */\n    this.promiseHandle = 0;\n    /** @private */\n    this.timeoutHandle =\n      Number.isFinite(timeout) && timeout > 0\n        ? setTimeout(() => {\n            this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n          }, timeout)\n        : null;\n    /**\n     * @readonly\n     */\n    this.promise = new Promise((resolve, reject) => {\n      if (this._value) {\n        resolve(this._value);\n      } else {\n        this._resolve = resolve;\n      }\n      if (this._reason) {\n        reject(this._reason);\n      } else {\n        this._reject = reject;\n      }\n    });\n  }\n\n  /**\n   * @param {any} value\n   */\n  resolve(value) {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n      this.timeoutHandle = null;\n    }\n    if (this._resolve) {\n      this._resolve(value);\n    } else {\n      this._value = value;\n    }\n  }\n\n  /**\n   * @param {any} reason\n   */\n  reject(reason) {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n      this.timeoutHandle = null;\n    }\n    if (this._reject) {\n      this._reject(reason);\n    } else {\n      this._reason = reason;\n    }\n  }\n}\n","import {\n  cacheAndResolve,\n  currentValue,\n  currentFallback,\n  currentLoading,\n  hasCurrentValue,\n  isCurrentLoading,\n  loadThenCache,\n  cancelAndReject,\n  deleteAndReject,\n} from './LocalAssetStore';\n\n/**\n * @template T\n * @template {object} Options\n * @param {string} uri\n * @param {import('../AssetTypes').AssetLoader<T, Options>} loader\n * @param {Options} [opts]\n */\nexport function create(uri, loader, opts = /** @type {any} */ ({})) {\n  return /** @type {const} */ ({\n    uri,\n    loader,\n    opts,\n  });\n}\n\n/**\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<any, any>} target\n * @returns {boolean}\n */\nexport function isCached(assets, target) {\n  return hasCurrentValue(assets, target.uri);\n}\n\n/**\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @returns {T|null}\n */\nexport function getOrNull(assets, target) {\n  if (hasCurrentValue(assets, target.uri)) {\n    return /** @type {T} */ (currentValue(assets, target.uri));\n  }\n  const def = currentFallback(assets, target.uri);\n  if (def) {\n    return /** @type {T} */ (def);\n  }\n  return null;\n}\n\n/**\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @returns {T}\n */\nexport function getOrThrow(assets, target) {\n  let result = getOrNull(assets, target);\n  if (result !== null) {\n    return result;\n  }\n  throw new Error(\n    `Trying to get value from asset not yet loaded \"${target.uri}\".`\n  );\n}\n\n/**\n * Pre-load target into cache ONLY if not yet loaded or loading. Otherwise, will throw.\n * \n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @param {number} timeout\n * @returns {Promise<T>}\n */\nexport async function preload(assets, target, timeout) {\n  if (hasCurrentValue(assets, target.uri)) {\n    throw new Error(`Asset already cached for \"${target.uri}\" - probably trying to load duplicate asset name!`);\n  } else if (isCurrentLoading(assets, target.uri)) {\n    throw new Error(`Asset already loading for \"${target.uri}\" - if this is intentional, use load() instead!`);\n  }\n  return await loadThenCache(\n    assets,\n    target.uri,\n    target.uri,\n    target.loader,\n    target.opts,\n    timeout\n  );\n}\n\n/**\n * Load target into cache if not yet loaded. Otherwise, return already cached value or loading promise.\n * \n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @param {number} timeout\n * @returns {Promise<T>}\n */\nexport async function load(assets, target, timeout) {\n  if (hasCurrentValue(assets, target.uri)) {\n    return /** @type {T} */ (currentValue(assets, target.uri));\n  } else if (isCurrentLoading(assets, target.uri)) {\n    return /** @type {T} */ (\n      await currentLoading(assets, target.uri)\n    );\n  }\n  return await loadThenCache(\n    assets,\n    target.uri,\n    target.uri,\n    target.loader,\n    target.opts,\n    timeout\n  );\n}\n\n/**\n * Re-load target into cache. Will always replace cached value.\n * \n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @param {number} timeout\n * @returns {Promise<T>}\n */\nexport async function reload(assets, target, timeout) {\n  return await loadThenCache(\n    assets,\n    target.uri,\n    target.uri,\n    target.loader,\n    target.opts,\n    timeout\n  );\n}\n\n/**\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @returns {Promise<boolean>}\n */\nexport async function cancel(assets, target) {\n  return cancelAndReject(assets, target.uri);\n}\n\n/**\n * Cache target with value. Will always replace cached value.\n * \n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @param {T} value\n */\nexport async function cachePut(assets, target, value) {\n  cacheAndResolve(assets, target.uri, value);\n}\n\n/**\n * Cache target with value ONLY if not yet loaded or loading. Otherwise, will throw.\n * \n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n * @param {T} value\n */\nexport async function cacheSafely(assets, target, value) {\n  if (hasCurrentValue(assets, target.uri)) {\n    throw new Error(`Asset already cached for \"${target.uri}\" - probably trying to cache duplicate asset name!`);\n  } else if (isCurrentLoading(assets, target.uri)) {\n    throw new Error(`Asset already loading for \"${target.uri}\" - if this is intentional, use cachePut() instead!`);\n  }\n  cacheAndResolve(assets, target.uri, value);\n}\n\n/**\n * @template T\n * @param {import('./AssetStoreTypes').AssetStoreLike} assets\n * @param {import('../AssetTypes').AssetLike<T, any>} target\n */\nexport async function dispose(assets, target) {\n  deleteAndReject(assets, target.uri);\n}\n","import { LocalAsset, LocalAssetStore } from './local';\n\n/**\n * @template T\n * @template {object} Options\n * \n * A global reference to the resource by name and loader type.\n */\nexport class Asset {\n\n  /** The default timeout for loading assets. */\n  static DEFAULT_TIMEOUT = 5_000;\n  /** The global asset store. */\n  static globalCache = LocalAssetStore.createStore();\n\n  /**\n   * Create an asset to load target resource from uri. Assets with\n   * the same uri will share the same resource instance.\n   * \n   * @template T\n   * @template {object} Options\n   * @param {string} uri \n   * @param {import('./AssetTypes').AssetLoader<T, Options>} loader \n   * @param {Options} opts \n   */\n  static for(uri, loader, opts) {\n    return new Asset(uri, loader, opts);\n  }\n\n  /**\n   * @private\n   * @param {string} uri \n   * @param {import('./AssetTypes').AssetLoader<T, Options>} loader \n   * @param {Options} opts \n   */\n  constructor(uri, loader, opts) {\n    /** @readonly */\n    this.uri = uri;\n    /** @readonly */\n    this.loader = loader;\n    /** @readonly */\n    this.opts = opts;\n  }\n\n  /** Whether this asset has a loaded value in the global cache. */\n  isCached() {\n    return LocalAsset.isCached(Asset.globalCache, this);\n  }\n\n  /** Get the cached or default asset value. Returns null if not present. */\n  getOrNull() {\n    return LocalAsset.getOrNull(Asset.globalCache, this);\n  }\n\n  /** Get the cached or default asset value. Throws if not present. */\n  getOrThrow() {\n    return LocalAsset.getOrThrow(Asset.globalCache, this);\n  }\n\n  /** Try load and cache the result for this asset, only if not yet loaded. */\n  async load(timeout = Asset.DEFAULT_TIMEOUT) {\n    return await LocalAsset.load(Asset.globalCache, this, timeout);\n  }\n\n  /** Force load and cache the result for this asset, even if already exists. */\n  async reload(timeout = Asset.DEFAULT_TIMEOUT) {\n    return await LocalAsset.reload(Asset.globalCache, this, timeout);\n  }\n\n  /** Perform load and cache the result for this asset, throws if already exists. */\n  async preload(timeout = Asset.DEFAULT_TIMEOUT) {\n    return await LocalAsset.preload(Asset.globalCache, this, timeout);\n  }\n\n  /** Cancel any ongoing loading attempts for this asset. */\n  async cancel() {\n    return LocalAsset.cancel(Asset.globalCache, this);\n  }\n\n  /**\n   * Put and override value in cache even if loaded already.\n   * \n   * @param {T} value \n   */\n  async cachePut(value) {\n    LocalAsset.cachePut(Asset.globalCache, this, value);\n  }\n\n  /**\n   * Put value in cache only if never loaded.\n   * \n   * @param {T} value \n   */\n  async cacheSafely(value) {\n    LocalAsset.cacheSafely(Asset.globalCache, this, value);\n  }\n\n  /**\n   * Delete the value in cache for this asset, if already loaded.\n   */\n  async dispose() {\n    LocalAsset.dispose(Asset.globalCache, this);\n  }\n}\n"],"names":["WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","SLASH_LITERAL","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","POSIX_CHARS","PLUS_LITERAL","QMARK_LITERAL","ONE_CHAR","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","SEP","WINDOWS_CHARS","constants","MAX_LENGTH","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","__proto__","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_GRAVE_ACCENT","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","extglobChars","chars","type","open","close","globChars","win32","require$$0","exports","isObject","val","Array","isArray","hasRegexChars","str","test","isRegexChar","length","escapeRegex","replace","toPosixSlashes","isWindows","navigator","platform","toLowerCase","process","removeBackslashes","match","escapeLast","input","char","lastIdx","idx","lastIndexOf","slice","removePrefix","state","output","startsWith","prefix","wrapOutput","options","contains","negated","basename","path","windows","segs","split","last","utils","require$$1","isPathSeparator","code","depth","token","isPrefix","isGlobstar","Infinity","scan_1","opts","scanToEnd","parts","slashes","tokens","prev","index","start","lastIndex","isBrace","isBracket","isGlob","isExtglob","braceEscaped","backslashes","negatedExtglob","finished","braces","value","eos","peek","charCodeAt","advance","next","noext","nonegate","noparen","push","base","glob","unescape","maxDepth","prevIndex","n","i","expandRange","args","sort","join","RegExp","ex","map","v","syntaxError","parse","TypeError","max","maxLength","Math","min","len","SyntaxError","bos","prepend","capture","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noextglob","consumed","backtrack","brackets","parens","quotes","extglobs","stack","remaining","consume","num","append","negate","count","increment","decrement","pop","tok","extglob","inner","extglobOpen","conditions","extglobClose","rest","extglobStar","includes","expression","fastpaths","m","esc","first","repeat","exec","posix","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","unshift","comma","out","toks","t","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","suffix","slashDot","create","source","parse_1","scan","require$$2","require$$3","picomatch","returnState","fns","arrayMatcher","isMatch","isState","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","result","onIgnore","format","matchBase","Boolean","patterns","pattern","p","returnOutput","toRegex","parsed","flags","nocase","err","debug","picomatch_1","pico","undefined","Object","assign","GlobExp","constructor","String","this","re","string","createStore","cached","loadings","defaults","async","loadThenCache","assets","uri","filePath","loader","timeout","loading","Loading","attempt","nextAttempt","promises","promise","then","isCurrentAttempt","cacheAndResolve","Promise","race","Error","resolve","deleteAndReject","cancelAndReject","rejectMessage","reject","currentLoading","currentFallback","def","hasCurrentValue","currentValue","isCurrentLoading","Fallback","promiseHandle","_resolve","_reject","_reason","_value","timeoutHandle","Number","isFinite","setTimeout","clearTimeout","reason","keys","targets","all","target","isCached","getOrNull","getOrThrow","preload","load","reload","cancel","cachePut","cacheSafely","dispose","Asset","static","LocalAsset.isCached","globalCache","LocalAsset.getOrNull","LocalAsset.getOrThrow","DEFAULT_TIMEOUT","LocalAsset.load","LocalAsset.reload","LocalAsset.preload","LocalAsset.cancel","LocalAsset.cachePut","LocalAsset.cacheSafely","LocalAsset.dispose"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}