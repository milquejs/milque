{"version":3,"file":"index.js","sources":["../../src/ByteReader.js","../../../color/dist/esm/index.js","../../src/AsepriteBytesHelper.js","../../src/AsepriteChunkPalette.js","../../src/AsepriteChunkLayer.js","../../src/AsepritePixelFormats.js","../../src/AsepriteChunkCel.js","../../src/AsepriteChunkCelExtra.js","../../src/AsepriteChunkColorProfile.js","../../src/AsepriteChunkExternalFiles.js","../../src/AsepriteChunkTags.js","../../src/AsepriteChunkUserData.js","../../src/AsepriteChunkSlice.js","../../src/AsepriteChunkTileset.js","../../src/AsepriteChunkTypes.js","../../src/AsepriteChunks.js","../../src/AsepriteFile.js","../../src/Aseprite.js"],"sourcesContent":["export class ByteReader {\n\n  /**\n   * @param {ArrayBuffer} arrayBuffer\n   * @param {number} [byteOffset]\n   * @param {number} [byteLength]\n   * @param {boolean} [littleEndian]\n   */\n  constructor(arrayBuffer, byteOffset = 0, byteLength = arrayBuffer.byteLength, littleEndian = true) {\n    /** @readonly */\n    this.buffer = arrayBuffer;\n    /** @readonly */\n    this.view = new DataView(arrayBuffer, byteOffset, byteLength);\n    /** @readonly */\n    this.littleEndian = littleEndian;\n\n    /** @protected */\n    this.offset = 0;\n  }\n\n  /**\n   * @param {number} numBytes \n   */\n  skipBytes(numBytes) {\n    this.offset += numBytes;\n  }\n\n  /**\n   * The next 8-bit unsigned value.\n   */\n  nextByte() {\n    let result = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return result;\n  }\n\n  /**\n   * The next 16-bit unsigned value.\n   */\n  nextWord() {\n    let result = this.view.getUint16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return result;\n  }\n\n  /**\n   * The next 16-bit signed value.\n   */\n  nextShort() {\n    let result = this.view.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return result;\n  }\n\n  /**\n   * The next 32-bit unsigned value.\n   */\n  nextDoubleWord() {\n    let result = this.view.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return result;\n  }\n\n  /**\n   * The next 32-bit signed value.\n   */\n  nextLong() {\n    let result = this.view.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return result;\n  }\n\n  /**\n   * The next 64-bit signed value.\n   */\n  nextDoubleLong() {\n    let result = this.view.getBigInt64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return result;\n  }\n\n  /**\n   * The next 64-bit unsigned value.\n   */\n  nextQuadWord() {\n    let result = this.view.getBigUint64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return result;\n  }\n\n  /**\n   * The next 32-bit fixed-point 16.16 value.\n   */\n  nextFixed() {\n    // TODO: Today, this is the same as getting a float32.\n    const fixed = this.view.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return fixed;\n  }\n\n  /**\n   * The next 32-bit single-precision value.\n   */\n  nextFloat() {\n    const result = this.view.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return result;\n  }\n\n  /**\n   * The next 64-bit double-precision value.\n   */\n  nextDouble() {\n    const result = this.view.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return result;\n  }\n\n  /**\n   * A slice of the next N-bytes.\n   * \n   * @param {number} numBytes \n   */\n  nextBytes(numBytes) {\n    let result = this.buffer.slice(this.offset, this.offset + numBytes);\n    this.offset += numBytes;\n    return result;\n  }\n\n  /**\n   * A slice of all remaining bytes in view.\n   */\n  remainingBytes() {\n    let numBytes = this.view.byteLength - this.offset;\n    return this.nextBytes(numBytes);\n  }\n}\n","/**\n * @typedef {ReturnType<create>} RGBA\n */\n\nfunction create$1() {\n  return 0x0;\n}\n\n/**\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n * @param {number} [alpha]\n */\nfunction fromBytes$1(red, green, blue, alpha = 0xff) {\n  return (\n    ((alpha & 0xff) << 24) | ((red & 0xff) << 16) | ((green & 0xff) << 8) | (blue & 0xff)\n  );\n}\n\n/**\n * @param {number} redf\n * @param {number} greenf\n * @param {number} bluef\n * @param {number} alphaf\n */\nfunction fromFloats$1(redf, greenf, bluef, alphaf = 1.0) {\n  let r = Math.floor(Math.max(Math.min(redf, 1), 0) * 255);\n  let g = Math.floor(Math.max(Math.min(greenf, 1), 0) * 255);\n  let b = Math.floor(Math.max(Math.min(bluef, 1), 0) * 255);\n  let a = Math.floor(Math.max(Math.min(alphaf, 1), 0) * 255);\n  return fromBytes$1(r, g, b, a);\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction red(hexValue) {\n  return (hexValue >> 16) & 0xff;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction redf(hexValue) {\n  return ((hexValue >> 16) & 0xff) / 255.0;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction green(hexValue) {\n  return (hexValue >> 8) & 0xff;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction greenf(hexValue) {\n  return ((hexValue >> 8) & 0xff) / 255.0;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction blue(hexValue) {\n  return hexValue & 0xff;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction bluef(hexValue) {\n  return (hexValue & 0xff) / 255.0;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction alpha$1(hexValue) {\n  let result = (hexValue >> 24) & 0xff;\n  if (result === 0x00) {\n    return 0xff;\n  }\n  return result;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction alphaf$1(hexValue) {\n  return alpha$1(hexValue) / 255.0;\n}\n\nconst OPACITY_EPSILON$1 = 0.01;\n\n/**\n * @param {RGBA} from\n * @param {RGBA} to\n * @param {number} delta\n */\nfunction mix$1(from = 0x000000, to = 0xffffff, delta = 0.5) {\n  const rm = redf(from);\n  const gm = greenf(from);\n  const bm = bluef(from);\n  const am = alphaf$1(from);\n  const rf = (redf(to) - rm) * delta + rm;\n  const gf = (greenf(to) - gm) * delta + gm;\n  const bf = (bluef(to) - bm) * delta + bm;\n  /** @type {number|undefined} */\n  let af = (alphaf$1(to) - am) * delta + am;\n  if (af < OPACITY_EPSILON$1) {\n    af = undefined;\n  }\n  return fromFloats$1(rf, gf, bf, af);\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction toCSSColorString$1(hexValue) {\n  if (typeof hexValue !== 'number') {\n    throw new Error('Not a valid number for hex color value.');\n  }\n  let r = red(hexValue).toString(16).padStart(2, '0');\n  let g = green(hexValue).toString(16).padStart(2, '0');\n  let b = blue(hexValue).toString(16).padStart(2, '0');\n  return `#${r}${g}${b}`;\n}\n\n/**\n * @param {RGBA} hexValue\n */\nfunction toFloatVector$1(hexValue) {\n  if (typeof hexValue !== 'number') {\n    throw new Error('Not a valid number for hex color value.');\n  }\n  return [redf(hexValue), greenf(hexValue), bluef(hexValue), alphaf$1(hexValue)];\n}\n\nvar rgba = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  alpha: alpha$1,\n  alphaf: alphaf$1,\n  blue: blue,\n  bluef: bluef,\n  create: create$1,\n  fromBytes: fromBytes$1,\n  fromFloats: fromFloats$1,\n  green: green,\n  greenf: greenf,\n  mix: mix$1,\n  red: red,\n  redf: redf,\n  toCSSColorString: toCSSColorString$1,\n  toFloatVector: toFloatVector$1\n});\n\n/**\n * @typedef {ReturnType<create>} Grayscale\n */\n\nfunction create() {\n  return 0x0;\n}\n\n/**\n * @param {number} gray\n * @param {number} alpha\n */\nfunction fromBytes(gray, alpha = 0xff) {\n  return (\n    ((alpha & 0xff) << 8) | (gray & 0xff)\n  );\n}\n\n/**\n * @param {number} grayf\n * @param {number} alphaf\n */\nfunction fromFloats(grayf, alphaf = 1.0) {\n  let g = Math.floor(Math.max(Math.min(grayf, 1), 0) * 255);\n  let a = Math.floor(Math.max(Math.min(alphaf, 1), 0) * 255);\n  return fromBytes(g, a);\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction gray(hexValue) {\n  return hexValue & 0xff;\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction grayf(hexValue) {\n  return (hexValue & 0xff) / 255.0;\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction alpha(hexValue) {\n  let result = (hexValue >> 8) & 0xff;\n  if (result === 0x00) {\n    return 0xff;\n  }\n  return result;\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction alphaf(hexValue) {\n  return alpha(hexValue) / 255.0;\n}\n\nconst OPACITY_EPSILON = 0.01;\n\n/**\n * @param {Grayscale} from\n * @param {Grayscale} to\n * @param {number} delta\n */\nfunction mix(from = 0x0000, to = 0xffff, delta = 0.5) {\n  const gm = grayf(from);\n  const am = alphaf(from);\n  const gf = (grayf(to) - gm) * delta + gm;\n  /** @type {number|undefined} */\n  let af = (alphaf(to) - am) * delta + am;\n  if (af < OPACITY_EPSILON) {\n    af = undefined;\n  }\n  return fromFloats(gf, af);\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction toCSSColorString(hexValue) {\n  if (typeof hexValue !== 'number') {\n    throw new Error('Not a valid number for hex color value.');\n  }\n  let g = gray(hexValue).toString(16).padStart(2, '0');\n  return `#${g}${g}${g}`;\n}\n\n/**\n * @param {Grayscale} hexValue\n */\nfunction toFloatVector(hexValue) {\n  if (typeof hexValue !== 'number') {\n    throw new Error('Not a valid number for hex color value.');\n  }\n  return [grayf(hexValue), alphaf(hexValue)];\n}\n\nvar grayscale = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  alpha: alpha,\n  alphaf: alphaf,\n  create: create,\n  fromBytes: fromBytes,\n  fromFloats: fromFloats,\n  gray: gray,\n  grayf: grayf,\n  mix: mix,\n  toCSSColorString: toCSSColorString,\n  toFloatVector: toFloatVector\n});\n\nexport { grayscale, rgba };\n//# sourceMappingURL=index.js.map\n","import { grayscale, rgba } from '@milquejs/color';\n\nimport { ByteReader } from './ByteReader';\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder \n */\nexport function readAsepriteStringBytes(data, textDecoder) {\n  const numBytes = data.nextWord();\n  const stringBuffer = data.nextBytes(numBytes);\n  return textDecoder.decode(stringBuffer);\n}\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteRGBAPixelBytes(data) {\n  const red = data.nextByte();\n  const green = data.nextByte();\n  const blue = data.nextByte();\n  const alpha = data.nextByte();\n  return rgba.fromBytes(red, green, blue, alpha);\n}\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteGrayscalePixelBytes(data) {\n  const gray = data.nextByte();\n  const alpha = data.nextByte();\n  return grayscale.fromBytes(gray, alpha);\n}\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteIndexedPixelBytes(data) {\n  const index = data.nextByte();\n  return index;\n}\n","import { rgba } from '@milquejs/color';\nimport { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\n/**\n * @param {ByteReader} data \n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkPalette(data, textDecoder) {\n  /** @type {Array<AsepritePaletteColor>} */\n  let colors = [];\n  const paletteSize = data.nextDoubleWord();\n  const firstColor = data.nextDoubleWord();\n  const lastColor = data.nextDoubleWord();\n  data.skipBytes(8); // Zeroes (for future)\n  for(let i = 0; i < paletteSize; ++i) {\n    const flags = data.nextWord();\n    const red = data.nextByte();\n    const green = data.nextByte();\n    const blue = data.nextByte();\n    const alpha = data.nextByte();\n    let name;\n    if (flags === 1) {\n      name = readAsepriteStringBytes(data, textDecoder);\n    }\n    let color = createAsepritePaletteColor(red, green, blue, alpha, name);\n    colors.push(color);\n  }\n  return {\n    /** Number of color entries. */\n    paletteSize,\n    /** Index of the first color to change. */\n    firstColor,\n    /** Index of the last color to change. */\n    lastColor,\n    colors,\n  };\n}\n\n/** @typedef {ReturnType<createAsepritePaletteColor>} AsepritePaletteColor */\n\n/**\n * @param {number} red\n * @param {number} green \n * @param {number} blue\n * @param {number} alpha\n * @param {string} [name]\n */\nfunction createAsepritePaletteColor(red, green, blue, alpha, name = 'none') {\n  return {\n    name,\n    value: rgba.fromBytes(red, green, blue, alpha),\n  };\n}\n","import { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\n/** @typedef {AsepriteBlendModes[keyof AsepriteBlendModes]} AsepriteBlendMode */\n\nexport const AsepriteBlendModes = /** @type {const} */ ({\n  NORMAL: 0,\n  MULTIPLY: 1,\n  SCREEN: 2,\n  OVERLAY: 3,\n  DARKEN: 4,\n  LIGHTEN: 5,\n  COLOR_DODGE: 6,\n  COLOR_BURN: 7,\n  HARD_LIGHT: 8,\n  SOFT_LIGHT: 9,\n  DIFFERENCE: 10,\n  EXCLUSION: 11,\n  HUE: 12,\n  SATURATION: 13,\n  COLOR: 14,\n  LUMINOSITY: 15,\n  ADDITION: 16,\n  SUBTRACT: 17,\n  DIVIDE: 18\n});\n\nexport const AsepriteLayerFlags = /** @type {const} */ ({\n  VISIBLE: 1,\n  EDITABLE: 2,\n  LOCK_MOVEMENT: 4,\n  BACKGROUND: 8,\n  PREFER_LINKED_CELS: 16,\n  COLLAPSED_LAYER_GROUP: 32,\n  IS_REFERENCE_LAYER: 64\n});\n\n/**\n * @param {ByteReader} data \n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkLayer(data, textDecoder) {\n  const flags = data.nextWord();\n  const layerType = data.nextWord();\n  const childLevel = data.nextWord();\n  data.nextWord(); // Ignored (default layer width in pixels)\n  data.nextWord(); // Ignored (default layer height in pixels)\n  const blendMode = /** @type {AsepriteBlendMode} */ (data.nextWord());\n  const opacity = data.nextByte();\n  data.skipBytes(3); // Zeroes (for future)\n  const layerName = readAsepriteStringBytes(data, textDecoder);\n  let tilesetIndex = 0;\n  if (layerType === 2) {\n    tilesetIndex = data.nextDoubleWord();\n  }\n  return {\n    flags,\n    layerType,\n    childLevel,\n    blendMode,\n    opacity,\n    layerName,\n    tilesetIndex,\n  };\n}\n","/** @typedef {AsepritePixelFormats[keyof AsepritePixelFormats]} AsepritePixelFormat */\n\nexport const AsepritePixelFormats = /** @type {const} */ ({\n  RGBA: 1,\n  GRAYSCALE: 2,\n  INDEXED: 3,\n});\n\n/**\n * @param {import('./AsepritePixelFormats').AsepritePixelFormat} pixelFormat\n */\nexport function countPixelFormatBytesPerPixel(pixelFormat) {\n  switch(pixelFormat) {\n    case AsepritePixelFormats.RGBA:\n      return 4;\n    case AsepritePixelFormats.GRAYSCALE:\n      return 2;\n    case AsepritePixelFormats.INDEXED:\n      return 1;\n    default:\n      throw new Error(`Unsupported image pixel format \"${pixelFormat}\".`);\n  }\n}\n\n/**\n * @param {number} colorDepth\n */\nexport function getPixelFormatFromColorDepth(colorDepth) {\n  if (colorDepth === 32) return AsepritePixelFormats.RGBA;\n  if (colorDepth === 16) return AsepritePixelFormats.GRAYSCALE;\n  if (colorDepth === 8) return AsepritePixelFormats.INDEXED;\n  throw new Error(`Unsupported color depth \"${colorDepth}\" for image pixel format.`);\n}\n","import { countPixelFormatBytesPerPixel } from './AsepritePixelFormats';\nimport { ByteReader } from './ByteReader';\n\n/** @typedef {AsepriteCelTypes[keyof AsepriteCelTypes]} AsepriteCelType */\n\nexport const AsepriteCelTypes = /** @type {const} */ ({\n  RAW_IMAGE_DATA: 0,\n  LINKED_CEL: 1,\n  COMPRESSED_IMAGE: 2,\n  COMPRESSED_TILEMAP: 3\n});\n\n/** @typedef {ReturnType<readAsepriteChunkCel>} AsepriteChunkCel */\n\n/**\n * @param {ByteReader} data \n * @param {import('./AsepritePixelFormats').AsepritePixelFormat} pixelFormat\n */\nexport function readAsepriteChunkCel(data, pixelFormat) {\n  const layerIndex = data.nextWord();\n  const posX = data.nextShort();\n  const posY = data.nextShort();\n  const opacityLevel = data.nextByte();\n  const celType = /** @type {AsepriteCelType} */ (data.nextWord());\n  const zIndex = data.nextShort();\n  data.skipBytes(5); // Zeroes (for future)\n  /** @type {AsepriteRawImageData|AsepriteLinkedCel|AsepriteCompressedImage|AsepriteCompressedTilemap} */\n  let celData;\n  switch(celType) {\n    case AsepriteCelTypes.RAW_IMAGE_DATA:\n      celData = readAsepriteChunkCelRawImageData(data, pixelFormat);\n      break;\n    case AsepriteCelTypes.LINKED_CEL:\n      celData = readAsepriteChunkCelLinkedCel(data);\n      break;\n    case AsepriteCelTypes.COMPRESSED_IMAGE:\n      celData = readAsepriteChunkCelCompressedImage(data);\n      break;\n    case AsepriteCelTypes.COMPRESSED_TILEMAP:\n      celData = readAsepriteChunkCelCompressedTilemap(data);\n      break;\n    default:\n      throw new Error(`Unsupported cel type \"${celType}\".`);\n  }\n  return {\n    layerIndex,\n    posX,\n    posY,\n    opacityLevel,\n    celType,\n    zIndex,\n    celData,\n  };\n}\n\n/** @typedef {ReturnType<readAsepriteChunkCelRawImageData>} AsepriteRawImageData */\n\n/**\n * @param {ByteReader} data \n * @param {import('./AsepritePixelFormats').AsepritePixelFormat} pixelFormat \n */\nfunction readAsepriteChunkCelRawImageData(data, pixelFormat) {\n  const width = data.nextWord();\n  const height = data.nextWord();\n  const length = width * height;\n  const bytesPerPixel = countPixelFormatBytesPerPixel(pixelFormat);\n  const numBytes = bytesPerPixel * length;\n  const pixelData = data.nextBytes(numBytes);\n  return {\n    width,\n    height,\n    length,\n    pixelFormat,\n    pixelData,\n  };\n}\n\n/** @typedef {ReturnType<readAsepriteChunkCelLinkedCel>} AsepriteLinkedCel */\n\n/**\n * @param {ByteReader} data\n */\nfunction readAsepriteChunkCelLinkedCel(data) {\n  const linkedFrame = data.nextWord();\n  return {\n    linkedFrame\n  };\n}\n\n/** @typedef {Awaited<ReturnType<readAsepriteChunkCelCompressedImage>>} AsepriteCompressedImage */\n\n/**\n * @param {ByteReader} data\n */\nfunction readAsepriteChunkCelCompressedImage(data) {\n  const width = data.nextWord();\n  const height = data.nextWord();\n  const compressedPixels = data.remainingBytes(); // zlib compressed.\n  return {\n    width,\n    height,\n    compressedPixels,\n  };\n}\n\n/** @typedef {ReturnType<readAsepriteChunkCelCompressedTilemap>} AsepriteCompressedTilemap */\n\n/**\n * @param {ByteReader} data\n */\nfunction readAsepriteChunkCelCompressedTilemap(data) {\n  const width = data.nextWord();\n  const height = data.nextWord();\n  const bitsPerTile = data.nextWord(); // Always 32-bits, at the moment.\n  const bitmaskForTileId = data.nextDoubleWord();\n  const bitmaskForFlipX = data.nextDoubleWord();\n  const bitmaskForFlipY = data.nextDoubleWord();\n  const bitmaskForDiagonalFlip = data.nextDoubleWord();\n  data.skipBytes(10); // Reserved bytes.\n  const compressedTiles = data.remainingBytes(); // zlib compressed.\n  return {\n    width,\n    height,\n    bitsPerTile,\n    bitmaskForTileId,\n    bitmaskForFlipX,\n    bitmaskForFlipY,\n    bitmaskForDiagonalFlip,\n    compressedTiles,\n  };\n}\n","import { ByteReader } from './ByteReader';\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteChunkCelExtra(data) {\n  const flags = data.nextDoubleWord();\n  const posX = data.nextFixed(); // precision float\n  const posY = data.nextFixed(); // precision float\n  const celWidth = data.nextFixed();\n  const celHeight = data.nextFixed();\n  data.skipBytes(16); // Zeroes (for future)\n  return {\n    flags,\n    posX,\n    posY,\n    celWidth,\n    celHeight,\n  };\n}\n","import { ByteReader } from './ByteReader';\n\n/** @typedef {AsepriteColorProfiles[keyof AsepriteColorProfiles]} AsepriteColorProfile */\n\nexport const AsepriteColorProfiles = /** @type {const} */ ({\n  NONE: 0,\n  SRGB: 1,\n  ICC: 2,\n});\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteChunkColorProfile(data) {\n  const profileType = /** @type {AsepriteColorProfile} */ (data.nextWord());\n  const flags = data.nextWord();\n  const fixedGamma = data.nextFixed();\n  data.skipBytes(8); // Zeroes (reserved)\n  let iccProfile = null;\n  if (profileType === AsepriteColorProfiles.ICC) {\n    const iccProfileLength = data.nextDoubleWord();\n    iccProfile = data.nextBytes(iccProfileLength); // http://www.color.org/ICC1V42.pdf\n  }\n  return {\n    profileType,\n    flags,\n    fixedGamma,\n    iccProfile,\n  };\n}\n","import { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\n/** @typedef {AsepriteExternalFileEntryTypes[keyof AsepriteExternalFileEntryTypes]} AsepriteExternalFileEntryType */\n\nexport const AsepriteExternalFileEntryTypes = /** @type {const} */ ({\n  EXTERNAL_PALETTE: 0,\n  EXTERNAL_TILESET: 1,\n  PROPERTIES_EXTENSION_NAME: 2,\n  TILE_MANAGER_EXTENSION_NAME: 3,\n});\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkExternalFiles(data, textDecoder) {\n  /** @type {Array<AsepriteExternalFileEntry>} */\n  let entries = [];\n  const numEntries = data.nextDoubleWord();\n  data.skipBytes(8); // Zeroes (reserved)\n  for(let i = 0; i < numEntries; ++i) {\n    const entryId = data.nextDoubleWord();\n    const entryType = /** @type {AsepriteExternalFileEntryType} */ (data.nextByte());\n    data.skipBytes(7); // Zeroes (reserved)\n    const extensionId = readAsepriteStringBytes(data, textDecoder);\n    entries.push(createAsepriteExternalFileEntry(entryId, entryType, extensionId));\n  }\n  return {\n    entries\n  };\n}\n\n/** @typedef {ReturnType<createAsepriteExternalFileEntry>} AsepriteExternalFileEntry */\n\n/**\n * @param {number} entryId \n * @param {AsepriteExternalFileEntryType} entryType \n * @param {string} extensionId\n */\nfunction createAsepriteExternalFileEntry(entryId, entryType, extensionId) {\n  return {\n    entryId,\n    entryType,\n    extensionId,\n  };\n}\n","import { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\n/** @typedef {AsepriteAnimationDirections[keyof AsepriteAnimationDirections]} AsepriteAnimationDirection */\n\nexport const AsepriteAnimationDirections = /** @type {const} */ ({\n  FORWARD: 0,\n  REVERSE: 1,\n  PING_PONG: 2,\n  PING_PONG_REVERSE: 3,\n});\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkTags(data, textDecoder) {\n  /** @type {Array<AsepriteTag>} */\n  let tags = [];\n  const numTags = data.nextWord();\n  data.skipBytes(8); // Zeroes (for future)\n  for(let i = 0; i < numTags; ++i) {\n    const fromFrame = data.nextWord();\n    const toFrame = data.nextWord();\n    const direction = /** @type {AsepriteAnimationDirection} */ (data.nextByte());\n    const nTimes = data.nextWord();\n    data.skipBytes(6); // Zeroes (for future)\n    data.skipBytes(3); // Deprecated tag color\n    data.skipBytes(1); // Zeroes (extra)\n    const tagName = readAsepriteStringBytes(data, textDecoder);\n    tags.push(createAsepriteTag(fromFrame, toFrame, direction, nTimes, tagName));\n  }\n  return {\n    tags,\n  };\n}\n\n/** @typedef {ReturnType<createAsepriteTag>} AsepriteTag */\n\n/**\n * @param {number} fromFrame \n * @param {number} toFrame \n * @param {number} direction \n * @param {number} nTimes \n * @param {string} tagName\n */\nfunction createAsepriteTag(fromFrame, toFrame, direction, nTimes, tagName) {\n  return {\n    fromFrame,\n    toFrame,\n    direction,\n    nTimes,\n    tagName,\n  };\n}\n","import { rgba } from '@milquejs/color';\nimport { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\nconst AsepriteUserDataFlags = /** @type {const} */ ({\n  HAS_TEXT: 1,\n  HAS_COLOR: 2,\n  HAS_PROPERTIES: 4,\n});\n\n/** @typedef {AsepriteValueTypes[keyof AsepriteValueTypes]} AsepriteValueType */\n\nconst AsepriteValueTypes = /** @type {const} */ ({\n  BOOL: 0x0001,\n  INT8: 0x0002,\n  UINT8: 0x0003,\n  INT16: 0x0004,\n  UINT16: 0x0005,\n  INT32: 0x0006,\n  UINT32: 0x0007,\n  INT64: 0x0008,\n  UINT64: 0x0009,\n  FIXED: 0x000A,\n  FLOAT: 0x000B,\n  DOUBLE: 0x000C,\n  STRING: 0x000D,\n  POINT: 0x000E,\n  SIZE: 0x000F,\n  RECT: 0x0010,\n  VECTOR: 0x0011,\n  NESTED: 0x0012,\n  UUID: 0x0013,\n});\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkUserData(data, textDecoder) {\n  const flags = data.nextDoubleWord();\n  let text = null;\n  if (flags & AsepriteUserDataFlags.HAS_TEXT) {\n    text = readAsepriteStringBytes(data, textDecoder);\n  }\n  let color = null;\n  if (flags & AsepriteUserDataFlags.HAS_COLOR) {\n    const red = data.nextByte();\n    const green = data.nextByte();\n    const blue = data.nextByte();\n    const alpha = data.nextByte();\n    color = rgba.fromBytes(red, green, blue, alpha);\n  }\n  let props = null;\n  if (flags & AsepriteUserDataFlags.HAS_PROPERTIES) {\n    let maps = [];\n    const mapSize = data.nextDoubleWord(); // Bytes in properties map.\n    const numMaps = data.nextDoubleWord();\n    for(let i = 0; i < numMaps; ++i) {\n      const mapKey = data.nextDoubleWord();\n      const numProps = data.nextDoubleWord();\n      /** @type {Record<string, any>} */\n      let values = {};\n      for(let j = 0; j < numProps; ++j) {\n        const name = readAsepriteStringBytes(data, textDecoder);\n        const type = /** @type {AsepriteValueType} */ (data.nextWord());\n        const value = readAsepriteValue(data, type, textDecoder);\n        values[name] = value;\n      }\n      maps.push({\n        mapKey,\n        values,\n      });\n    }\n    props = {\n      mapSize,\n      maps,\n    };\n  }\n  return {\n    text,\n    color,\n    props,\n  };\n}\n\n/**\n * @param {ByteReader} data\n * @param {AsepriteValueType} type \n * @param {TextDecoder} textDecoder\n */\nfunction readAsepriteValue(data, type, textDecoder) {\n  switch (type) {\n    case AsepriteValueTypes.BOOL:\n      return data.nextByte() === 0 ? false : true;\n    case AsepriteValueTypes.INT8:\n      return data.nextByte();\n    case AsepriteValueTypes.UINT8:\n      return data.nextByte();\n    case AsepriteValueTypes.INT16:\n      return data.nextShort();\n    case AsepriteValueTypes.UINT16:\n      return data.nextWord();\n    case AsepriteValueTypes.INT32:\n      return data.nextLong();\n    case AsepriteValueTypes.UINT32:\n      return data.nextDoubleWord();\n    case AsepriteValueTypes.INT64:\n      return data.nextDoubleLong();\n    case AsepriteValueTypes.UINT64:\n      return data.nextQuadWord();\n    case AsepriteValueTypes.FIXED:\n      return data.nextFixed();\n    case AsepriteValueTypes.FLOAT:\n      return data.nextFloat();\n    case AsepriteValueTypes.DOUBLE:\n      return data.nextDouble();\n    case AsepriteValueTypes.STRING:\n      return readAsepriteStringBytes(data, textDecoder);\n    case AsepriteValueTypes.POINT: {\n      const coordX = data.nextLong();\n      const coordY = data.nextLong();\n      return { coordX, coordY };\n    }\n    case AsepriteValueTypes.SIZE: {\n      const width = data.nextLong();\n      const height = data.nextLong();\n      return { width, height };\n    }\n    case AsepriteValueTypes.RECT: {\n      const originX = data.nextLong();\n      const originY = data.nextLong();\n      const width = data.nextLong();\n      const height = data.nextLong();\n      return {\n        originX,\n        originY,\n        width,\n        height,\n      };\n    }\n    case AsepriteValueTypes.UUID: {\n      const buf = data.nextBytes(16);\n      return textDecoder.decode(buf);\n    }\n    case AsepriteValueTypes.VECTOR:\n    case AsepriteValueTypes.NESTED:\n    default:\n      throw new Error(`Unsupported value type \"${type}\" for user data property.`);\n  }\n}","import { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\nconst AsepriteSliceFlags = /** @type {const} */ ({\n  HAS_9_PATCHES: 1,\n  HAS_PIVOT_INFO: 2,\n});\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkSlice(data, textDecoder) {\n  const numKeys = data.nextDoubleWord();\n  const flags = data.nextDoubleWord();\n  data.nextDoubleWord(); // Reserved.\n  const name = readAsepriteStringBytes(data, textDecoder);\n  let keys = [];\n  for(let i = 0; i < numKeys; ++i) {\n    const frameNumber = data.nextDoubleWord();\n    const originX = data.nextLong();\n    const originY = data.nextLong();\n    const sliceWidth = data.nextDoubleWord();\n    const sliceHeight= data.nextDoubleWord();\n    let ninePatch = null;\n    if (flags & AsepriteSliceFlags.HAS_9_PATCHES) {\n      const centerX = data.nextLong();\n      const centerY = data.nextLong();\n      const centerWidth = data.nextDoubleWord();\n      const centerHeight = data.nextDoubleWord();\n      ninePatch = {\n        centerX,\n        centerY,\n        centerWidth,\n        centerHeight,\n      };\n    }\n    let pivot = null;\n    if (flags & AsepriteSliceFlags.HAS_PIVOT_INFO) {\n      const pivotX = data.nextLong();\n      const pivotY = data.nextLong();\n      pivot = {\n        pivotX,\n        pivotY,\n      };\n    }\n    keys.push(createAsepriteSliceKey(frameNumber, originX, originY, sliceWidth, sliceHeight, ninePatch, pivot));\n  }\n  return {\n    name,\n    keys,\n  };\n}\n\n/** @typedef {ReturnType<createAsepriteSliceKey>} AsepriteSliceKey */\n\n/**\n * @param {number} frameNumber \n * @param {number} originX \n * @param {number} originY \n * @param {number} sliceWidth \n * @param {number} sliceHeight \n * @param {{ centerX: number, centerY: number, centerWidth: number, centerHeight: number }|null} [ninePatch] \n * @param {{ pivotX: number, pivotY: number }|null} [pivot]\n */\nfunction createAsepriteSliceKey(frameNumber, originX, originY, sliceWidth, sliceHeight, ninePatch = null, pivot = null) {\n  return {\n    frameNumber,\n    originX,\n    originY,\n    sliceWidth,\n    sliceHeight,\n    ninePatch,\n    pivot,\n  };\n}\n","import { readAsepriteStringBytes } from './AsepriteBytesHelper';\nimport { ByteReader } from './ByteReader';\n\nconst AsepriteTilesetFlags = /** @type {const} */ ({\n  EXTERNAL_TILESET: 1,\n  INCLUDED_TILESET: 2,\n  NEW_EMPTY_TILE_FORMAT: 4,\n  MATCH_FLIPPED_X: 8,\n  MATCH_FLIPPED_Y: 16,\n  MATCH_FLIPPED_DIAG: 32,\n});\n\n/**\n * @param {ByteReader} data\n * @param {TextDecoder} textDecoder\n */\nexport function readAsepriteChunkTileset(data, textDecoder) {\n  const tilesetId = data.nextDoubleWord();\n  const flags = data.nextDoubleWord();\n  const numTiles = data.nextDoubleWord();\n  const tileWidth = data.nextWord();\n  const tileHeight = data.nextWord();\n  const baseIndex = data.nextShort();\n  data.skipBytes(14); // Zeroes (for future)\n  const name = readAsepriteStringBytes(data, textDecoder);\n  let externalTileset = null;\n  if (flags & AsepriteTilesetFlags.EXTERNAL_TILESET) {\n    const entryId = data.nextDoubleWord();\n    const externalTilesetId = data.nextDoubleWord();\n    externalTileset = {\n      entryId,\n      externalTilesetId,\n    };\n  }\n  let includedTileset = null;\n  if (flags & AsepriteTilesetFlags.INCLUDED_TILESET) {\n    const imageSize = data.nextDoubleWord();\n    const compressedPixels = data.nextBytes(imageSize);\n    includedTileset = {\n      compressedPixels\n    };\n  }\n  return {\n    tilesetId,\n    numTiles,\n    tileWidth,\n    tileHeight,\n    baseIndex,\n    name,\n    externalTileset,\n    includedTileset,\n  };\n}\n","/** @typedef {AsepriteChunkTypes[keyof AsepriteChunkTypes]} AsepriteChunkType */\n\nexport const AsepriteChunkTypes = /** @type {const} */ ({\n  PALETTE_0004: 0x0004,\n  PALETTE_0011: 0x0011,\n  LAYER: 0x2004,\n  CEL: 0x2005,\n  CEL_EXTRA: 0x2006,\n  COLOR_PROFILE: 0x2007,\n  EXTERNAL_FILE: 0x2008,\n  MASK: 0x2016,\n  PATH: 0x2017,\n  TAGS: 0x2018,\n  PALETTE: 0x2019,\n  USER_DATA: 0x2020,\n  SLICE: 0x2022,\n  TILESET: 0x2023,\n});\n","import { ByteReader } from './ByteReader';\nimport { readAsepriteChunkPalette } from './AsepriteChunkPalette';\nimport { readAsepriteChunkLayer } from './AsepriteChunkLayer';\nimport { readAsepriteChunkCel } from './AsepriteChunkCel';\nimport { readAsepriteChunkCelExtra } from './AsepriteChunkCelExtra';\nimport { readAsepriteChunkColorProfile } from './AsepriteChunkColorProfile';\nimport { readAsepriteChunkExternalFiles } from './AsepriteChunkExternalFiles';\nimport { readAsepriteChunkTags } from './AsepriteChunkTags';\nimport { readAsepriteChunkUserData } from './AsepriteChunkUserData';\nimport { readAsepriteChunkSlice } from './AsepriteChunkSlice';\nimport { readAsepriteChunkTileset } from './AsepriteChunkTileset';\nimport { AsepriteChunkTypes } from './AsepriteChunkTypes';\n\n/**\n * @param {import('./AsepriteChunkTypes').AsepriteChunkType} chunkType \n * @param {ArrayBuffer} chunkData\n * @param {import('./AsepritePixelFormats').AsepritePixelFormat} pixelFormat\n */\nexport function parseAsepriteChunk(chunkType, chunkData, pixelFormat) {\n  const data = new ByteReader(chunkData);\n  switch(chunkType) {\n    case AsepriteChunkTypes.PALETTE_0004: // Skip in favor of new palette chunk\n    case AsepriteChunkTypes.PALETTE_0011: // Skip in favor of new palette chunk\n      return null;\n    case AsepriteChunkTypes.LAYER:\n      return readAsepriteChunkLayer(data, new TextDecoder());\n    case AsepriteChunkTypes.CEL:\n      return readAsepriteChunkCel(data, pixelFormat);\n    case AsepriteChunkTypes.CEL_EXTRA:\n      return readAsepriteChunkCelExtra(data);\n    case AsepriteChunkTypes.COLOR_PROFILE:\n      return readAsepriteChunkColorProfile(data);\n    case AsepriteChunkTypes.EXTERNAL_FILE:\n      return readAsepriteChunkExternalFiles(data, new TextDecoder());\n    case AsepriteChunkTypes.MASK: // Deprecated\n      return null;\n    case AsepriteChunkTypes.PATH: // Never used\n      return null;\n    case AsepriteChunkTypes.TAGS:\n      return readAsepriteChunkTags(data, new TextDecoder());\n    case AsepriteChunkTypes.PALETTE:\n      return readAsepriteChunkPalette(data, new TextDecoder());\n    case AsepriteChunkTypes.USER_DATA:\n      return readAsepriteChunkUserData(data, new TextDecoder());\n    case AsepriteChunkTypes.SLICE:\n      return readAsepriteChunkSlice(data, new TextDecoder());\n    case AsepriteChunkTypes.TILESET:\n      return readAsepriteChunkTileset(data, new TextDecoder());\n  }\n}\n","import { ByteReader } from './ByteReader';\nimport { parseAsepriteChunk } from './AsepriteChunks';\nimport { getPixelFormatFromColorDepth } from './AsepritePixelFormats';\n\nconst HEADER_MAGIC_NUMBER = 0xa5e0;\nconst FRAME_HEADER_MAGIC_NUMBER = 0xf1fa;\n\n/** @typedef {ReturnType<readAsepriteFileBytes>} AsepriteFile */\n\n/**\n * @see https://github.com/aseprite/aseprite/blob/master/docs/ase-file-specs.md\n * @param {ByteReader} data \n */\nexport function readAsepriteFileBytes(data) {\n  const header = readAsepriteHeaderBytes(data);\n  let frames = [];\n  for(let i = 0; i < header.frames; ++i) {\n    const frameHeader = readAsepriteFrameHeaderBytes(data);\n    let chunks = [];\n    for(let j = 0; j < frameHeader.chunks; ++j) {\n      const chunk = readAsepriteChunkBytes(data);\n      let result = parseAsepriteChunk(\n        chunk.chunkType,\n        chunk.chunkData,\n        getPixelFormatFromColorDepth(header.colorDepth));\n      chunks.push({\n        chunkHeader: {\n          chunkType: chunk.chunkType,\n          chunkSize: chunk.chunkSize,\n        },\n        ...result,\n      });\n    }\n    frames.push({\n      frameHeader,\n      chunks,\n    });\n  }\n  return {\n    header,\n    frames,\n  };\n}\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteHeaderBytes(data) {\n  const fileSize = data.nextDoubleWord();\n  const magicNumber = data.nextWord();\n  if (magicNumber !== HEADER_MAGIC_NUMBER) {\n    throw new Error('Invalid Aseprite header byte format.');\n  }\n  const frames = data.nextWord();\n  const width = data.nextWord();\n  const height = data.nextWord();\n  const colorDepth = data.nextWord();\n  data.nextDoubleWord(); // Layer opacity flag\n  data.nextWord(); // Deprecated speed (ms) between frames\n  data.nextDoubleWord(); // Zeroes\n  data.nextDoubleWord(); // Zeroes\n  const paletteIndex = data.nextByte();\n  data.skipBytes(3); // Zeroes (ignored bytes)\n  const numColors = data.nextWord();\n  const pixelWidth = data.nextByte();\n  const pixelHeight = data.nextByte();\n  const gridX = data.nextShort();\n  const gridY = data.nextShort();\n  const gridWidth = data.nextWord();\n  const gridHeight = data.nextWord();\n  data.skipBytes(84); // Zeroes (reserved for the future)\n  return {\n    /** Bytes in this file. */\n    fileSize,\n    /** Number of frames in this file. */\n    frames,\n    width,\n    height,\n    colorDepth,\n    paletteIndex,\n    numColors,\n    pixelWidth,\n    pixelHeight,\n    gridX,\n    gridY,\n    gridWidth,\n    gridHeight,\n  };\n}\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteFrameHeaderBytes(data) {\n  const frameSize = data.nextDoubleWord();\n  const magicNumber = data.nextWord();\n  if (magicNumber !== FRAME_HEADER_MAGIC_NUMBER) {\n    throw new Error('Invalid Aseprite frame header byte format.');\n  }\n  const oldChunks = data.nextWord(); // Old num chunks field\n  const frameDuration = data.nextWord(); // In milliseconds\n  data.skipBytes(2); // Zeroes (for future)\n  const newChunks = data.nextDoubleWord(); // If 0, use old num chunks field\n  return {\n    /** Bytes in this frame. */\n    frameSize,\n    /** Duration of this frame in milliseconds. */\n    frameDuration,\n    /** Number of chunks in this frame. */\n    chunks: newChunks > 0 ? newChunks : oldChunks,\n  };\n}\n\n/** @typedef {ReturnType<readAsepriteChunkBytes>} AsepriteChunk */\n\n/**\n * @param {ByteReader} data\n */\nexport function readAsepriteChunkBytes(data) {\n  const chunkSize = data.nextDoubleWord();\n  const chunkType = /** @type {import('./AsepriteChunkTypes').AsepriteChunkType} */ (data.nextWord());\n  const numBytes = chunkSize - 6;\n  if (numBytes < 0) {\n    throw new Error('Invalid Aseprite chunk size - must be at least 6 bytes (to include chunk size and type info).');\n  }\n  const chunkData = data.nextBytes(numBytes);\n  return {\n    /** Bytes in this chunk. */\n    chunkSize,\n    chunkType,\n    chunkData,\n  };\n}\n","import { readAsepriteFileBytes } from './AsepriteFile';\nimport { getPixelFormatFromColorDepth } from './AsepritePixelFormats';\nimport { ByteReader } from './ByteReader';\n\nexport class Aseprite {\n\n  /**\n   * @param {ArrayBuffer} arrayBuffer\n   */\n  static fromArrayBuffer(arrayBuffer) {\n    const data = new ByteReader(arrayBuffer);\n    const file = readAsepriteFileBytes(data);\n    let result = new Aseprite(\n      file.header.fileSize,\n      file.header.width,\n      file.header.height,\n      file.header.colorDepth,\n      `${file.header.pixelWidth}:${file.header.pixelHeight}`,\n      file);\n    return result;\n  }\n\n  /**\n   * @param {number} fileSize\n   * @param {number} width\n   * @param {number} height\n   * @param {number} colorDepth\n   * @param {string} pixelRatio\n   * @param {import('./AsepriteFile').AsepriteFile} fileData\n   */\n  constructor(fileSize, width, height, colorDepth, pixelRatio, fileData) {\n    /** @readonly */\n    this.fileSize = fileSize;\n    /** @readonly */\n    this.fileData = fileData;\n\n    this.frames = [];\n    this.layers = [];\n    this.slices = [];\n    this.tags = [];\n    this.tilesets = [];\n\n    /** @readonly */\n    this.width = width;\n    /** @readonly */\n    this.height = height;\n    /** @readonly */\n    this.colorDepth = colorDepth;\n    /** @readonly */\n    this.pixelRatio = pixelRatio;\n    /** @readonly */\n    this.pixelFormat = getPixelFormatFromColorDepth(this.colorDepth);\n  }\n}\n"],"names":["ByteReader","constructor","arrayBuffer","byteOffset","byteLength","littleEndian","this","buffer","view","DataView","offset","skipBytes","numBytes","nextByte","result","getUint8","nextWord","getUint16","nextShort","getInt16","nextDoubleWord","getUint32","nextLong","getInt32","nextDoubleLong","getBigInt64","nextQuadWord","getBigUint64","nextFixed","fixed","getFloat32","nextFloat","nextDouble","getFloat64","nextBytes","slice","remainingBytes","fromBytes$1","red","green","blue","alpha","fromFloats$1","redf","greenf","bluef","alphaf","Math","floor","max","min","hexValue","alpha$1","alphaf$1","rgba","Object","freeze","__proto__","create","fromBytes","fromFloats","mix","from","to","delta","rm","gm","bm","am","rf","gf","bf","af","undefined","toCSSColorString","Error","toString","padStart","toFloatVector","gray","grayf","grayscale","g","readAsepriteStringBytes","data","textDecoder","stringBuffer","decode","readAsepriteChunkPalette","colors","paletteSize","firstColor","lastColor","i","flags","name","color","createAsepritePaletteColor","push","value","readAsepriteChunkLayer","layerType","childLevel","blendMode","opacity","layerName","tilesetIndex","AsepritePixelFormats","RGBA","GRAYSCALE","INDEXED","countPixelFormatBytesPerPixel","pixelFormat","getPixelFormatFromColorDepth","colorDepth","AsepriteCelTypes","RAW_IMAGE_DATA","LINKED_CEL","COMPRESSED_IMAGE","COMPRESSED_TILEMAP","readAsepriteChunkCel","layerIndex","posX","posY","opacityLevel","celType","zIndex","celData","width","height","length","bytesPerPixel","pixelData","readAsepriteChunkCelRawImageData","linkedFrame","readAsepriteChunkCelLinkedCel","compressedPixels","readAsepriteChunkCelCompressedImage","bitsPerTile","bitmaskForTileId","bitmaskForFlipX","bitmaskForFlipY","bitmaskForDiagonalFlip","compressedTiles","readAsepriteChunkCelCompressedTilemap","readAsepriteChunkCelExtra","celWidth","celHeight","AsepriteColorProfiles","NONE","SRGB","ICC","readAsepriteChunkColorProfile","profileType","fixedGamma","iccProfile","iccProfileLength","readAsepriteChunkExternalFiles","entries","numEntries","entryId","entryType","extensionId","createAsepriteExternalFileEntry","readAsepriteChunkTags","tags","numTags","fromFrame","toFrame","direction","nTimes","tagName","createAsepriteTag","AsepriteUserDataFlags","AsepriteValueTypes","readAsepriteChunkUserData","text","props","maps","mapSize","numMaps","mapKey","numProps","values","j","type","readAsepriteValue","coordX","coordY","originX","originY","buf","AsepriteSliceFlags","readAsepriteChunkSlice","numKeys","keys","frameNumber","sliceWidth","sliceHeight","ninePatch","centerX","centerY","centerWidth","centerHeight","pivot","pivotX","pivotY","createAsepriteSliceKey","AsepriteTilesetFlags","readAsepriteChunkTileset","tilesetId","numTiles","tileWidth","tileHeight","baseIndex","externalTileset","externalTilesetId","includedTileset","imageSize","AsepriteChunkTypes","PALETTE_0004","PALETTE_0011","LAYER","CEL","CEL_EXTRA","COLOR_PROFILE","EXTERNAL_FILE","MASK","PATH","TAGS","PALETTE","USER_DATA","SLICE","TILESET","parseAsepriteChunk","chunkType","chunkData","TextDecoder","readAsepriteFileBytes","header","readAsepriteHeaderBytes","frames","frameHeader","readAsepriteFrameHeaderBytes","chunks","chunk","readAsepriteChunkBytes","chunkHeader","chunkSize","fileSize","paletteIndex","numColors","pixelWidth","pixelHeight","gridX","gridY","gridWidth","gridHeight","frameSize","oldChunks","frameDuration","newChunks","Aseprite","fromArrayBuffer","file","pixelRatio","fileData","layers","slices","tilesets","FORWARD","REVERSE","PING_PONG","PING_PONG_REVERSE","NORMAL","MULTIPLY","SCREEN","OVERLAY","DARKEN","LIGHTEN","COLOR_DODGE","COLOR_BURN","HARD_LIGHT","SOFT_LIGHT","DIFFERENCE","EXCLUSION","HUE","SATURATION","COLOR","LUMINOSITY","ADDITION","SUBTRACT","DIVIDE","EXTERNAL_PALETTE","EXTERNAL_TILESET","PROPERTIES_EXTENSION_NAME","TILE_MANAGER_EXTENSION_NAME","VISIBLE","EDITABLE","LOCK_MOVEMENT","BACKGROUND","PREFER_LINKED_CELS","COLLAPSED_LAYER_GROUP","IS_REFERENCE_LAYER"],"mappings":"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"}