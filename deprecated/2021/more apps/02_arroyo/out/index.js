
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
  'use strict';

  var INNER_HTML = "<div class=\"container\">\n    <label class=\"hidden\" id=\"title\">display-port</label>\n    <label class=\"hidden\" id=\"fps\">00</label>\n    <label class=\"hidden\" id=\"dimension\">0x0</label>\n    <div class=\"content\">\n        <canvas>\n            Oh no! Your browser does not support canvas.\n        </canvas>\n        <slot id=\"inner\"></slot>\n    </div>\n    <slot name=\"frame\"></slot>\n</div>";
  var INNER_STYLE = ":host{display:inline-block;color:#555}.container{display:flex;position:relative;width:100%;height:100%}.content{position:relative;margin:auto}.content>*{width:100%;height:100%}canvas{background:#000;-ms-interpolation-mode:nearest-neighbor;image-rendering:-moz-crisp-edges;image-rendering:pixelated}label{font-family:monospace;color:currentColor}#inner,label{position:absolute}#inner{display:flex;flex-direction:column;align-items:center;justify-content:center;top:0;left:0;pointer-events:none}#title{left:.5rem;top:.5rem}#fps{right:.5rem;top:.5rem}#dimension{left:.5rem;bottom:.5rem}.hidden{display:none}:host([debug]) .container{outline:6px dashed rgba(0,0,0,.1);outline-offset:-4px;background-color:rgba(0,0,0,.1)}:host([mode=noscale]) canvas{margin:0;top:0;left:0}:host([mode=center]),:host([mode=fit]),:host([mode=stretch]){width:100%;height:100%}:host([full]){width:100vw!important;height:100vh!important}:host([disabled]){display:none}slot{display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;width:100%;height:100%;top:0;left:0;pointer-events:none}::slotted(*){pointer-events:auto}";
  /**
   * No scaling is applied. The canvas size maintains a 1:1 pixel ratio to the defined
   * display dimensions.
   */

  const MODE_NOSCALE = 'noscale';
  /**
   * Scales the canvas to fill the entire viewport and maintains the same aspect ratio
   * with respect to the defined display dimensions. In effect, this will upscale and
   * downscale the pixel size depending on the viewport resolution and aspect ratio. This
   * is the default scaling mode.
   */

  const MODE_FIT = 'fit';
  /**
   * Scales the canvas to fill the entire viewport. This does not maintain the aspect
   * ratio. If you care about aspect ratio, consider using 'fit' mode instead.
   */

  const MODE_STRETCH = 'stretch'; // The default display dimensions. This is the same as the canvas element default.

  const DEFAULT_WIDTH = 300;
  const DEFAULT_HEIGHT = 150; // The default display scaling mode.

  const DEFAULT_MODE = MODE_FIT;
  /**
   * @typedef {CustomEvent} FrameEvent
   * @property {number} detail.now The current time in milliseconds.
   * @property {number} detail.prevTime The previous frame time in milliseconds.
   * @property {number} detail.deltaTime The time taken between the current and previous frame in milliseconds.
   * @property {HTMLCanvasElement} detail.canvas The canvas element.
   */

  /**
   * A canvas that can scale and stretch with respect to the aspect ratio to fill
   * the viewport size.
   * 
   * To start drawing, you should get the canvas context like so:
   * 
   * For Canvas2D:
   * ```
   * const display = document.querySelector('display-port');
   * const ctx = display.canvas.getContext('2d');
   * ctx.drawText(0, 0, 'Hello World!');
   * ```
   * 
   * For WebGL:
   * ```
   * const display = document.querySelector('display-port');
   * const gl = display.canvas.getContext('webgl');
   * gl.clear(gl.COLOR_BUFFER_BIT);
   * ```
   * 
   * Usually, you would want to set the `width` and `height` attributes to define
   * the canvas size and aspect ratio in pixels. You can also change the scaling
   * behavior by setting the `mode` attribute.
   * 
   * And for convenience, this element also dispatches a `frame` event every animation
   * frame (60 fps). This is basically the same as calling `requestAnimationFrame()`.
   * 
   * NOTE: The viewport size is usually the parent container size. However, in the
   * rare case the element must be nested in a child container, you can define the
   * boolean attribute `full` to force the dimensions to be the actual window size.
   */

  class DisplayPort extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }
    /** @override */


    static get observedAttributes() {
      return ["onframe", "width", "height", "disabled", "debug", 'id', 'class'];
    }

    static get properties() {
      return {
        /** The canvas width in pixels. This determines the aspect ratio and canvas buffer size. */
        width: Number,

        /** The canvas height in pixels. This determines the aspect ratio and canvas buffer size. */
        height: Number,

        /** If disabled, animation frames will not fire. */
        disabled: Boolean,

        /** Enable for debug information. */
        debug: Boolean,

        /**
         * The scaling mode.
         * - `noscale`: Does not perform scaling. This is effectively the same as a regular
         * canvas.
         * - `center`: Does not perform pixel scaling but stretches the display to fill the
         * entire viewport. The unscaled canvas is centered.
         * - `fit`: Performs scaling to fill the entire viewport and maintains the aspect
         * ratio. This is the default behavior.
         * - `stretch`: Performs scaling to fill the entire viewport but does not maintain
         * aspect ratio.
         */
        mode: {
          type: String,
          value: DEFAULT_MODE,
          observed: false
        }
      };
    }
    /**
                 * The scaling mode.
                 * - `noscale`: Does not perform scaling. This is effectively the same as a regular
                 * canvas.
                 * - `center`: Does not perform pixel scaling but stretches the display to fill the
                 * entire viewport. The unscaled canvas is centered.
                 * - `fit`: Performs scaling to fill the entire viewport and maintains the aspect
                 * ratio. This is the default behavior.
                 * - `stretch`: Performs scaling to fill the entire viewport but does not maintain
                 * aspect ratio.
                 */


    get mode() {
      return this.getAttribute("mode");
    }

    set mode(value) {
      this.setAttribute("mode", value);
    }
    /** Enable for debug information. */


    get debug() {
      return this._debug;
    }

    set debug(value) {
      this.toggleAttribute("debug", value);
    }
    /** If disabled, animation frames will not fire. */


    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      this.toggleAttribute("disabled", value);
    }
    /** The canvas height in pixels. This determines the aspect ratio and canvas buffer size. */


    get height() {
      return this._height;
    }

    set height(value) {
      this.setAttribute("height", String(value));
    }
    /** The canvas width in pixels. This determines the aspect ratio and canvas buffer size. */


    get width() {
      return this._width;
    }

    set width(value) {
      this.setAttribute("width", String(value));
    }

    static get customEvents() {
      return [
      /** Fired every animation frame. */
      'frame'];
    }
    /** Fired every animation frame. */


    get onframe() {
      return this._onframe;
    }

    set onframe(value) {
      if (this._onframe) this.removeEventListener("frame", this._onframe);
      this._onframe = value;
      if (this._onframe) this.addEventListener("frame", value);
    }

    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      /** @private */

      this._canvasElement = this.shadowRoot.querySelector('canvas');
      /** @private */

      this._contentElement = this.shadowRoot.querySelector('.content');
      /** @private */

      this._innerElement = this.shadowRoot.querySelector('#inner');
      /** @private */

      this._titleElement = this.shadowRoot.querySelector('#title');
      /** @private */

      this._fpsElement = this.shadowRoot.querySelector('#fps');
      /** @private */

      this._dimensionElement = this.shadowRoot.querySelector('#dimension');
      /** @private */

      this._animationRequestHandle = 0;
      /** @private */

      this._prevAnimationFrameTime = 0;
      /** @private */

      this._width = DEFAULT_WIDTH;
      /** @private */

      this._height = DEFAULT_HEIGHT;
      /** @private */

      this.update = this.update.bind(this);
    }
    /** Get the canvas element. */


    get canvas() {
      return this._canvasElement;
    }
    /** @override */


    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "onframe")) {
        let value = this.onframe;
        delete this.onframe;
        this.onframe = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "width")) {
        let value = this.width;
        delete this.width;
        this.width = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "height")) {
        let value = this.height;
        delete this.height;
        this.height = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "disabled")) {
        let value = this.disabled;
        delete this.disabled;
        this.disabled = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "debug")) {
        let value = this.debug;
        delete this.debug;
        this.debug = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "mode")) {
        let value = this.mode;
        delete this.mode;
        this.mode = value;
      }

      if (!this.hasAttribute("mode")) {
        this.setAttribute("mode", DEFAULT_MODE);
      } // Allows this element to be focusable


      if (!this.hasAttribute('tabindex')) this.setAttribute('tabindex', '0');
      this.updateCanvasSize();
      this.resume();
    }
    /** @override */


    disconnectedCallback() {
      this.pause();
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "width":
          {
            this._width = Number(value);
          }
          break;

        case "height":
          {
            this._height = Number(value);
          }
          break;

        case "disabled":
          {
            this._disabled = value !== null;
          }
          break;

        case "debug":
          {
            this._debug = value !== null;
          }
          break;

        case "onframe":
          {
            this.onframe = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'disabled':
            if (value) {
              this.update(0);
              this.pause();
            } else {
              this.resume();
            }

            break;
          // NOTE: For debugging purposes...

          case 'id':
          case 'class':
            this._titleElement.innerHTML = `display-port${this.className ? '.' + this.className : ''}${this.hasAttribute('id') ? '#' + this.getAttribute('id') : ''}`;
            break;

          case 'debug':
            this._titleElement.classList.toggle('hidden', value);

            this._fpsElement.classList.toggle('hidden', value);

            this._dimensionElement.classList.toggle('hidden', value);

            break;
        }
      })(attribute, prev, value);
    }
    /** Pause animation of the display frames. */


    pause() {
      cancelAnimationFrame(this._animationRequestHandle);
    }
    /** Resume animation of the display frames. */


    resume() {
      this._animationRequestHandle = requestAnimationFrame(this.update);
    }
    /** @private */


    update(now) {
      this._animationRequestHandle = requestAnimationFrame(this.update);
      this.updateCanvasSize();
      const deltaTime = now - this._prevAnimationFrameTime;
      this._prevAnimationFrameTime = now; // NOTE: For debugging purposes...

      if (this.debug) {
        // Update FPS...
        const frames = deltaTime <= 0 ? '--' : String(Math.round(1000 / deltaTime)).padStart(2, '0');

        if (this._fpsElement.textContent !== frames) {
          this._fpsElement.textContent = frames;
        } // Update dimensions...


        if (this.mode === MODE_NOSCALE) {
          let result = `${this._width}x${this._height}`;

          if (this._dimensionElement.textContent !== result) {
            this._dimensionElement.textContent = result;
          }
        } else {
          let result = `${this._width}x${this._height}|${this.shadowRoot.host.clientWidth}x${this.shadowRoot.host.clientHeight}`;

          if (this._dimensionElement.textContent !== result) {
            this._dimensionElement.textContent = result;
          }
        }
      }

      this.dispatchEvent(new CustomEvent('frame', {
        detail: {
          now,
          prevTime: this._prevAnimationFrameTime,
          deltaTime: deltaTime,
          canvas: this._canvasElement
        },
        bubbles: false,
        composed: true
      }));
    }
    /** @private */


    updateCanvasSize() {
      let clientRect = this.shadowRoot.host.getBoundingClientRect();
      const clientWidth = clientRect.width;
      const clientHeight = clientRect.height;
      let canvas = this._canvasElement;
      let canvasWidth = this._width;
      let canvasHeight = this._height;
      const mode = this.mode;

      if (mode === MODE_STRETCH) {
        canvasWidth = clientWidth;
        canvasHeight = clientHeight;
      } else if (mode !== MODE_NOSCALE) {
        let flag = clientWidth < canvasWidth || clientHeight < canvasHeight || mode === MODE_FIT;

        if (flag) {
          let ratioX = clientWidth / canvasWidth;
          let ratioY = clientHeight / canvasHeight;

          if (ratioX < ratioY) {
            canvasWidth = clientWidth;
            canvasHeight = canvasHeight * ratioX;
          } else {
            canvasWidth = canvasWidth * ratioY;
            canvasHeight = clientHeight;
          }
        }
      }

      canvasWidth = Math.floor(canvasWidth);
      canvasHeight = Math.floor(canvasHeight);
      let fontSize = Math.min(canvasWidth / this._width, canvasHeight / this._height) * 0.5; // NOTE: Update the inner container for the default slotted children.
      // To anchor children outside the canvas, use the slot named 'frame'.

      this._innerElement.style = `font-size: ${fontSize}em`;

      if (canvas.clientWidth !== canvasWidth || canvas.clientHeight !== canvasHeight) {
        canvas.width = this._width;
        canvas.height = this._height;
        this._contentElement.style = `width: ${canvasWidth}px; height: ${canvasHeight}px`;
        this.dispatchEvent(new CustomEvent('resize', {
          detail: {
            width: canvasWidth,
            height: canvasHeight
          },
          bubbles: false,
          composed: true
        }));
      }
    }

  }

  window.customElements.define('display-port', DisplayPort);

  /**
   * An enum for input types.
   * 
   * @readonly
   * @enum {number}
   */
  const InputType = {
    NULL: 0,
    KEY: 1,
    POS: 2,
    WHEEL: 3
  };
  /**
   * An enum for input events.
   * 
   * @readonly
   * @enum {number}
   */

  const InputEventCode = {
    NULL: 0,
    DOWN: 1,
    UP: 2,
    MOVE: 3,

    parse(string) {
      if (typeof string === 'string') {
        switch (string.toLowerCase()) {
          case 'down':
            return InputEventCode.DOWN;

          case 'up':
            return InputEventCode.UP;

          case 'move':
            return InputEventCode.MOVE;

          default:
            return InputEventCode.NULL;
        }
      } else {
        return InputEventCode.NULL;
      }
    }

  };
  const WILDCARD_KEY_MATCHER = '*';
  /**
   * @typedef InputEvent
   * @property {EventTarget} target
   * @property {string} deviceName
   * @property {string} keyCode
   * @property {InputEventCode} event
   * @property {InputType} type
   * @property {number} [value] If type is `key`, it is defined to be the input
   * value of the triggered event (usually this is 1). Otherwise, it is undefined.
   * @property {boolean} [control] If type is `key`, it is defined to be true if
   * any control key is down (false if up). Otherwise, it is undefined.
   * @property {boolean} [shift] If type is `key`, it is defined to be true if
   * any shift key is down (false if up). Otherwise, it is undefined.
   * @property {boolean} [alt] If type is `key`, it is defined to be true if any
   * alt key is down (false if up). Otherwise, it is undefined.
   * @property {number} [x] If type is `pos`, it is defined to be the x value
   * of the position event. Otherwise, it is undefined.
   * @property {number} [y] If type is `pos`, it is defined to be the y value
   * of the position event. Otherwise, it is undefined.
   * @property {number} [dx] If type is `pos` or `wheel`, it is defined to be
   * the change in the x value from the previous to the current position.
   * Otherwise, it is undefined.
   * @property {number} [dy] If type is `pos` or `wheel`, it is defined to be
   * the change in the y value from the previous to the current position.
   * Otherwise, it is undefined.
   * @property {number} [dz] If type is `wheel`, it is defined to be the change
   * in the z value from the previous to the current position. Otherwise, it
   * is undefined.
   * 
   * @callback InputDeviceListener
   * @param {InputEvent} e
   * @returns {boolean} Whether to consume the input after all other
   * listeners had a chance to handle the event.
   */

  /** Represents an input device. */

  class InputDevice {
    /** @abstract */
    static isAxis(keyCode) {
      return false;
    }
    /** @abstract */


    static isButton(keyCode) {
      return false;
    }

    constructor(deviceName, eventTarget) {
      this.deviceName = deviceName;
      this.eventTarget = eventTarget;
      /** @private */

      this.listeners = {};
    }

    destroy() {
      /** @private */
      this.listeners = {};
    }
    /**
     * @param {string} keyMatcher
     * @param {InputDeviceListener} listener
     */


    addInputListener(keyMatcher, listener) {
      let inputListeners = this.listeners[keyMatcher];

      if (!inputListeners) {
        inputListeners = [listener];
        this.listeners[keyMatcher] = inputListeners;
      } else {
        inputListeners.push(listener);
      }
    }
    /**
     * @param {string} keyMatcher
     * @param {InputDeviceListener} listener
     */


    removeInputListener(keyMatcher, listener) {
      let inputListeners = this.listeners[keyMatcher];

      if (inputListeners) {
        inputListeners.indexOf(listener);
        inputListeners.splice(listener, 1);
      }
    }
    /**
     * @param {InputEvent} e
     * @returns {boolean} Whether the input event should be consumed.
     */


    dispatchInput(e) {
      const {
        keyCode
      } = e;
      const listeners = this.listeners[keyCode];
      let flag = 0;

      if (listeners) {
        // KeyCode listeners
        for (let listener of listeners) {
          flag |= listener(e);
        }

        return Boolean(flag);
      } // Wildcard listeners


      for (let listener of this.listeners[WILDCARD_KEY_MATCHER]) {
        flag |= listener(e);
      }

      return Boolean(flag);
    }

  }
  /**
   * @typedef AdapterInput
   * @property {Function} update
   * @property {Function} poll
   * @property {Function} reset
   * 
   * @typedef Adapter
   * @property {AdapterInput} target
   * @property {Number} adapterId
   * @property {String} deviceName
   * @property {String} keyCode
   * @property {Number} scale
   * @property {Number} eventCode
   */


  const WILDCARD_DEVICE_MATCHER = '*';

  class AdapterManager {
    /**
     * Creates a new adapter for the given values.
     * 
     * @param {AdapterInput} target The target callback to update the value.
     * @param {Number} adapterId The adapter id (unique within the target).
     * @param {String} deviceName The name of the device to listen to.
     * @param {String} keyCode The key code to listen to.
     * @param {Number} scale The input value multiplier.
     * @param {Number} eventCode The event code to listen for.
     * @returns {Adapter} The new adapter.
     */
    static createAdapter(target, adapterId, deviceName, keyCode, scale, eventCode) {
      return {
        target,
        adapterId,
        deviceName,
        keyCode,
        scale,
        eventCode
      };
    }

    constructor() {
      /** @private */
      this.adapters = {
        [WILDCARD_DEVICE_MATCHER]: createKeyCodeMap()
      };
    }
    /**
     * @param {Array<Adapter>} adapters 
     */


    add(adapters) {
      for (let adapter of adapters) {
        const {
          deviceName,
          keyCode
        } = adapter;
        let adapterMap;

        if (!(deviceName in this.adapters)) {
          adapterMap = createKeyCodeMap();
          this.adapters[deviceName] = adapterMap;
        } else {
          adapterMap = this.adapters[deviceName];
        }

        if (keyCode in adapterMap) {
          adapterMap[keyCode].push(adapter);
        } else {
          adapterMap[keyCode] = [adapter];
        }
      }
    }
    /**
     * @param {Array<Adapter>} adapters
     */


    delete(adapters) {
      for (let adapter of adapters) {
        const {
          deviceName,
          keyCode
        } = adapter;

        if (deviceName in this.adapters) {
          let adapterMap = this.adapters[deviceName];

          if (keyCode in adapterMap) {
            let list = adapterMap[keyCode];
            let index = list.indexOf(adapter);

            if (index >= 0) {
              list.splice(index, 1);
            }
          }
        }
      }
    }

    clear() {
      for (let deviceName in this.adapters) {
        this.adapters[deviceName] = createKeyCodeMap();
      }
    }

    poll(deviceName, keyCode, input) {
      const adapters = this.findAdapters(deviceName, keyCode);

      for (let adapter of adapters) {
        const eventCode = adapter.eventCode;

        if (eventCode === InputEventCode.NULL) {
          const {
            target,
            scale
          } = adapter;
          const nextValue = input.value * scale;
          target.poll(nextValue, adapter);
        } else {
          const {
            target,
            scale
          } = adapter;
          const nextValue = input.getEvent(eventCode) * scale;
          target.poll(nextValue, adapter);
        }
      }

      return adapters.length > 0;
    }

    update(deviceName, keyCode, input) {
      let flag = false;

      for (let adapter of this.findAdapters(deviceName, keyCode)) {
        const eventCode = adapter.eventCode;

        if (eventCode !== InputEventCode.NULL) {
          const {
            target,
            scale
          } = adapter;
          const nextValue = input.getEvent(eventCode) * scale;
          target.update(nextValue, adapter);
          flag = true;
        }
      }

      return flag;
    }

    reset(deviceName, keyCode, input) {
      let flag = false;

      for (let adapter of this.findAdapters(deviceName, keyCode)) {
        adapter.target.reset();
        flag = true;
      }

      return flag;
    }
    /**
     * Find all adapters for the given device and key code.
     * 
     * @param {String} deviceName The name of the target device.
     * @param {String} keyCode The target key code.
     * @returns {Array<Adapter>} The associated adapters for the device and key code.
     */


    findAdapters(deviceName, keyCode) {
      let result = [];

      if (deviceName in this.adapters) {
        let adapterMap = this.adapters[deviceName];
        if (keyCode in adapterMap) result.push(...adapterMap[keyCode]);
        result.push(...adapterMap[WILDCARD_KEY_MATCHER]);
      }

      let wildMap = this.adapters[WILDCARD_DEVICE_MATCHER];
      if (keyCode in wildMap) result.push(...wildMap[keyCode]);
      result.push(...wildMap[WILDCARD_KEY_MATCHER]);
      return result;
    }

  }

  function createKeyCodeMap() {
    return {
      [WILDCARD_KEY_MATCHER]: []
    };
  }
  /**
   * @typedef {import('../device/InputDevice.js').InputEventCode} InputEventCode
   */

  /**
   * A class to represent the basic input interface.
   */


  class Input {
    constructor() {
      /** The current state of the input. */
      this.value = 0;
      /** The previous state (after poll) of the input. */

      this.prev = 0; // TODO: Do we need a next? How do you tell if the update is a PRESS vs a HOLD?
    }

    update(value) {
      this.value = value;
    }

    poll() {
      this.prev = this.value;
      this.value = 0;
    }
    /**
     * @param {InputEventCode} eventCode
     * @returns {number} The event state.
     */


    getEvent(eventCode) {
      return 0;
    }

    getState() {
      return this.value;
    }

    getPrevState() {
      return this.prev;
    }

  }
  /**
   * A stateful input for axis input interfaces, such as mouse positions,
   * scrolling, joysticks, etc. The unscaled `value` is a floating point
   * in a 1-dimensional range of [-1, 1]. It also keeps track of the
   * accumulated delta since last poll with `delta`.
   */


  class Axis extends Input {
    constructor() {
      super();
      this.delta = 0;
      /** @private */

      this.next = {
        delta: 0
      };
    }
    /** @override */


    update(value, delta) {
      this.value = value;
      this.next.delta += delta;
    }
    /** @override */


    poll() {
      // Update previous state.
      this.prev = this.value; // Update current state.

      this.delta = this.next.delta;
      this.next.delta = 0;
    }
    /** @override */


    getEvent(eventCode) {
      switch (eventCode) {
        case InputEventCode.MOVE:
          return this.delta;

        default:
          return super.getEvent(eventCode);
      }
    }

  }
  /**
   * A stateful input for button input interfaces, such as keyboard
   * buttons, mouse buttons, etc. The unscaled `value` is either
   * 1 or 0. If truthy, this indicates that it is currently
   * being held down, and 0 indicates the opposite. It also keeps
   * track of this state as a boolean with `down` and `up`.
   */


  class Button extends Input {
    constructor() {
      super();
      /** Whether the button is just pressed. Is updated on poll(). */

      this.down = false;
      /** Whether the button is just released. Is updated on poll(). */

      this.up = false;
      /** @private */

      this.next = {
        down: false,
        up: false
      };
    }
    /** @override */


    update(value) {
      if (value) {
        this.next.down = true;
      } else {
        this.next.up = true;
      }
    }
    /** @override */


    poll() {
      // Update previous state.
      this.prev = this.value; // Poll current state.

      const {
        up: nextUp,
        down: nextDown
      } = this.next;

      if (this.value) {
        if (this.up && !nextUp) {
          this.value = 0;
        }
      } else if (nextDown) {
        this.value = 1;
      }

      this.down = nextDown;
      this.up = nextUp;
      this.next.down = false;
      this.next.up = false;
    }
    /** @override */


    getEvent(eventCode) {
      switch (eventCode) {
        case InputEventCode.DOWN:
          return this.down & 1;

        case InputEventCode.UP:
          return this.up & 1;

        default:
          return super.getEvent(eventCode);
      }
    }

  }
  /**
   * @typedef {import('../device/InputDevice.js').InputDevice} InputDevice
   * @typedef {import('../input/Input.js').Input} Input
   */

  /**
   * @typedef {'update'|'poll'|'input'} InputSourceEventTypes
   * 
   * @typedef InputSourceInputEvent
   * @property {InputSourceEventStage} stage
   * @property {string} deviceName
   * @property {string} keyCode
   * @property {Axis|Button|Input} input
   * 
   * @typedef InputSourcePollEvent
   * @property {number} now
   * 
   * @callback InputSourceEventListener
   * @param {InputSourceInputEvent|InputSourcePollEvent} e
   * 
   * @typedef KeyMapEntry
   * @property {number} refs The number of active references to this key.
   * @property {Axis|Button|Input} input The input object.
   */

  /**
   * @readonly
   * @enum {number}
   */


  const InputSourceEventStage = {
    NULL: 0,
    UPDATE: 1,
    POLL: 2
  };
  /**
   * A class to model the current input state with buttons and axes for devices.
   */

  class InputSourceState {
    constructor(deviceList = []) {
      /** @private */
      this.onInputEvent = this.onInputEvent.bind(this);
      /** @private */

      this.onAnimationFrame = this.onAnimationFrame.bind(this);
      /** @type {Record<string, InputDevice>} */

      let deviceMap = {};
      /** @type {Record<string, Record<string, KeyMapEntry>>} */

      let keyMap = {};

      for (let device of deviceList) {
        const deviceName = device.deviceName;

        if (deviceName in deviceMap) {
          throw new Error(`Another device with name '${deviceName}' already exists.`);
        }

        deviceMap[deviceName] = device;
        keyMap[deviceName] = {};
        device.addInputListener(WILDCARD_KEY_MATCHER, this.onInputEvent);
      }
      /**
       * @type {Record<string, InputDevice>}
       */


      this.devices = deviceMap;
      /**
       * @private
       * @type {Record<string, Record<string, KeyMapEntry>>}
       */

      this.keyMap = keyMap;
      /** @private */

      this.listeners = {
        poll: [],
        update: []
      };
      /** @private */

      this._lastPollTime = -1;
      /** @private */

      this._autopoll = false;
      /** @private */

      this._animationFrameHandle = null;
    }
    /**
     * @returns {boolean} Whether in the last second this input source was polled.
     */


    get polling() {
      return performance.now() - this._lastPollTime < 1000;
    }
    /**
     * Destroys this source's devices and keys.
     */


    destroy() {
      this.clearKeys();

      for (let deviceName in this.devices) {
        let device = this.devices[deviceName];
        device.removeInputListener(WILDCARD_KEY_MATCHER, this.onInputEvent);
        device.destroy();
      }

      this.devices = {};
    }
    /**
     * Poll the devices and update the input state.
     */


    poll(now = performance.now()) {
      for (const deviceName in this.keyMap) {
        let deviceKeyMap = this.keyMap[deviceName];

        for (const keyCode in deviceKeyMap) {
          let input = getKeyMapEntryInput(deviceKeyMap[keyCode]);
          input.poll();
          this.dispatchInputEvent(InputSourceEventStage.POLL, deviceName, keyCode, input);
        }
      }

      this.dispatchPollEvent(now);
      this._lastPollTime = now;
    }
    /**
     * Add listener to listen for event, in order by most
     * recently added. In other words, this listener will
     * be called BEFORE the previously added listener (if
     * there exists one) and so on.
     * 
     * @param {InputSourceEventTypes} event The name of the event.
     * @param {InputSourceEventListener} listener The listener callback.
     */


    addEventListener(event, listener) {
      if (event in this.listeners) {
        this.listeners[event].unshift(listener);
      } else {
        this.listeners[event] = [listener];
      }
    }
    /**
     * Removes the listener from listening to the event.
     * 
     * @param {InputSourceEventTypes} event The name of the event.
     * @param {InputSourceEventListener} listener The listener callback.
     */


    removeEventListener(event, listener) {
      if (event in this.listeners) {
        let list = this.listeners[event];
        let i = list.indexOf(listener);
        list.splice(i, 1);
      }
    }
    /**
     * @param {InputSourceEventTypes} event The name of the event.
     * @returns {number} The number of active listeners for the event.
     */


    countEventListeners(event) {
      if (!(event in this.listeners)) {
        throw new Error(`Cannot count listeners for unknown event '${event}'.`);
      }

      return this.listeners[event].length;
    }
    /**
     * Dispatches an event to the listeners.
     * 
     * @protected
     * @param {InputSourceEventTypes} event The name of the event.
     * @param {InputSourceInputEvent|InputSourcePollEvent} eventOpts The event object to pass to listeners.
     */


    dispatchEvent(event, eventOpts) {
      for (let listener of this.listeners[event]) {
        listener(eventOpts);
      }
    }
    /**
     * @protected
     * @param {InputSourceEventStage} stage The current input event stage.
     * @param {string} deviceName The device from which the input event was fired.
     * @param {string} keyCode The triggered key code for this input event.
     * @param {Axis|Button|Input} input The triggered input.
     */


    dispatchInputEvent(stage, deviceName, keyCode, input) {
      this.dispatchEvent('input', {
        stage,
        deviceName,
        keyCode,
        input
      });
    }
    /**
     * @protected
     * @param {number} now The currrent time in milliseconds.
     */


    dispatchPollEvent(now) {
      this.dispatchEvent('poll', {
        now
      });
    }
    /** @private */


    onInputEvent(e) {
      const deviceName = e.deviceName;
      const deviceKeyMap = this.keyMap[deviceName];

      switch (e.type) {
        case InputType.KEY:
          {
            const keyCode = e.keyCode;
            let button = getKeyMapEntryInput(deviceKeyMap[keyCode]);

            if (button) {
              button.update(e.event === InputEventCode.DOWN);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, keyCode, button);
              return true;
            }
          }
          break;

        case InputType.POS:
          {
            let xAxis = getKeyMapEntryInput(deviceKeyMap.PosX);

            if (xAxis) {
              xAxis.update(e.x, e.dx);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, 'PosX', xAxis);
            }

            let yAxis = getKeyMapEntryInput(deviceKeyMap.PosY);

            if (yAxis) {
              yAxis.update(e.y, e.dy);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, 'PosY', yAxis);
            }
          }
          break;

        case InputType.WHEEL:
          {
            let xAxis = getKeyMapEntryInput(deviceKeyMap.WheelX);

            if (xAxis) {
              xAxis.update(e.dx, e.dx);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, 'WheelX', xAxis);
            }

            let yAxis = getKeyMapEntryInput(deviceKeyMap.WheelY);

            if (yAxis) {
              yAxis.update(e.dy, e.dy);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, 'WheelY', yAxis);
            }

            let zAxis = getKeyMapEntryInput(deviceKeyMap.WheelZ);

            if (zAxis) {
              zAxis.update(e.dz, e.dz);
              this.dispatchInputEvent(InputSourceEventStage.UPDATE, deviceName, 'WheelZ', zAxis);
            }
          }
          break;
      }
    }
    /** @private */


    onAnimationFrame(now) {
      if (!this._autopoll) return;
      this._animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);
      this.poll(now);
    }

    set autopoll(value) {
      this._autopoll = value;

      if (this._animationFrameHandle) {
        // Stop animation frame loop
        cancelAnimationFrame(this._animationFrameHandle);
        this._animationFrameHandle = null;
      }

      if (value) {
        // Start animation frame loop
        this._animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);
      }
    }
    /**
     * If true, polling will be handled automatically through requestAnimationFrame().
     * 
     * @returns {boolean} Whether to automatically poll on animation frame.
     */


    get autopoll() {
      return this._autopoll;
    }
    /**
     * Register and enable the source input to listen to for the given device
     * and key code. Can be registered more than once to obtain active lease
     * on the input, which guarantees it will be unregistered the same number
     * of times before removal.
     * 
     * @param {string} deviceName The name of the device (case-sensitive).
     * @param {string} keyCode The key code for the given key in the device.
     */


    registerKey(deviceName, keyCode) {
      if (!(deviceName in this.devices)) {
        throw new Error(`Invalid device name - missing device with name '${deviceName}' in source.`);
      }

      let deviceKeyMap = this.keyMap[deviceName];

      if (keyCode in deviceKeyMap) {
        incrementKeyMapEntryRef(deviceKeyMap[keyCode]);
      } else {
        let device = this.devices[deviceName];
        let deviceClass = device.constructor;
        let result;

        if (deviceClass.isAxis(keyCode)) {
          result = new Axis();
        } else if (deviceClass.isButton(keyCode)) {
          result = new Button();
        } else {
          throw new Error(`Unknown key code '${keyCode}' for device ${deviceName}.`);
        }

        deviceKeyMap[keyCode] = createKeyMapEntry(result);
      }

      return this;
    }
    /**
     * Remove and disable the registered source for the given device and key code.
     * 
     * @param {string} deviceName The name of the device (case-sensitive).
     * @param {string} keyCode The key code for the given key in the device.
     */


    unregisterKey(deviceName, keyCode) {
      let deviceKeyMap = this.keyMap[deviceName];

      if (deviceKeyMap) {
        let keyMapEntry = deviceKeyMap[keyCode];

        if (keyMapEntry) {
          decrementKeyMapEntryRef(keyMapEntry);

          if (keyMapEntry.refs <= 0) {
            delete deviceKeyMap[keyCode];
          }
        }
      }
    }
    /**
     * @param {string} deviceName The name of the device.
     * @param {string} keyCode The key code in the device.
     * @returns {boolean} Whether the device and key code has been registered.
     */


    hasKey(deviceName, keyCode) {
      return deviceName in this.keyMap && keyCode in this.keyMap[deviceName];
    }
    /**
     * Removes all registered inputs from all devices.
     */


    clearKeys() {
      for (let deviceName in this.devices) {
        let deviceKeyMap = this.keyMap[deviceName]; // Clean-up device key map.

        for (let keyCode in deviceKeyMap) {
          clearKeyMapEntryRef(deviceKeyMap[keyCode]);
        } // Actually clear it from future references.


        this.keyMap[deviceName] = {};
      }
    }
    /**
     * @returns {Button|Axis|Input}
     */


    getInputByKey(deviceName, keyCode) {
      return getKeyMapEntryInput(this.keyMap[deviceName][keyCode]);
    }

  }
  /**
   * @param {Input} [input]
   * @returns {KeyMapEntry}
   */


  function createKeyMapEntry(input = null) {
    return {
      refs: 1,
      input: input
    };
  }
  /**
   * @param {KeyMapEntry} keyMapEntry 
   */


  function getKeyMapEntryInput(keyMapEntry) {
    return keyMapEntry ? keyMapEntry.input : null;
  }
  /**
   * @param {KeyMapEntry} keyMapEntry 
   */


  function incrementKeyMapEntryRef(keyMapEntry) {
    keyMapEntry.refs += 1;
  }
  /**
   * @param {KeyMapEntry} keyMapEntry
   */


  function decrementKeyMapEntryRef(keyMapEntry) {
    keyMapEntry.refs -= 1;
  }
  /**
   * @param {KeyMapEntry} keyMapEntry 
   */


  function clearKeyMapEntryRef(keyMapEntry) {
    keyMapEntry.refs = 0;
  }

  const KEY_STRING_DEVICE_SEPARATOR = ':';

  class Synthetic extends Input {
    constructor() {
      super();
      this.update = this.update.bind(this);
      /** @private */

      this.adapters = [];
      /** @private */

      this.values = [];
      /** @private */

      this.next = {
        values: [],
        value: 0
      };
    }

    hydrate(adapterOptions) {
      if (!adapterOptions) return;

      if (!Array.isArray(adapterOptions)) {
        adapterOptions = [adapterOptions];
      }

      let adapterList = [];
      let adapterId = 0;

      for (let adapterOption of adapterOptions) {
        if (typeof adapterOption === 'string') {
          adapterOption = {
            key: adapterOption
          };
        }

        const {
          key,
          scale = 1,
          event = 'null'
        } = adapterOption;
        const {
          deviceName,
          keyCode
        } = parseKeyString(key);
        const eventCode = InputEventCode.parse(event);
        const scaleValue = Number(scale);
        let adapter = AdapterManager.createAdapter(this, adapterId, deviceName, keyCode, scaleValue, eventCode);
        adapterList.push(adapter);
        ++adapterId;
      }

      this.adapters = adapterList;
      this.values = new Array(adapterList.length).fill(0);
      this.next = {
        values: new Array(adapterList.length).fill(0),
        value: 0
      };
    }
    /** @override */


    poll(value, adapter) {
      // Update previous state.
      this.prev = this.value; // Poll current state.

      const adapterId = adapter.adapterId;
      let prevValue = this.values[adapterId];
      this.values[adapterId] = value;
      this.value = this.value - prevValue + value;
      this.next.values[adapterId] = 0;
      this.next.value += value - prevValue;
    }
    /** @override */


    update(value, adapter) {
      const adapterId = adapter.adapterId;
      let prevValue = this.next.values[adapterId];
      this.next.values[adapterId] = value;
      this.next.value += value - prevValue;
    }

    reset() {
      this.prev = 0;
      this.values.fill(0);
      this.value = 0;
      this.next.values.fill(0);
      this.next.value = 0;
    }

  }

  function parseKeyString(keyString) {
    let i = keyString.indexOf(KEY_STRING_DEVICE_SEPARATOR);

    if (i >= 0) {
      return {
        deviceName: keyString.substring(0, i),
        keyCode: keyString.substring(i + 1)
      };
    } else {
      throw new Error(`Invalid key string - missing device separator '${KEY_STRING_DEVICE_SEPARATOR}'.`);
    }
  }
  /**
   * @typedef {import('../source/InputSourceState.js').InputSourceInputEvent} InputSourceInputEvent
   * @typedef {import('../source/InputSourceState.js').InputSourcePollEvent} InputSourcePollEvent
   */

  /**
   * @typedef {string} InputEvent
   * @typedef {string} InputKeyString
   * 
   * @typedef InputKeyOption
   * @property {InputKeyString} key
   * @property {InputEvent} [event]
   * @property {number} [scale]
   * 
   * @typedef {InputKeyString|InputKeyOption} InputMappingEntryValue
   * @typedef {InputMappingEntryValue|Array<InputMappingEntryValue>} InputMappingEntry
   * @typedef {Record<string, InputMappingEntry>} InputMapping
   * 
   * @typedef {Record<string, Synthetic>} SyntheticMap 
   */

  /**
   * @typedef {'change'|'attach'|'detach'} InputContextEventTypes
   * 
   * @typedef {object} InputContextChangeEvent
   * @typedef {object} InputContextAttachEvent
   * @typedef {object} InputContextDetachEvent
   * 
   * @callback InputContextEventListener
   * @param {InputContextChangeEvent|InputContextAttachEvent|InputContextDetachEvent} e
   */


  class InputContext {
    /**
     * Constructs a disabled InputContext.
     */
    constructor() {
      /** @private */
      this._source = null;
      /** @private */

      this._mapping = null;
      /** @private */

      this._disabled = true;
      /** @private */

      this._ignoreInputs = this._disabled;
      /** @private */

      this.adapters = new AdapterManager();
      /**
       * @private
       * @type {SyntheticMap}
       */

      this.inputs = {};
      /** @private */

      this.listeners = {
        change: [],
        attach: [],
        detach: []
      };
      /** @private */

      this.onSourceInput = this.onSourceInput.bind(this);
      /** @private */

      this.onSourcePoll = this.onSourcePoll.bind(this);
    }

    get source() {
      return this._source;
    }

    get mapping() {
      return this._mapping;
    }

    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      this.toggle(!value);
    }
    /**
     * @param {InputMapping} inputMapping
     * @returns {InputContext}
     */


    setInputMapping(inputMapping) {
      const prevDisabled = this.disabled;
      this.disabled = true;
      let prevSource = this.source;
      let prevInputs = this.inputs; // Clean up previous state.

      if (prevSource) {
        unregisterInputKeys(prevSource, prevInputs);
      }

      this.adapters.clear(); // Set up next state.

      let nextSource = this.source;
      let nextInputs = {};

      if (inputMapping) {
        for (let inputName in inputMapping) {
          let adapterOptions = inputMapping[inputName]; // NOTE: Preserve synthetics across restarts.

          let synthetic = prevInputs[inputName] || new Synthetic();
          synthetic.hydrate(adapterOptions);
          let syntheticAdapters = synthetic.adapters;
          this.adapters.add(syntheticAdapters);
          nextInputs[inputName] = synthetic;
        }

        if (nextSource) {
          registerInputKeys(nextSource, nextInputs);
        }
      }

      this.inputs = nextInputs;
      this._mapping = inputMapping;
      this.dispatchChangeEvent(); // Force disable if missing required components, otherwise return to previous operating state.

      this.disabled = this.source && this.inputs ? prevDisabled : true;
      return this;
    }

    attach(inputSource) {
      if (this.source) {
        throw new Error('Already attached to existing input source.');
      }

      if (!inputSource) {
        throw new Error('Missing input source to attach context.');
      }

      registerInputKeys(inputSource, this.inputs);
      inputSource.addEventListener('poll', this.onSourcePoll);
      inputSource.addEventListener('input', this.onSourceInput);
      this._source = inputSource;
      this.toggle(true);
      this.dispatchAttachEvent();
      return this;
    }

    detach() {
      let prevSource = this.source;
      let prevInputs = this.inputs;

      if (prevSource) {
        this.toggle(false);
        prevSource.removeEventListener('poll', this.onSourcePoll);
        prevSource.removeEventListener('input', this.onSourceInput);

        if (prevInputs) {
          unregisterInputKeys(prevSource, prevInputs);
        }

        this._source = null;
        this.dispatchDetachEvent();
      }

      return this;
    }
    /**
     * Add listener to listen for event, in order by most
     * recently added. In other words, this listener will
     * be called BEFORE the previously added listener (if
     * there exists one) and so on.
     * 
     * @param {InputContextEventTypes} event The name of the event.
     * @param {InputContextEventListener} listener The listener callback.
     */


    addEventListener(event, listener) {
      if (event in this.listeners) {
        this.listeners[event].unshift(listener);
      } else {
        this.listeners[event] = [listener];
      }
    }
    /**
     * Removes the listener from listening to the event.
     * 
     * @param {InputContextEventTypes} event The name of the event.
     * @param {InputContextEventListener} listener The listener callback.
     */


    removeEventListener(event, listener) {
      if (event in this.listeners) {
        let list = this.listeners[event];
        let i = list.indexOf(listener);
        list.splice(i, 1);
      }
    }
    /**
     * @param {InputContextEventTypes} event The name of the event.
     * @returns {number} The number of active listeners for the event.
     */


    countEventListeners(event) {
      if (!(event in this.listeners)) {
        throw new Error(`Cannot count listeners for unknown event '${event}'.`);
      }

      return this.listeners[event].length;
    }
    /**
     * Dispatches an event to the listeners.
     * 
     * @protected
     * @param {InputSourceEventTypes} event The name of the event.
     * @param {InputSourceInputEvent|InputSourcePollEvent} eventOpts The event object to pass to listeners.
     */


    dispatchEvent(event, eventOpts) {
      for (let listener of this.listeners[event]) {
        listener(eventOpts);
      }
    }
    /** @private */


    dispatchChangeEvent() {
      this.dispatchEvent('change', {});
    }
    /** @private */


    dispatchAttachEvent() {
      this.dispatchEvent('attach', {});
    }
    /** @private */


    dispatchDetachEvent() {
      this.dispatchEvent('detach', {});
    }
    /**
     * @private
     * @param {InputSourceInputEvent} e
     */


    onSourceInput(e) {
      if (!e.consumed && !this._ignoreInputs) {
        const {
          stage,
          deviceName,
          keyCode,
          input
        } = e;

        switch (stage) {
          case InputSourceEventStage.POLL:
            this.adapters.poll(deviceName, keyCode, input);
            break;

          case InputSourceEventStage.UPDATE:
            this.adapters.update(deviceName, keyCode, input);
            break;

          default:
            throw new Error('Unknown input source stage.');
        }

        e.consumed = true;
      } else {
        const {
          deviceName,
          keyCode,
          input
        } = e;
        this.adapters.reset(deviceName, keyCode, input);
      }
    }
    /**
     * @private
     * @param {InputSourcePollEvent} e
     */


    onSourcePoll(e) {
      if (this._ignoreInputs !== this.disabled) {
        this._ignoreInputs = this.disabled;
      }
    }
    /**
     * Set the context to enabled/disabled.
     * 
     * @param {Boolean} [force] If defined, the context is enabled if true,
     * disabled if false. If undefined, it will toggle the current value.
     * @returns {InputContext} Self for method chaining.
     */


    toggle(force = this._disabled) {
      let result = !force;

      if (!result) {
        if (!this.source) {
          throw new Error('Input source must be set before enabling input context.');
        }
      }

      this._disabled = result;
      return this;
    }
    /**
     * @param {string} inputName The name of the input.
     * @returns {boolean} Whether the input exists for the given name.
     */


    hasInput(inputName) {
      return inputName in this.inputs && this.inputs[inputName].adapters.length > 0;
    }
    /**
     * Get the synthetic input object by name.
     * 
     * @param {string} inputName The name of the input.
     * @returns {Synthetic} The synthetic input for the given input name.
     */


    getInput(inputName) {
      if (inputName in this.inputs) {
        return this.inputs[inputName];
      } else {
        let synthetic = new Synthetic();
        this.inputs[inputName] = synthetic;
        this._mapping[inputName] = '';
        this.dispatchChangeEvent();
        return synthetic;
      }
    }
    /**
     * Get the current value of the input by name.
     * 
     * @param {String} inputName The name of the input.
     * @returns {number} The input value.
     */


    getInputState(inputName) {
      if (inputName in this.inputs) {
        return this.inputs[inputName].value;
      } else {
        return 0;
      }
    }
    /**
     * Get the change in value of the input by name since last poll.
     * 
     * @param {String} inputName The name of the input.
     * @returns {number} The input value.
     */


    getInputChanged(inputName) {
      if (inputName in this.inputs) {
        let input = this.inputs[inputName];
        return input.value - input.prev;
      } else {
        return 0;
      }
    }

  }

  function registerInputKeys(inputSource, inputs) {
    for (let inputName in inputs) {
      let {
        adapters
      } = inputs[inputName];

      for (let adapter of adapters) {
        const {
          deviceName,
          keyCode
        } = adapter;
        inputSource.registerKey(deviceName, keyCode);
      }
    }
  }

  function unregisterInputKeys(inputSource, inputs) {
    for (let inputName in inputs) {
      let {
        adapters
      } = inputs[inputName];

      for (let adapter of adapters) {
        const {
          deviceName,
          keyCode
        } = adapter;
        inputSource.unregisterKey(deviceName, keyCode);
      }
    }
  }
  /**
   * Available Key Codes:
   * - This uses the `event.code` standard to reference each key.
   * - Use this to help you determine the code: https://keycode.info/
   */

  /**
   * A class that listens to the keyboard events from the event target and
   * transforms the events into a valid {@link InputEvent} for the added
   * listeners.
   */


  class Keyboard extends InputDevice {
    /** @override */
    static isAxis(keyCode) {
      return false;
    }
    /** @override */


    static isButton(keyCode) {
      return true;
    }
    /**
     * Constructs a listening keyboard with no listeners (yet).
     * 
     * @param {EventTarget} eventTarget 
     * @param {Object} [opts] Any additional options.
     * @param {Boolean} [opts.repeat=false] Whether to accept repeated key
     * events.
     */


    constructor(eventTarget, opts = {}) {
      super('Keyboard', eventTarget);
      const {
        repeat = false
      } = opts;
      this.repeat = repeat;
      /** @private */

      this._eventObject = {
        target: eventTarget,
        deviceName: this.deviceName,
        keyCode: '',
        event: InputEventCode.NULL,
        type: InputType.KEY,
        // Key values
        value: 0,
        control: false,
        shift: false,
        alt: false
      };
      /** @private */

      this.onKeyDown = this.onKeyDown.bind(this);
      /** @private */

      this.onKeyUp = this.onKeyUp.bind(this);
      eventTarget.addEventListener('keydown', this.onKeyDown);
      eventTarget.addEventListener('keyup', this.onKeyUp);
    }
    /** @override */


    destroy() {
      let eventTarget = this.eventTarget;
      eventTarget.removeEventListener('keydown', this.onKeyDown);
      eventTarget.removeEventListener('keyup', this.onKeyUp);
      super.destroy();
    }
    /**
     * @private
     * @param {KeyboardEvent} e
     */


    onKeyDown(e) {
      if (e.repeat) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }

      let event = this._eventObject; // We care more about location (code) than print char (key).

      event.keyCode = e.code;
      event.event = InputEventCode.DOWN;
      event.value = 1;
      event.control = e.ctrlKey;
      event.shift = e.shiftKey;
      event.alt = e.altKey;
      let result = this.dispatchInput(event);

      if (result) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    /**
     * @private
     * @param {KeyboardEvent} e
     */


    onKeyUp(e) {
      let event = this._eventObject; // We care more about location (code) than print char (key).

      event.keyCode = e.code;
      event.event = InputEventCode.UP;
      event.value = 1;
      event.control = e.ctrlKey;
      event.shift = e.shiftKey;
      event.alt = e.altKey;
      let result = this.dispatchInput(event);

      if (result) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }

  }
  /**
   * Available Key Codes:
   * - PosX
   * - PosY
   * - WheelX
   * - WheelY
   * - WheelZ
   * - Button0 (left button)
   * - Button1 (middle button)
   * - Button2 (right button)
   * - Button3 (next button)
   * - Button4 (back button)
   */


  const DEFAULT_LINE_PIXELS = 10;
  const DEFAULT_PAGE_PIXELS = 100;
  /**
   * A class that listens to the keyboard events from the event target and
   * transforms the events into a valid {@link InputEvent} for the added
   * listeners.
   */

  class Mouse extends InputDevice {
    /** @override */
    static isAxis(keyCode) {
      return keyCode === 'PosX' || keyCode === 'PosY' || keyCode === 'WheelX' || keyCode === 'WheelY' || keyCode === 'WheelZ';
    }
    /** @override */


    static isButton(keyCode) {
      return !this.isAxis(keyCode);
    }
    /**
     * Constructs a listening mouse with no listeners (yet).
     * 
     * @param {EventTarget} eventTarget
     * @param {Object} [opts] Any additional options.
     * @param {Boolean} [opts.eventsOnFocus=true] Whether to capture events only when it has focus.
     */


    constructor(eventTarget, opts = {
      eventsOnFocus: true
    }) {
      super('Mouse', eventTarget);
      this.canvasTarget = eventTarget instanceof HTMLCanvasElement && eventTarget || eventTarget.canvas || eventTarget.querySelector('canvas') || eventTarget.shadowRoot && eventTarget.shadowRoot.querySelector('canvas') || eventTarget;
      this.eventsOnFocus = opts.eventsOnFocus;
      this._downHasFocus = false;
      /** @private */

      this._eventObject = {
        target: eventTarget,
        deviceName: this.deviceName,
        keyCode: '',
        event: InputEventCode.NULL,
        type: InputType.KEY,
        // Key values
        value: 0,
        control: false,
        shift: false,
        alt: false
      };
      /** @private */

      this._positionObject = {
        target: eventTarget,
        deviceName: this.deviceName,
        keyCode: 'Position',
        event: InputEventCode.MOVE,
        type: InputType.POS,
        // Pos values
        x: 0,
        y: 0,
        dx: 0,
        dy: 0
      };
      /** @private */

      this._wheelObject = {
        target: eventTarget,
        deviceName: this.deviceName,
        keyCode: 'Wheel',
        event: InputEventCode.MOVE,
        type: InputType.WHEEL,
        // Wheel values
        dx: 0,
        dy: 0,
        dz: 0
      };
      /** @private */

      this.onMouseDown = this.onMouseDown.bind(this);
      /** @private */

      this.onMouseUp = this.onMouseUp.bind(this);
      /** @private */

      this.onMouseMove = this.onMouseMove.bind(this);
      /** @private */

      this.onContextMenu = this.onContextMenu.bind(this);
      /** @private */

      this.onWheel = this.onWheel.bind(this);
      eventTarget.addEventListener('mousedown', this.onMouseDown);
      eventTarget.addEventListener('contextmenu', this.onContextMenu);
      eventTarget.addEventListener('wheel', this.onWheel);
      document.addEventListener('mousemove', this.onMouseMove);
      document.addEventListener('mouseup', this.onMouseUp);
    }
    /** @override */


    destroy() {
      let eventTarget = this.eventTarget;
      eventTarget.removeEventListener('mousedown', this.onMouseDown);
      eventTarget.removeEventListener('contextmenu', this.onContextMenu);
      eventTarget.removeEventListener('wheel', this.onWheel);
      document.removeEventListener('mousemove', this.onMouseMove);
      document.removeEventListener('mouseup', this.onMouseUp);
      super.destroy();
    }

    setPointerLock(force = true) {
      if (force) {
        this.eventTarget.requestPointerLock();
      } else {
        this.eventTarget.exitPointerLock();
      }
    }

    hasPointerLock() {
      return document.pointerLockElement === this.eventTarget;
    }
    /**
     * @private
     * @param {MouseEvent} e
     */


    onMouseDown(e) {
      this._downHasFocus = true;
      let event = this._eventObject; // We care more about location (code) than print char (key).

      event.keyCode = 'Button' + e.button;
      event.event = InputEventCode.DOWN;
      event.value = 1;
      event.control = e.ctrlKey;
      event.shift = e.shiftKey;
      event.alt = e.altKey;
      let result = this.dispatchInput(event);

      if (result) {
        // Make sure it has focus first.
        if (document.activeElement === this.eventTarget) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }
    }
    /**
     * @private
     * @param {MouseEvent} e
     */


    onContextMenu(e) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
    /**
     * @private
     * @param {WheelEvent} e
     */


    onWheel(e) {
      let event = this._wheelObject;

      switch (e.deltaMode) {
        case WheelEvent.DOM_DELTA_LINE:
          event.dx = e.deltaX * DEFAULT_LINE_PIXELS;
          event.dy = e.deltaY * DEFAULT_LINE_PIXELS;
          event.dz = e.deltaZ * DEFAULT_LINE_PIXELS;
          break;

        case WheelEvent.DOM_DELTA_PAGE:
          event.dx = e.deltaX * DEFAULT_PAGE_PIXELS;
          event.dy = e.deltaY * DEFAULT_PAGE_PIXELS;
          event.dz = e.deltaZ * DEFAULT_PAGE_PIXELS;
          break;

        case WheelEvent.DOM_DELTA_PIXEL:
        default:
          event.dx = e.deltaX;
          event.dy = e.deltaY;
          event.dz = e.deltaZ;
          break;
      }

      let result = this.dispatchInput(event);

      if (result) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    /**
     * @private
     * @param {MouseEvent} e
     */


    onMouseUp(e) {
      // Make sure mouse down was pressed before this (with focus).
      if (!this._downHasFocus) return;
      this._downHasFocus = false;
      let event = this._eventObject; // We care more about location (code) than print char (key).

      event.keyCode = 'Button' + e.button;
      event.event = InputEventCode.UP;
      event.value = 1;
      event.control = e.ctrlKey;
      event.shift = e.shiftKey;
      event.alt = e.altKey;
      let result = this.dispatchInput(event);

      if (result) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    /**
     * @private
     * @param {MouseEvent} e
     */


    onMouseMove(e) {
      if (this.eventsOnFocus && document.activeElement !== this.eventTarget) return;
      const element = this.canvasTarget;
      const {
        clientWidth,
        clientHeight
      } = element;
      const rect = element.getBoundingClientRect();
      let dx = e.movementX / clientWidth;
      let dy = e.movementY / clientHeight;
      let x = (e.clientX - rect.left) / clientWidth;
      let y = (e.clientY - rect.top) / clientHeight;
      let event = this._positionObject;
      event.x = x;
      event.y = y;
      event.dx = dx;
      event.dy = dy;
      this.dispatchInput(event);
    }

  }

  var INNER_HTML$1 = "<kbd>\n    <span id=\"key\"><slot></slot></span>\n    <span id=\"value\" class=\"hidden\"></span>\n</kbd>\n";
  var INNER_STYLE$1 = "kbd{position:relative;display:inline-block;border-radius:3px;border:1px solid #888;font-size:.85em;font-weight:700;text-rendering:optimizeLegibility;line-height:12px;height:14px;padding:2px 4px;color:#444;background-color:#eee;box-shadow:inset 0 -3px 0 #aaa;overflow:hidden}kbd:empty:after{content:\"<?>\";opacity:.6}.disabled{opacity:.6;box-shadow:none;background-color:#aaa}.hidden{display:none}#value{position:absolute;top:0;bottom:0;right:0;font-size:.85em;padding:2px 4px 0;color:#ccc;background-color:#333;box-shadow:inset 0 3px 0 #222}";

  class InputKeyElement extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML$1;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE$1;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }

    static get properties() {
      return {
        name: String,
        value: String,
        disabled: Boolean
      };
    }

    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      this.toggleAttribute("disabled", value);
    }

    get value() {
      return this._value;
    }

    set value(value) {
      this.setAttribute("value", value);
    }

    get name() {
      return this._name;
    }

    set name(value) {
      this.setAttribute("name", value);
    }

    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      this._keyboardElement = this.shadowRoot.querySelector('kbd');
      this._keyElement = this.shadowRoot.querySelector('#key');
      this._valueElement = this.shadowRoot.querySelector('#value');
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "name":
          this._name = value;
          break;

        case "value":
          this._value = value;
          break;

        case "disabled":
          {
            this._disabled = value !== null;
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'name':
            this._keyElement.textContent = value;
            break;

          case 'value':
            if (value !== null) {
              this._valueElement.classList.toggle('hidden', false);

              this._valueElement.textContent = value;
              this._keyboardElement.style.paddingRight = `${this._valueElement.clientWidth + 4}px`;
            } else {
              this._valueElement.classList.toggle('hidden', true);
            }

            break;

          case 'disabled':
            this._keyboardElement.classList.toggle('disabled', value !== null);

            break;
        }
      })(attribute, prev, value);
    }

    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "name")) {
        let value = this.name;
        delete this.name;
        this.name = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "value")) {
        let value = this.value;
        delete this.value;
        this.value = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "disabled")) {
        let value = this.disabled;
        delete this.disabled;
        this.disabled = value;
      }
    }

    static get observedAttributes() {
      return ["name", "value", "disabled"];
    }

  }

  window.customElements.define('input-key', InputKeyElement);
  var INNER_HTML$1$1 = "<table>\n    <thead>\n        <tr class=\"tableHeader\">\n            <th colspan=4>\n                <slot></slot>\n            </th>\n        </tr>\n        <tr class=\"colHeader\">\n            <th>name</th>\n            <th>key</th>\n            <th>mod</th>\n            <th>value</th>\n        </tr>\n    </thead>\n    <tbody>\n    </tbody>\n</table>\n";
  var INNER_STYLE$1$1 = ":host{display:block}table{border-collapse:collapse}table,td,th{border:1px solid #666}td,th{padding:5px 10px}td{text-align:center}thead th{padding:0}.colHeader>th{font-size:.8em;padding:0 10px;letter-spacing:3px;background-color:#aaa;color:#666}.colHeader>th,output{font-family:monospace}output{border-radius:.3em;padding:3px}tr:not(.primary) .name,tr:not(.primary) .value{opacity:.3}tr:nth-child(2n){background-color:#eee}";

  function upgradeProperty(element, propertyName) {
    if (Object.prototype.hasOwnProperty.call(element, propertyName)) {
      let value = element[propertyName];
      delete element[propertyName];
      element[propertyName] = value;
    }
  }

  class InputMapElement extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML$1$1;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE$1$1;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }

    static get customEvents() {
      return ['load'];
    }
    /** @override */


    get onload() {
      return this._onload;
    }

    set onload(value) {
      if (this._onload) this.removeEventListener("load", this._onload);
      this._onload = value;
      if (this._onload) this.addEventListener("load", value);
    }

    static get observedAttributes() {
      return ["onload", 'src'];
    }

    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      this._src = '';
      this._inputMap = null;
      this._tableElements = {};
      this._titleElement = this.shadowRoot.querySelector('#title');
      this._bodyElement = this.shadowRoot.querySelector('tbody');
      this._children = this.shadowRoot.querySelector('slot');
    }

    get map() {
      return this._inputMap;
    }

    get mapElements() {
      return this._tableElements;
    }
    /** @override */


    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "onload")) {
        let value = this.onload;
        delete this.onload;
        this.onload = value;
      }

      upgradeProperty(this, 'src');
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "onload":
          {
            this.onload = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'src':
            if (this._src !== value) {
              this._src = value;

              if (value.trim().startsWith('{')) {
                let jsonData = JSON.parse(value);

                this._setInputMap(jsonData);
              } else {
                fetch(value).then(fileBlob => fileBlob.json()).then(jsonData => this._setInputMap(jsonData));
              }
            }

            break;
        }
      })(attribute, prev, value);
    }

    get src() {
      return this.getAttribute('src');
    }

    set src(value) {
      switch (typeof value) {
        case 'object':
          {
            let src = JSON.stringify(value);
            this._src = src;

            this._setInputMap(value);

            this.setAttribute('src', src);
          }
          break;

        case 'string':
          this.setAttribute('src', value);
          break;

        default:
          this.setAttribute('src', JSON.stringify(value));
          break;
      }
    }

    _setInputMap(inputMap) {
      let entryMap = {};
      let entryList = [];

      for (let name in inputMap) {
        let input = inputMap[name];
        let entries = [];
        inputToTableEntries(entries, name, input);
        entryMap[name] = entries;
        entryList.push(...entries);
      }

      this._bodyElement.innerHTML = '';

      for (let entry of entryList) {
        this._bodyElement.appendChild(entry);
      }

      this._inputMap = inputMap;
      this._tableElements = entryMap;
      this.dispatchEvent(new CustomEvent('load', {
        bubbles: false,
        composed: true,
        detail: {
          map: inputMap
        }
      }));
    }

  }

  window.customElements.define('input-map', InputMapElement);

  function inputToTableEntries(out, name, input) {
    if (Array.isArray(input)) {
      inputToTableEntries(out, name, input[0]);
      let length = input.length;

      for (let i = 1; i < length; ++i) {
        out.push(parseInputOption(name, input[i], false));
      }
    } else {
      out.push(parseInputOption(name, input, true));
    }

    return out;
  }

  function parseInputOption(inputName, inputOption, inputPrimary = true) {
    if (typeof inputOption === 'object') {
      const {
        key,
        event,
        scale
      } = inputOption;
      return createInputTableEntry(inputName, key, event, scale, 0, inputPrimary);
    } else {
      return createInputTableEntry(inputName, inputOption, null, 1, 0, inputPrimary);
    }
  }

  function createInputTableEntry(name, key, event, scale, value, primary = true) {
    let row = document.createElement('tr');
    if (primary) row.classList.add('primary'); // Name

    {
      let data = document.createElement('td');
      data.textContent = name;
      data.classList.add('name');
      row.appendChild(data);
    } // Key

    {
      let data = document.createElement('td');
      data.classList.add('key');
      let kbd = new InputKeyElement();
      kbd.innerText = key;
      data.appendChild(kbd);
      row.appendChild(data);
    } // Modifiers

    {
      let data = document.createElement('td');
      let samp = document.createElement('samp');
      let modifiers = [];

      if (typeof event === 'string' && event !== 'null') {
        modifiers.push(event);
      }

      if (typeof scale === 'number' && scale !== 1) {
        modifiers.push(`\u00D7(${scale.toFixed(2)})`);
      }

      samp.innerText = modifiers.join(' ');
      data.classList.add('mod');
      data.appendChild(samp);
      row.appendChild(data);
    } // Value

    {
      let data = document.createElement('td');
      let output = document.createElement('output');
      output.innerText = Number(value).toFixed(2);
      output.classList.add('value');
      data.appendChild(output);
      row.appendChild(data);
    }
    return row;
  }

  var INNER_HTML$2 = "<input-map>\n    <slot></slot>\n    <input-source></input-source>\n</input-map>\n";
  var INNER_STYLE$2 = ":host{display:inline-block}";
  var INNER_HTML$3 = "<div>\n    <label id=\"title\">\n        input-source\n    </label>\n    <span>|</span>\n    <p>\n        <label for=\"poll\">poll</label>\n        <output id=\"poll\"></output>\n    </p>\n    <p>\n        <label for=\"focus\">focus</label>\n        <output id=\"focus\"></output>\n    </p>\n</div>\n";
  var INNER_STYLE$3 = ":host{display:inline-block}div{font-family:monospace;color:#666;outline:1px solid #666;padding:4px}p{display:inline;margin:0;padding:0}#focus:empty:after,#poll:empty:after{content:\"\";color:red}";
  /** This determines whether an element has an associated input event source. */

  const INPUT_SOURCE_STATE_KEY = Symbol('inputSourceState');
  /**
   * This serves as a layer of abstraction to get unique sources of input events by target elements. Getting
   * the input source for the same event target will return the same input source instance. This allows
   * easier management of input source references without worrying about duplicates.
   * 
   * If you do not want this feature but still want the events managed, use `InputSourceState` directly instead.
   */

  class InputSource extends InputSourceState {
    /**
     * Get the associated input source for the given event target.
     * 
     * @param {EventTarget} eventTarget The target element to listen
     * for all input events.
     * @returns {InputSourceState} The input source for the given event target.
     */
    static for(eventTarget) {
      if (eventTarget) {
        return obtainInputSourceState(eventTarget);
      } else {
        throw new Error('Cannot get input source for null event target.');
      }
    }
    /**
     * Delete the associated input source for the given event target.
     * 
     * @param {EventTarget} eventTarget The target element being listened to.
     */


    static delete(eventTarget) {
      if (eventTarget) {
        releaseInputSourceState(eventTarget);
      }
    }
    /** @private */


    constructor() {
      super(); // NOTE: This is to enforce the for() and delete() structure.

      throw new Error('Cannot construct InputSource with new - use InputSourceState() instead.');
    }

  }
  /**
   * @param {EventTarget} eventTarget The target element to listen to.
   * @returns {boolean} Whether the event target has an associated input source.
   */


  function hasAttachedInputSourceState(eventTarget) {
    return Object.prototype.hasOwnProperty.call(eventTarget, INPUT_SOURCE_STATE_KEY) && Object.getOwnPropertyDescriptor(eventTarget, INPUT_SOURCE_STATE_KEY).value;
  }
  /**
   * Obtain a lease to the associated input source for the event target element.
   * 
   * @param {EventTarget} eventTarget The target element to listen to.
   */


  function obtainInputSourceState(eventTarget) {
    if (!hasAttachedInputSourceState(eventTarget)) {
      let state = new InputSourceState([new Keyboard(eventTarget), new Mouse(eventTarget)]);
      Object.defineProperty(eventTarget, INPUT_SOURCE_STATE_KEY, {
        value: {
          state: state,
          refs: 1
        },
        configurable: true
      });
      return state;
    } else {
      let descriptor = Object.getOwnPropertyDescriptor(eventTarget, INPUT_SOURCE_STATE_KEY);
      descriptor.value.refs += 1;
      return descriptor.value.state;
    }
  }
  /**
   * Release a single lease on the input source for the event target element.
   * 
   * @param {EventTarget} eventTarget The target element.
   */


  function releaseInputSourceState(eventTarget) {
    if (hasAttachedInputSourceState(eventTarget)) {
      let descriptor = Object.getOwnPropertyDescriptor(eventTarget, INPUT_SOURCE_STATE_KEY);
      descriptor.value.refs -= 1;

      if (descriptor.value.refs <= 0) {
        let state = descriptor.value.state;
        delete eventTarget[INPUT_SOURCE_STATE_KEY];
        state.destroy();
      }
    }
  }
  /**
   * @typedef {import('./InputSourceState.js').InputSourceState} InputSourceState
   */

  /** Poll status check interval in milliseconds. */


  const INTERVAL_DURATION = 1000;

  class InputSourceElement extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML$3;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE$3;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }

    static get properties() {
      return {
        for: String,

        /**
         * Whether to automatically poll the state on each frame. This is a shared
         * state with all input sources that have the same event target. In other
         * words, all input sources with the same event target must have the
         * same autopoll value, otherwise behavior is undefined.
         * 
         * Implementation-wise, the closest and most recent autopoll value is used.
         * This follows the standard HTML loading order.
         */
        autopoll: Boolean
      };
    }
    /**
                 * Whether to automatically poll the state on each frame. This is a shared
                 * state with all input sources that have the same event target. In other
                 * words, all input sources with the same event target must have the
                 * same autopoll value, otherwise behavior is undefined.
                 * 
                 * Implementation-wise, the closest and most recent autopoll value is used.
                 * This follows the standard HTML loading order.
                 */


    get autopoll() {
      return this._autopoll;
    }

    set autopoll(value) {
      this.toggleAttribute("autopoll", value);
    }

    get for() {
      return this._for;
    }

    set for(value) {
      this.setAttribute("for", value);
    }

    static get customEvents() {
      return ['input', 'poll', 'change'];
    }

    get onchange() {
      return this._onchange;
    }

    set onchange(value) {
      if (this._onchange) this.removeEventListener("change", this._onchange);
      this._onchange = value;
      if (this._onchange) this.addEventListener("change", value);
    }

    get onpoll() {
      return this._onpoll;
    }

    set onpoll(value) {
      if (this._onpoll) this.removeEventListener("poll", this._onpoll);
      this._onpoll = value;
      if (this._onpoll) this.addEventListener("poll", value);
    }

    get oninput() {
      return this._oninput;
    }

    set oninput(value) {
      if (this._oninput) this.removeEventListener("input", this._oninput);
      this._oninput = value;
      if (this._oninput) this.addEventListener("input", value);
    }

    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      /** @private */

      this._containerElement = this.shadowRoot.querySelector('div');
      /** @private */

      this._titleElement = this.shadowRoot.querySelector('#title');
      /** @private */

      this._pollElement = this.shadowRoot.querySelector('#poll');
      /** @private */

      this._focusElement = this.shadowRoot.querySelector('#focus');
      /**
       * @private
       * @type {EventTarget}
       */

      this._eventTarget = null;
      /**
       * @private
       * @type {InputSource}
       */

      this._sourceState = null;
      /** @private */

      this.onSourcePoll = this.onSourcePoll.bind(this);
      /** @private */

      this.onSourceInput = this.onSourceInput.bind(this);
      /** @private */

      this.onTargetFocus = this.onTargetFocus.bind(this);
      /** @private */

      this.onTargetBlur = this.onTargetBlur.bind(this);
      /** @private */

      this.onPollStatusCheck = this.onPollStatusCheck.bind(this);
      /** @private */

      this._intervalHandle = null;
    }

    get eventTarget() {
      return this._eventTarget;
    }

    get source() {
      return this._sourceState;
    }
    /** @override */


    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "oninput")) {
        let value = this.oninput;
        delete this.oninput;
        this.oninput = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "onpoll")) {
        let value = this.onpoll;
        delete this.onpoll;
        this.onpoll = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "onchange")) {
        let value = this.onchange;
        delete this.onchange;
        this.onchange = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "for")) {
        let value = this.for;
        delete this.for;
        this.for = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "autopoll")) {
        let value = this.autopoll;
        delete this.autopoll;
        this.autopoll = value;
      } // Allows this element to be focusable


      if (!this.hasAttribute('tabindex')) this.setAttribute('tabindex', '0'); // Initialize input source event target as self, if unset

      if (!this.hasAttribute('for') && !this._eventTarget) {
        this.setEventTarget(this);
      }

      this._intervalHandle = setInterval(this.onPollStatusCheck, INTERVAL_DURATION);
    }
    /** @override */


    disconnectedCallback() {
      this.clearEventTarget();
      clearInterval(this._intervalHandle);
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "for":
          this._for = value;
          break;

        case "autopoll":
          {
            this._autopoll = value !== null;
          }
          break;

        case "oninput":
          {
            this.oninput = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;

        case "onpoll":
          {
            this.onpoll = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;

        case "onchange":
          {
            this.onchange = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'for':
            {
              let target;
              let name;

              if (value) {
                target = document.getElementById(value);
                name = `${target.tagName.toLowerCase()}#${value}`;
              } else {
                target = this;
                name = 'input-source';
              }

              this.setEventTarget(value ? document.getElementById(value) : this); // For debug info

              this._titleElement.innerHTML = `for(${name})`;
            }
            break;

          case 'autopoll':
            {
              if (this._sourceState) {
                this._sourceState.autopoll = this._autopoll;
              }
            }
            break;
        }
      })(attribute, prev, value);
    }
    /**
     * Set event target to listen for input events.
     * 
     * @protected
     * @param {EventTarget} [eventTarget] The event target to listen for input events. If
     * falsey, no target will be listened to.
     */


    setEventTarget(eventTarget = undefined) {
      this.clearEventTarget();

      if (eventTarget) {
        let sourceState = InputSource.for(eventTarget);
        this._sourceState = sourceState;
        this._eventTarget = eventTarget;
        sourceState.autopoll = this.autopoll;
        sourceState.addEventListener('poll', this.onSourcePoll);
        sourceState.addEventListener('input', this.onSourceInput);
        eventTarget.addEventListener('focus', this.onTargetFocus);
        eventTarget.addEventListener('blur', this.onTargetBlur);
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: false
        }));
      }

      return this;
    }
    /**
     * Stop listening to the current target for input events.
     * 
     * @protected
     */


    clearEventTarget() {
      if (this._eventTarget) {
        let eventTarget = this._eventTarget;
        let sourceState = this._sourceState;
        this._eventTarget = null;
        this._sourceState = null;

        if (eventTarget) {
          eventTarget.removeEventListener('focus', this.onTargetFocus);
          eventTarget.removeEventListener('blur', this.onTargetBlur); // Event source also exists (and therefore should be removed) if event target was setup.

          sourceState.removeEventListener('poll', this.onSourcePoll);
          sourceState.removeEventListener('input', this.onSourceInput); // Clean up event source if no longer used.

          InputSource.delete(eventTarget);
        }
      }
    }
    /**
     * Poll input state from devices.
     * 
     * @param {number} now The current time in milliseconds.
     */


    poll(now) {
      this._sourceState.poll(now);
    }
    /** @private */


    onPollStatusCheck() {
      if (this._sourceState && this._sourceState.polling) {
        this._pollElement.innerHTML = '';
      } else {
        this._pollElement.innerHTML = '';
      }
    }
    /** @private */


    onSourceInput({
      stage,
      deviceName,
      keyCode,
      input
    }) {
      this.dispatchEvent(new CustomEvent('input', {
        composed: true,
        bubbles: false,
        detail: {
          stage,
          deviceName,
          keyCode,
          input
        }
      }));
    }
    /** @private */


    onSourcePoll({
      now
    }) {
      this.dispatchEvent(new CustomEvent('poll', {
        composed: true,
        bubbles: false,
        detail: {
          now
        }
      }));
    }
    /** @private */


    onTargetFocus() {
      this._focusElement.innerHTML = '';
    }
    /** @private */


    onTargetBlur() {
      this._focusElement.innerHTML = '';
    }

    static get observedAttributes() {
      return ["oninput", "onpoll", "onchange", "for", "autopoll"];
    }

  }

  window.customElements.define('input-source', InputSourceElement);
  /**
   * @typedef {import('./InputMapElement.js').InputMapElement} InputMapElement
   * @typedef {import('../source/InputSourceElement.js').InputSourceElement} InputSourceElement
   */

  /**
   * @param {HTMLElement} element The target element.
   * @param {string} propertyName The name of the property to upgrade.
   */

  function upgradeProperty$1(element, propertyName) {
    if (Object.prototype.hasOwnProperty.call(element, propertyName)) {
      let value = element[propertyName];
      delete element[propertyName];
      element[propertyName] = value;
    }
  }

  class InputPort extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML$2;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE$2;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }

    static get properties() {
      // src: A custom type,
      return {
        for: String,
        autopoll: Boolean,
        disabled: Boolean
      };
    }
    /** @override */


    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      this.toggleAttribute("disabled", value);
    }

    get autopoll() {
      return this._autopoll;
    }

    set autopoll(value) {
      this.toggleAttribute("autopoll", value);
    }

    get for() {
      return this._for;
    }

    set for(value) {
      this.setAttribute("for", value);
    }

    static get observedAttributes() {
      return ["for", "autopoll", "disabled", 'src'];
    }

    constructor(inputContext = new InputContext()) {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      /** @private */

      this._src = '';
      /**
       * @private
       * @type {InputMapElement}
       */

      this._mapElement = this.shadowRoot.querySelector('input-map');
      /**
       * @private
       * @type {InputSourceElement}
       */

      this._sourceElement = this.shadowRoot.querySelector('input-source');
      /** @private */

      this._context = inputContext;
      /** @private */

      this.onSourcePoll = this.onSourcePoll.bind(this);
      /** @private */

      this.onSourceChange = this.onSourceChange.bind(this);
      /** @private */

      this.onContextChange = this.onContextChange.bind(this);

      this._sourceElement.addEventListener('poll', this.onSourcePoll);

      this._sourceElement.addEventListener('change', this.onSourceChange);

      this._context.addEventListener('change', this.onContextChange);
    }

    get context() {
      return this._context;
    }

    get source() {
      return this._sourceElement.source;
    }

    get mapping() {
      return this._mapElement.map;
    }
    /**
     * @returns {string|object}
     */


    get src() {
      return this._src;
    }
    /**
     * @param {string|object} value
     */


    set src(value) {
      this.setAttribute('src', typeof value === 'string' ? value : JSON.stringify(value));
    }
    /** @override */


    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "for")) {
        let value = this.for;
        delete this.for;
        this.for = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "autopoll")) {
        let value = this.autopoll;
        delete this.autopoll;
        this.autopoll = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "disabled")) {
        let value = this.disabled;
        delete this.disabled;
        this.disabled = value;
      }

      upgradeProperty$1(this, 'src');
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "for":
          this._for = value;
          break;

        case "autopoll":
          {
            this._autopoll = value !== null;
          }
          break;

        case "disabled":
          {
            this._disabled = value !== null;
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'for':
            {
              this._sourceElement.for = value;
            }
            break;

          case 'src':
            if (this._src !== value) {
              this._src = value;

              if (value.trim().startsWith('{')) {
                let jsonData = JSON.parse(value);
                this.updateMapping(jsonData);
              } else {
                fetch(value).then(fileBlob => fileBlob.json()).then(jsonData => this.updateMapping(jsonData));
              }
            }

            break;

          case 'autopoll':
            this._sourceElement.autopoll = this._autopoll;
            break;

          case 'disabled':
            if (this._context.source) {
              this._context.disabled = this._disabled;
            }

            break;
        }
      })(attribute, prev, value);
    }
    /** @private */


    updateMapping(inputMapping) {
      this._context.setInputMapping(inputMapping);

      this._mapElement.src = inputMapping;
    }
    /** @private */


    onSourcePoll() {
      for (let [inputName, entries] of Object.entries(this._mapElement.mapElements)) {
        let value = this._context.getInputState(inputName);

        let primary = entries[0];
        let outputElement = primary.querySelector('output');
        outputElement.innerText = Number(value).toFixed(2);
      }
    }
    /** @private */


    onSourceChange() {
      if (this._context.source) this._context.detach();

      if (this._sourceElement.source) {
        this._context.attach(this._sourceElement.source);

        this._context.disabled = this._disabled;
      }
    }
    /** @private */


    onContextChange() {
      this._mapElement.src = this._context.mapping;
    }

    hasInput(inputName) {
      return this._context.hasInput(inputName);
    }

    getInput(inputName) {
      return this._context.getInput(inputName);
    }

    getInputState(inputName) {
      return this._context.getInputState(inputName);
    }

    getInputChanged(inputName) {
      return this._context.getInputChanged(inputName);
    }

  }

  window.customElements.define('input-port', InputPort);

  window.addEventListener('error', error, true);
  window.addEventListener('unhandledrejection', error, true);

  function error(e) {
    if (e instanceof PromiseRejectionEvent) {
      window.alert(e.reason.stack);
    } else if (e instanceof ErrorEvent) {
      window.alert(e.error.stack);
    } else {
      window.alert(JSON.stringify(e));
    }
  }

  /**
   * @typedef RandomGeneratorLike
   * @property {NumberFunction} next 
   * 
   * @callback NumberFunction Generates a pseudo-random number
   * from 0 inclusive to 1 exclusive.
   * @returns {number} A pseudo-randomly generated number.
   */

  /**
   * Represents a pseudo-random number generator. This is only used for
   * type information.
   * 
   * All random number generator instances are expected to implement
   * {@link RandomGeneratorLike}. If using classes, you can extend
   * {@link RandomBase} to enforce this, but this should not necessary
   * nor assumed.
   */
  class RandomBase {
    /**
     * Generates a pseudo-random number from 0 inclusive to 1 exclusive.
     * 
     * @abstract
     * @returns {number} A pseudo-randomly generated number.
     */
    next() {
      return 0;
    }

  }

  class MathRandom extends RandomBase {
    /** @override */
    next() {
      return Math.random();
    }

  }
  /**
   * A simple and fast 32-bit PRNG.
   * 
   * @see {@link https://github.com/bryc/code/blob/master/jshash/PRNGs.md}
   */


  class Mulberry32 extends RandomBase {
    /**
     * @param {number} seed An unsigned 32-bit integer.
     */
    constructor(seed) {
      super();
      this.seed = seed;
      /** @private */

      this.a = seed;
    }
    /** @override */


    next() {
      var t = this.a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }

  }
  /**
   * @typedef {import('./generators/RandomBase.js').RandomGeneratorLike} RandomGeneratorLike
   * @typedef {import('./generators/RandomBase.js').RandomBase} RandomBase
   */


  class Random {
    /**
     * The lazily-initiated, static instance of this random class.
     * 
     * @protected
     */
    static get RAND() {
      let instance = new this();
      Object.defineProperty(this, 'RAND', {
        value: instance
      });
      return instance;
    }
    /**
     * @param {RandomGeneratorLike|RandomBase|number} [randomGenerator]
     * If number type, the param will be used as a seed for a Mulberry32 PRNG.
     * Otherwise, it is the pseudo-random number generator object that provides
     * the generated numbers through `next()`. By default, if undefined, this
     * will use the browser-specific `Math.random()` implementation.
     */


    constructor(randomGenerator = undefined) {
      if (typeof randomGenerator === 'number') {
        this.generator = new Mulberry32(randomGenerator);
      } else if (randomGenerator) {
        this.generator = randomGenerator;
      } else {
        this.generator = new MathRandom();
      }
    }

    static next() {
      return this.RAND.next();
    }

    next() {
      return this.generator.next();
    }

    static choose(list) {
      return this.RAND.choose(list);
    }

    choose(list) {
      return list[Math.floor(this.generator.next() * list.length)];
    }

    static range(min, max) {
      return this.RAND.range(min, max);
    }

    range(min, max) {
      return (max - min) * this.generator.next() + min;
    }

    static rangeInt(min, max) {
      return this.RAND.rangeInt(min, max);
    }

    rangeInt(min, max) {
      return Math.trunc(this.range(min, max));
    }

    static sign() {
      return this.RAND.sign();
    }

    sign() {
      return this.generator.next() < 0.5 ? -1 : 1;
    }

  }

  // Bresenham's Line Algorithm
  const FILE_TYPE_PNG = 'png';
  const FILE_TYPE_SVG = 'svg';

  function downloadText(filename, textData) {
    downloadURL(filename, getTextDataURI(textData));
  }

  function downloadImageFromSVG(filename, filetype, svg, width, height) {
    const blob = createBlobFromSVG(svg);

    switch (filetype) {
      case FILE_TYPE_PNG:
        {
          const url = URL.createObjectURL(blob);
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const pixelRatio = window.devicePixelRatio || 1;
          canvas.width = width * pixelRatio;
          canvas.height = height * pixelRatio;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          const image = new Image();

          image.onload = () => {
            ctx.drawImage(image, 0, 0);
            URL.revokeObjectURL(url);
            const imageURI = canvas.toDataURL('image/' + filetype).replace('image/' + filetype, 'image/octet-stream');
            downloadURL(filename, imageURI);
          };

          image.src = url;
        }
        break;

      case FILE_TYPE_SVG:
        {
          const reader = new FileReader();

          reader.onload = () => {
            downloadURL(filename, reader.result);
          };

          reader.readAsDataURL(blob);
        }
        break;

      default:
        throw new Error('Unknown file type \'' + filetype + '\'');
    }
  }

  function downloadURL(filename, url) {
    const element = document.createElement('a');
    const headerIndex = url.indexOf(';');
    url = url.substring(0, headerIndex + 1) + 'headers=Content-Disposition%3A%20attachment%3B%20filename=' + filename + ';' + url.substring(headerIndex + 1);
    element.setAttribute('href', url);
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }

  function createBlobFromSVG(svg) {
    const styledSVG = computeSVGStyles(svg);
    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(styledSVG);
    const blob = new Blob([svgString], {
      type: 'image/svg+xml'
    });
    return blob;
  } // SOURCE: https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser/44769098#44769098


  const SVG_CONTAINERS = ['svg', 'g'];

  function computeSVGStyles(svg, dst = svg.cloneNode(true)) {
    let sourceChildren = svg.childNodes;
    let children = dst.childNodes;

    for (var index = 0; index < children.length; index++) {
      let child = children[index];
      let tagName = child.tagName;

      if (SVG_CONTAINERS.indexOf(tagName) != -1) {
        computeSVGStyles(sourceChildren[index], child);
      } else if (sourceChildren[index] instanceof Element) {
        const computedStyle = window.getComputedStyle(sourceChildren[index]);
        let styleAttributes = [];

        for (let styleName of Object.keys(computedStyle)) {
          styleAttributes.push(`${styleName}:${computedStyle.getPropertyValue(styleName)};`);
        }

        child.setAttribute('style', styleAttributes.join(''));
      }
    }

    return dst;
  }

  function getTextDataURI(data) {
    return 'data:text/plain; charset=utf-8,' + encodeURIComponent(data);
  }

  var Downloader = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FILE_TYPE_PNG: FILE_TYPE_PNG,
    FILE_TYPE_SVG: FILE_TYPE_SVG,
    downloadText: downloadText,
    downloadImageFromSVG: downloadImageFromSVG,
    downloadURL: downloadURL
  });

  async function uploadFile(accept = [], multiple = false) {
    return new Promise((resolve, reject) => {
      const element = document.createElement('input');
      element.addEventListener('change', e => {
        if (multiple) {
          resolve(e.target.files);
        } else {
          resolve(e.target.files[0]);
        }
      });
      element.type = 'file';
      element.accept = accept.join(',');
      element.style.display = 'none';
      element.toggleAttribute('multiple', multiple);
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    });
  }

  var Uploader = /*#__PURE__*/Object.freeze({
    __proto__: null,
    uploadFile: uploadFile
  }); // Log levels
  /**
   * @typedef Eventable
   * @property {function} on
   * @property {function} off
   * @property {function} once
   * @property {function} emit
   */

  /**
   * @version 1.3.0
   * @description
   * # Changelog
   * ## 1.3.0
   * - Return results for emit()
   * ## 1.2.0
   * - Added named exports
   * - Added custom this context
   * - Added some needed explanations for the functions
   * ## 1.1.0
   * - Started versioning
   */

  const EventableInstance = {
    /**
     * Registers an event handler to continually listen for the event.
     * 
     * @param {string} event The name of the event to listen for.
     * @param {function} callback The callback function to handle the event.
     * @param {*} [handle = callback] The handle to refer to this registered callback.
     * Used by off() to remove handlers. If none specified, it will use the callback
     * itself as the handle. This must be unique.
     * @return {Eventable} Self for method-chaining.
     */
    on(event, callback, handle = callback) {
      let callbacks;

      if (!this.__events.has(event)) {
        callbacks = new Map();

        this.__events.set(event, callbacks);
      } else {
        callbacks = this.__events.get(event);
      }

      if (!callbacks.has(handle)) {
        callbacks.set(handle, callback);
      } else {
        throw new Error(`Found callback for event '${event}' with the same handle '${handle}'.`);
      }

      return this;
    },

    /**
     * Unregisters an event handler to stop listening for the event.
     * 
     * @param {string} event The name of the event listened for.
     * @param {*} handle The registered handle to refer to the registered
     * callback. If no handle was provided when calling on(), the callback
     * is used as the handle instead.
     * @return {Eventable} Self for method-chaining.
     */
    off(event, handle) {
      if (this.__events.has(event)) {
        const callbacks = this.__events.get(event);

        if (callbacks.has(handle)) {
          callbacks.delete(handle);
        } else {
          throw new Error(`Unable to find callback for event '${event}' with handle '${handle}'.`);
        }
      } else {
        throw new Error(`Unable to find event '${event}'.`);
      }

      return this;
    },

    /**
     * Registers a one-off event handler to start listening for the next,
     * and only the next, event.
     * 
     * @param {string} event The name of the event to listen for.
     * @param {function} callback The callback function to handle the event.
     * @param {*} [handle = callback] The handle to refer to this registered callback.
     * Used by off() to remove handlers. If none specified, it will use the callback
     * itself as the handle. This must be unique.
     * @return {Eventable} Self for method-chaining.
     */
    once(event, callback, handle = callback) {
      const func = (...args) => {
        this.off(event, handle);
        callback.apply(this.__context || this, args);
      };

      return this.on(event, func, handle);
    },

    /**
     * Emits the event with the arguments passed on to the registered handlers.
     * The context of the handlers, if none were initially bound, could be
     * defined upon calling the Eventable's creation function. Otherwise, the
     * handler is called with `this` context of the Eventable instance.
     * 
     * @param {string} event The name of the event to emit.
     * @param  {...any} args Any arguments to pass to registered handlers.
     * @return {Array<any>} Array of any returned values of the callbacks.
     */
    emit(event, ...args) {
      if (this.__events.has(event)) {
        let results = [];
        const callbacks = Array.from(this.__events.get(event).values());

        for (const callback of callbacks) {
          let result = callback.apply(this.__context || this, args);
          if (result) results.push(result);
        }

        return results;
      } else {
        this.__events.set(event, new Map());

        return [];
      }
    }

  };
  /**
   * Creates an eventable object.
   * 
   * @param {Object} [context] The context used for the event handlers.
   * @return {Eventable} The created eventable object.
   */

  function create(context = undefined) {
    const result = Object.create(EventableInstance);
    result.__events = new Map();
    result.__context = context;
    return result;
  }
  /**
   * Assigns the passed-in object with eventable properties.
   * 
   * @param {Object} dst The object to assign with eventable properties.
   * @param {Object} [context] The context used for the event handlers.
   * @return {Eventable} The resultant eventable object.
   */


  function assign(dst, context = undefined) {
    const result = Object.assign(dst, EventableInstance);
    result.__events = new Map();
    result.__context = context;
    return result;
  }
  /**
   * Mixins eventable properties into the passed-in class.
   * 
   * @param {Class} targetClass The class to mixin eventable properties.
   * @param {Object} [context] The context used for the event handlers.
   * @return {Class<Eventable>} The resultant eventable-mixed-in class.
   */


  function mixin(targetClass, context = undefined) {
    const targetPrototype = targetClass.prototype;
    Object.assign(targetPrototype, EventableInstance);
    targetPrototype.__events = new Map();
    targetPrototype.__context = context;
    return targetPrototype;
  }

  var Eventable = {
    create,
    assign,
    mixin
  };
  var Eventable$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    create: create,
    assign: assign,
    mixin: mixin,
    'default': Eventable
  });

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function distance2(fromX, fromY, toX, toY) {
    let dx = toX - fromX;
    let dy = toY - fromY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$2() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp$1(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  })();

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$4() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$4();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  })();

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$5() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */

  (function () {
    var tmpvec3 = create$3();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function (out, a, b) {
      var dot$1 = dot(a, b);

      if (dot$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$1;
        return normalize$2(out, out);
      }
    };
  })();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  (function () {
    var temp1 = create$5();
    var temp2 = create$5();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  })();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  (function () {
    var matr = create$1();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  })();

  class Camera2D {
    static screenToWorld(screenX, screenY, viewMatrix, projectionMatrix) {
      let mat = multiply(create$2(), projectionMatrix, viewMatrix);
      invert(mat, mat);
      let result = fromValues(screenX, screenY, 0);
      transformMat4(result, result, mat);
      return result;
    }

    constructor(left = -1, right = 1, top = -1, bottom = 1, near = 0, far = 1) {
      this.position = create$3();
      this.rotation = create$5();
      this.scale = fromValues(1, 1, 1);
      this.clippingPlane = {
        left,
        right,
        top,
        bottom,
        near,
        far
      };
      this._viewMatrix = create$2();
      this._projectionMatrix = create$2();
    }

    get x() {
      return this.position[0];
    }

    set x(value) {
      this.position[0] = value;
    }

    get y() {
      return this.position[1];
    }

    set y(value) {
      this.position[1] = value;
    }

    get z() {
      return this.position[2];
    }

    set z(value) {
      this.position[2] = value;
    }
    /** Moves the camera. This is the only way to change the position. */


    moveTo(x, y, z = 0, dt = 1) {
      let nextPosition = fromValues(x, y, z);
      lerp$1(this.position, this.position, nextPosition, Math.min(1, dt));
    }

    getViewMatrix(out = this._viewMatrix) {
      let viewX = -Math.round(this.x);
      let viewY = -Math.round(this.y);
      let viewZ = this.z === 0 ? 1 : 1 / this.z;
      let invPosition = fromValues(viewX, viewY, 0);
      let invScale = fromValues(this.scale[0] * viewZ, this.scale[1] * viewZ, 1);
      fromRotationTranslationScale(out, this.rotation, invPosition, invScale);
      return out;
    }

    getProjectionMatrix(out = this._projectionMatrix) {
      let {
        left,
        right,
        top,
        bottom,
        near,
        far
      } = this.clippingPlane;
      ortho(out, left, right, top, bottom, near, far);
      return out;
    }

  }

  function toChunkId(chunkCoordX, chunkCoordY) {
    return chunkCoordX + ',' + chunkCoordY;
  }
  function toChunkCoords(chunkId) {
    let separator = chunkId.indexOf(',');
    let chunkCoordX = Number(chunkId.substring(0, separator));
    let chunkCoordY = Number(chunkId.substring(separator + 1));
    return [chunkCoordX, chunkCoordY];
  }
  class Chunk {
    constructor(chunkManager, chunkId, chunkCoordX, chunkCoordY, chunkData) {
      this.chunkManager = chunkManager;
      this.chunkId = chunkId;
      this.chunkCoordX = chunkCoordX;
      this.chunkCoordY = chunkCoordY;
      this._data = chunkData;
    }

    get data() {
      return this._data;
    }

  }
  class ChunkData {
    constructor(width, height) {
      const length = width * height;
      this.block = new Uint8Array(length).fill(0);
      this.meta = new Uint8Array(length).fill(0);
      this.neighbor = new Uint8Array(length).fill(0b1111);
    }

  }

  class BlockPos {
    constructor(chunkWidth, chunkHeight) {
      this._chunkWidth = chunkWidth;
      this._chunkHeight = chunkHeight;
      this._x = 0;
      this._y = 0;
      this._blockCoordX = 0;
      this._blockCoordY = 0;
      this._index = 0;
      this._chunkCoordX = 0;
      this._chunkCoordY = 0;
      this._chunkId = null;
    }

    get x() {
      return this._x;
    }

    get y() {
      return this._y;
    }

    get blockCoordX() {
      return this._blockCoordX;
    }

    get blockCoordY() {
      return this._blockCoordY;
    }

    get index() {
      return this._index;
    }

    get chunkCoordX() {
      return this._chunkCoordX;
    }

    get chunkCoordY() {
      return this._chunkCoordY;
    }

    get chunkId() {
      return this._chunkId;
    }
    /**
     * Creates a new instance of this BlockPos. This does not copy values, only initializes a new instance.
     * Because of this, this is useful when we the position is arbitrary, but we want a new instance to modify.
     */


    clone() {
      return new BlockPos(this._chunkWidth, this._chunkHeight);
    }

    set(x, y) {
      this._x = x;
      this._y = y;
      const chunkWidth = this._chunkWidth;
      const chunkHeight = this._chunkHeight;

      if (x < 0) {
        this._blockCoordX = Math.abs(chunkWidth + Math.floor(x)) % chunkWidth;
      } else {
        this._blockCoordX = Math.floor(x) % chunkWidth;
      }

      if (y < 0) {
        this._blockCoordY = Math.abs(chunkHeight + Math.floor(y)) % chunkHeight;
      } else {
        this._blockCoordY = Math.floor(y) % chunkHeight;
      }

      this._index = this._blockCoordX + this._blockCoordY * chunkWidth;
      this._chunkCoordX = Math.floor(x / chunkWidth);
      this._chunkCoordY = Math.floor(y / chunkHeight);
      this._chunkId = toChunkId(this._chunkCoordX, this._chunkCoordY);
      return this;
    }

    copy(out = this.clone()) {
      out._x = this.x;
      out._y = this.y;
      out._blockCoordX = this.blockCoordX;
      out._blockCoordY = this.blockCoordY;
      out._index = this.index;
      out._chunkCoordX = this.chunkCoordX;
      out._chunkCoordY = this.chunkCoordY;
      out._chunkId = this.chunkId;
      return out;
    }

    offset(out = this, dx = 0, dy = 0) {
      return out.set(this.x + dx, this.y + dy);
    }

    down(out = this, offset = 1) {
      return out.set(this.x, this.y + offset);
    }

    up(out = this, offset = 1) {
      return out.set(this.x, this.y - offset);
    }

    right(out = this, offset = 1) {
      return out.set(this.x + offset, this.y);
    }

    left(out = this, offset = 1) {
      return out.set(this.x - offset, this.y);
    }

    reset(src = null) {
      if (src) {
        return src.copy(this);
      } else {
        return this.set(0, 0);
      }
    }

    equals(blockPos) {
      return Math.abs(this.x - blockPos.x) < Number.EPSILON && Math.abs(this.y - blockPos.y) < Number.EPSILON;
    }
    /** @override */


    toString(details = false) {
      return `BlockPos(${this.x},${this.y})` + (details ? `:Chunk[${this.chunkId}]@{${this.blockCoordX},${this.blockCoordY}}[${this.index}],` : '');
    }

  }

  class ChunkManager {
    constructor(chunkWidth, chunkHeight) {
      this.chunkWidth = chunkWidth;
      this.chunkHeight = chunkHeight;
      this.chunks = {};
    }

    clear() {
      this.chunks = {};
    }

    getChunkById(chunkId) {
      if (chunkId in this.chunks) {
        return this.chunks[chunkId];
      } else {
        const [chunkCoordX, chunkCoordY] = toChunkCoords(chunkId);
        let chunkData = new ChunkData(this.chunkWidth, this.chunkHeight);
        let chunk = new Chunk(this, chunkId, chunkCoordX, chunkCoordY, chunkData);
        this.chunks[chunkId] = chunk;
        return chunk;
      }
    }

    getChunkByCoord(chunkCoordX, chunkCoordY) {
      const chunkId = toChunkId(chunkCoordX, chunkCoordY);
      return this.getChunkById(chunkId);
    }

    getChunksWithinBounds(fromBlockPos, toBlockPos) {
      let dst = [];
      const fromChunkCoordX = fromBlockPos.chunkCoordX;
      const fromChunkCoordY = fromBlockPos.chunkCoordY;
      const toChunkCoordX = toBlockPos.chunkCoordX;
      const toChunkCoordY = toBlockPos.chunkCoordY;

      for (let chunkCoordY = fromChunkCoordY; chunkCoordY <= toChunkCoordY; ++chunkCoordY) {
        for (let chunkCoordX = fromChunkCoordX; chunkCoordX <= toChunkCoordX; ++chunkCoordX) {
          const chunkId = toChunkId(chunkCoordX, chunkCoordY);
          dst.push(this.getChunkById(chunkId));
        }
      }

      return dst;
    }

    getLoadedChunks() {
      let dst = [];

      for (let chunkId of Object.keys(this.chunks)) {
        let chunk = this.chunks[chunkId];
        dst.push(chunk);
      }

      return dst;
    }

  }

  class ChunkMap extends ChunkManager {
    constructor(left = -Infinity, top = -Infinity, right = Infinity, bottom = Infinity, chunkWidth = Number.isFinite(right - left) ? right - left : 16, chunkHeight = Number.isFinite(bottom - top) ? bottom - top : 16) {
      super(chunkWidth, chunkHeight);
      this.bounds = {
        left,
        right,
        top,
        bottom
      };
    }

    isWithinBounds(blockPos) {
      if (!blockPos) return false;
      const {
        x,
        y
      } = blockPos;
      return x <= this.bounds.right && x >= this.bounds.left && y <= this.bounds.bottom && y >= this.bounds.top;
    }

    isWithinLoaded(blockPos) {
      return blockPos.chunkId in this.chunks;
    }

    getChunk(blockPos) {
      return this.getChunkById(blockPos.chunkId);
    }

    getBlockId(blockPos) {
      return this.getChunkById(blockPos.chunkId).data.block[blockPos.index];
    }

    getBlockMeta(blockPos) {
      return this.getChunkById(blockPos.chunkId).data.meta[blockPos.index];
    }

    getBlockNeighbor(blockPos) {
      return this.getChunkById(blockPos.chunkId).data.neighbor[blockPos.index];
    }

    setBlockId(blockPos, value) {
      this.getChunkById(blockPos.chunkId).data.block[blockPos.index] = value;
      return this;
    }

    setBlockMeta(blockPos, value) {
      this.getChunkById(blockPos.chunkId).data.meta[blockPos.index] = value;
      return this;
    }

    setBlockNeighbor(blockPos, value) {
      this.getChunkById(blockPos.chunkId).data.neighbor[blockPos.index] = value;
      return this;
    }

    at(x, y) {
      return new BlockPos(this.chunkWidth, this.chunkHeight).set(x, y);
    }

  }

  class BlockRegistry {
    constructor() {
      this.blocks = {};
      this.components = {};
    }

    register(blockId, ...components) {
      if (blockId in this.blocks) {
        throw new Error(`BlockId '${blockId}' already registered.`);
      }

      const componentOpts = components.map(opt => !Array.isArray(opt) ? [opt, true] : opt);

      for (let [component, initial] of componentOpts) {
        if (!(component in this.components)) this.components[component] = {};
        let blockComponents = this.components[component];
        if (blockId in blockComponents) throw new Error(`Component '${component}' for block '${blockId}' already registered.`);
        let value;

        if (typeof initial === 'object') {
          value = Object.assign({}, initial);
        } else {
          value = initial;
        }

        blockComponents[blockId] = value;
      }

      let block = new Block(this, blockId, componentOpts);
      this.blocks[blockId] = block;
      return block;
    }

    getBlock(blockId) {
      if (blockId in this.blocks) {
        return this.blocks[blockId];
      } else {
        return null;
      }
    }

    getBlocks() {
      return Object.values(this.blocks);
    }

    getBlockIds() {
      return Object.keys(this.blocks);
    }

    getBlockComponents(blockId) {
      let result = [];

      for (let blockComponents of this.components) {
        if (blockId in blockComponents) {
          result.push(blockComponents[blockId]);
        }
      }

      return result;
    }

    hasComponent(component, blockId) {
      return component in this.components && blockId in this.components[component];
    }

    getComponent(component, blockId) {
      if (component in this.components) {
        let blockComponents = this.components[component];

        if (blockId in blockComponents) {
          return blockComponents[blockId];
        }
      }

      return null;
    }

    getComponents(component) {
      if (component in this.components) {
        let blockComponents = this.components[component];
        return Object.values(blockComponents);
      }
    }

    getComponentNames() {
      return Object.keys(this.components);
    }

  }

  class Block {
    constructor(blockRegistry, blockId, componentOpts) {
      this.blockRegistry = blockRegistry;
      this.blockId = blockId;
      this.blockOpts = componentOpts;

      for (let [component, values] of componentOpts) {
        this[component] = blockRegistry.getComponent(component, blockId);
      }
    }
    /** @override */


    toString() {
      return `Block#${this.blockId}`;
    }

  }

  const BLOCKS = new BlockRegistry();

  BLOCKS.register(0, 'air');
  BLOCKS.register(1, 'fluid', ['color', 'dodgerblue'], ['material', 'fluid']);
  const DIRT = BLOCKS.register(3, 'solid', 'grassSoil', ['color', 'saddlebrown'], ['material', 'dirt']);
  const GOLD = BLOCKS.register(4, 'solid', ['color', 'gold'], ['material', 'metal']);
  const GRASS = BLOCKS.register(5, 'solid', ['color', 'limegreen'], ['material', 'dirt']);
  BLOCKS.register(6, 'solid', ['color', 'slategray'], ['material', 'stone']);
  BLOCKS.register(7, 'solid', ['color', 'salmon'], ['material', 'stone']);
  BLOCKS.register(8, 'solid', ['color', 'powderblue'], ['material', 'metal']);
  BLOCKS.register(9, 'solid', ['color', 'rebeccapurple'], ['material', 'stone']);
  BLOCKS.register(10, 'solid', ['color', 'teal'], ['material', 'stone']);
  BLOCKS.register(11, 'solid', ['color', 'mediumvioletred'], ['material', 'stone']);
  BLOCKS.register(12, 'solid', ['color', 'navajowhite'], ['material', 'dirt']);

  const UPDATE_EVENT = 'update';
  const WORLD_UPDATE_EVENT = 'worldUpdate';
  const CHUNK_UPDATE_EVENT = 'chunkUpdate';
  const BLOCK_UPDATE_EVENT = 'blockUpdate';
  function emitUpdateEvent(world) {
    world.emit(UPDATE_EVENT, world);
  }
  function emitWorldUpdateEvent(world) {
    world.emit(WORLD_UPDATE_EVENT, world);
  }
  function emitChunkUpdateEvent(world, chunk) {
    world.emit(CHUNK_UPDATE_EVENT, world, chunk);
  }
  function emitBlockUpdateEvent(world, chunk, blockPos) {
    world.emit(BLOCK_UPDATE_EVENT, world, chunk, blockPos);
  }

  const PLACE_EVENT = 'place';
  const BREAK_EVENT = 'break';
  function emitPlaceEvent(world, blockPos, blockId) {
    world.emit(PLACE_EVENT, world, blockPos, blockId);
  }
  function emitBreakEvent(world, blockPos, blockId) {
    world.emit(BREAK_EVENT, world, blockPos, blockId);
  }

  const AIR_COMPONENT = 'air';
  const FLUID_COMPONENT = 'fluid';
  const MAX_FLUID_LEVELS = 3;
  function initialize(world) {
    world.on(PLACE_EVENT, onBlockPlace);
    world.on(WORLD_UPDATE_EVENT, onWorldUpdate);
  }

  function onBlockPlace(world, blockPos, blockId) {
    if (BLOCKS.hasComponent(FLUID_COMPONENT, blockId)) {
      world.map.setBlockMeta(blockPos, MAX_FLUID_LEVELS);
    }
  }

  function onWorldUpdate(world) {
    let sortedChunks = sortChunksByBottomFirst(world.map.getLoadedChunks());

    for (let chunk of sortedChunks) {
      updateFluidsInChunk(world, chunk);
    }
  }

  function sortChunksByBottomFirst(chunks) {
    return chunks.sort((a, b) => {
      if (a.chunkCoordY < b.chunkCoordY) {
        return 1;
      } else if (a.chunkCoordY > b.chunkCoordY) {
        return -1;
      } else if (a.chunkCoordX < b.chunkCoordX) {
        return 1;
      } else if (a.chunkCoordX > b.chunkCoordX) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  function updateFluidsInChunk(world, chunk) {
    const worldMap = world.map;
    const chunkX = chunk.chunkCoordX * worldMap.chunkWidth;
    const chunkY = chunk.chunkCoordY * worldMap.chunkHeight; // Do water physics.

    let blockPos = worldMap.at(0, 0);

    for (let y = worldMap.chunkHeight - 1; y >= 0; --y) {
      for (let x = 0; x < worldMap.chunkWidth; ++x) {
        blockPos.set(x + chunkX, y + chunkY);
        let blockId = worldMap.getBlockId(blockPos);

        if (BLOCKS.hasComponent(FLUID_COMPONENT, blockId)) {
          updateFluidBlock(world, blockPos);
        }
      }
    }
  }

  function updateFluidBlock(world, blockPos) {
    const worldMap = world.map;

    if (!tryFlowWaterDown(worldMap, blockPos) && !tryFlowWaterSide(worldMap, blockPos)) ;
  }

  function tryFlowWaterDown(worldMap, blockPos) {
    let toBlockPos = blockPos.copy().down();
    return flowWater(worldMap, blockPos, toBlockPos, MAX_FLUID_LEVELS);
  }

  function tryFlowWaterSide(worldMap, blockPos) {
    let flag = false;
    let meta = worldMap.getBlockMeta(blockPos);
    let toBlockPos = blockPos.copy();

    if (meta <= 1) {
      blockPos.offset(toBlockPos, 1 * Random.sign(), 0);
      flag |= flowWater(worldMap, blockPos, toBlockPos, 1, false);
    } else {
      blockPos.offset(toBlockPos, 1 * Random.sign(), 0);
      flag |= flowWater(worldMap, blockPos, toBlockPos, 1, false);
      blockPos.offset(toBlockPos, 1 * Random.sign(), 0);
      flag |= flowWater(worldMap, blockPos, toBlockPos, 1, false);
    }

    return flag;
  }

  function flowWater(worldMap, fromBlockPos, toBlockPos, amount, allowBackflow = true) {
    if (!worldMap.isWithinBounds(toBlockPos)) return false;

    if (!worldMap.isWithinLoaded(toBlockPos)) {
      worldMap.setBlockId(fromBlockPos, 0);
      worldMap.setBlockMeta(fromBlockPos, 0);
      return true;
    }

    let fromBlock = worldMap.getBlockId(fromBlockPos);
    let fromMeta = worldMap.getBlockMeta(fromBlockPos);
    let toBlock = worldMap.getBlockId(toBlockPos);
    let toMeta = worldMap.getBlockMeta(toBlockPos);
    if (amount > fromMeta) amount = fromMeta;

    if (BLOCKS.hasComponent(AIR_COMPONENT, toBlock)) {
      let remainder = fromMeta - amount;

      if (remainder <= 0) {
        worldMap.setBlockId(toBlockPos, fromBlock).setBlockMeta(toBlockPos, fromMeta).setBlockId(fromBlockPos, 0).setBlockMeta(fromBlockPos, 0);
        return true;
      } else {
        worldMap.setBlockId(toBlockPos, fromBlock).setBlockMeta(toBlockPos, amount).setBlockMeta(fromBlockPos, remainder);
        return true;
      }
    } else if (BLOCKS.hasComponent(FLUID_COMPONENT, toBlock) && toMeta < MAX_FLUID_LEVELS) {
      if (!allowBackflow && fromMeta <= toMeta) return false;

      if (toMeta + amount <= MAX_FLUID_LEVELS) {
        worldMap.setBlockMeta(toBlockPos, toMeta + amount);

        if (amount >= fromMeta) {
          worldMap.setBlockId(fromBlockPos, 0).setBlockMeta(fromBlockPos, 0);
        } else {
          worldMap.setBlockMeta(fromBlockPos, fromMeta - amount);
        }

        return true;
      } else {
        worldMap.setBlockMeta(toBlockPos, MAX_FLUID_LEVELS);
        let remainder = amount - (MAX_FLUID_LEVELS - toMeta);
        worldMap.setBlockMeta(fromBlockPos, remainder);
        return true;
      }
    }
  }

  function hasUpNeighbor(neighbor) {
    return (neighbor & 0b0010) >> 1 > 0;
  }
  function onBlockPlace$1(world, blockPos, blockId) {
    const worldMap = world.map;
    let out = blockPos.clone();
    let neighbor = 0b0000;

    if (worldMap.isWithinBounds(blockPos.right(out)) && worldMap.getBlockId(out) === blockId) {
      neighbor |= 0b0001;
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) | 0b0100);
    }

    if (worldMap.isWithinBounds(blockPos.up(out)) && worldMap.getBlockId(out) === blockId) {
      neighbor |= 0b0010;
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) | 0b1000);
    }

    if (worldMap.isWithinBounds(blockPos.left(out)) && worldMap.getBlockId(out) === blockId) {
      neighbor |= 0b0100;
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) | 0b0001);
    }

    if (worldMap.isWithinBounds(blockPos.down(out)) && worldMap.getBlockId(out) === blockId) {
      neighbor |= 0b1000;
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) | 0b0010);
    }

    worldMap.setBlockNeighbor(blockPos, neighbor);
  }
  function onBlockBreak(world, blockPos, blockId) {
    const worldMap = world.map;
    let out = blockPos.clone();

    if (worldMap.isWithinBounds(blockPos.right(out)) && worldMap.getBlockId(out) === blockId) {
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) & 0b1011);
    }

    if (worldMap.isWithinBounds(blockPos.up(out)) && worldMap.getBlockId(out) === blockId) {
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) & 0b0111);
    }

    if (worldMap.isWithinBounds(blockPos.left(out)) && worldMap.getBlockId(out) === blockId) {
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) & 0b1110);
    }

    if (worldMap.isWithinBounds(blockPos.down(out)) && worldMap.getBlockId(out) === blockId) {
      worldMap.setBlockNeighbor(out, worldMap.getBlockNeighbor(out) & 0b1101);
    }

    worldMap.setBlockNeighbor(blockPos, 0);
  }

  function placeBlock(world, blockPos, blockId, blockMeta = 0) {
    const prevBlockId = world.map.getBlockId(blockPos);
    const isNextFluid = BLOCKS.hasComponent(FLUID_COMPONENT, blockId); // Break the previous block, as long as the next block is NOT a fluid.

    if (!isNextFluid) {
      emitBreakEvent(world, blockPos, prevBlockId);
      const isPrevFluid = BLOCKS.hasComponent(FLUID_COMPONENT, prevBlockId);

      if (!isPrevFluid) {
        onBlockBreak(world, blockPos, prevBlockId);
      }
    } else if (!BLOCKS.hasComponent(AIR_COMPONENT, prevBlockId)) {
      // If it IS a fluid, then it should not replace anything but AIR.
      return;
    }

    world.map.setBlockId(blockPos, blockId);
    world.map.setBlockMeta(blockPos, blockMeta);

    if (!isNextFluid) {
      onBlockPlace$1(world, blockPos, blockId);
    }

    emitPlaceEvent(world, blockPos, blockId);
  }

  const GRASS_SOIL_COMPONENT = 'grassSoil';
  const GRASS_BLOCK_ID = 5;
  function initialize$1(world) {
    world.on(BLOCK_UPDATE_EVENT, onBlockUpdate);
  }

  function onBlockUpdate(world, chunk, blockPos) {
    const worldMap = world.map;
    let blockId = worldMap.getBlockId(blockPos);

    if (BLOCKS.hasComponent(GRASS_SOIL_COMPONENT, blockId)) {
      let upBlockId = worldMap.getBlockId(blockPos.up());

      if (BLOCKS.hasComponent(AIR_COMPONENT, upBlockId)) {
        if (Random.next() < 0.001) {
          placeBlock(world, blockPos, GRASS_BLOCK_ID);
        }
      }
    }
  }

  /* global process */
  class AssetManager {
    constructor() {
      this.assetPath = '' ;
      this.loaders = {};
      this.assets = {};
      this.loadingQueue = [];
    }

    registerLoader(loaderName, loader) {
      this.loaders[loaderName] = loader;
      return this;
    }

    registerAsset(loader, name, url, opts = null) {
      if (!(loader in this.assets)) {
        this.assets[loader] = {};
      }

      let assetMap = this.assets[loader];
      let asset = {
        value: null,
        url,
        opts
      };
      assetMap[name] = asset;
      this.loadingQueue.push(asset);
      return this;
    }

    async loadAssets() {
      let cache = {};
      let errors = [];

      for (let loaderName of Object.keys(this.assets)) {
        let assetMap = this.assets[loaderName];

        if (loaderName in this.loaders) {
          let loader = this.loaders[loaderName];

          for (let assetName of Object.keys(assetMap)) {
            const {
              url,
              opts
            } = assetMap[assetName];
            let assetValue;
            const cacheKey = url + '?opts=' + JSON.stringify(opts);

            if (cacheKey in cache) {
              assetValue = cache[cacheKey];
            } else {
              try {
                assetValue = await loader.call(undefined, this.assetPath + url, opts || {});
                cache[cacheKey] = assetValue;
              } catch (e) {
                errors.push(e);
                continue;
              }
            }

            let asset = assetMap[assetName];
            asset.value = assetValue;
          }
        } else {
          throw new Error(`Missing loader for '${loaderName}'.`);
        }
      }

      if (errors.length > 0) {
        throw new Error('Failed to load assets: ' + errors);
      }
    }

    getAsset(loader, name) {
      return this.assets[loader][name].value;
    }

  }

  const AUDIO_CONTEXT = new AudioContext();
  autoUnlock(AUDIO_CONTEXT);
  async function loadAudio(filepath, opts = {}) {
    const ctx = AUDIO_CONTEXT;
    let result = await fetch(filepath);
    let buffer = await result.arrayBuffer();
    let data = await ctx.decodeAudioData(buffer);
    return new Sound(ctx, data, Boolean(opts.loop));
  }
  const DEFAULT_SOURCE_PARAMS = {
    gain: 0,
    pitch: 0,
    pan: 0,
    loop: false
  };

  class Sound {
    constructor(ctx, audioBuffer, loop = false) {
      this.context = ctx;
      this.buffer = audioBuffer;
      this._source = null;
      this.playing = false;
      this.loop = loop;
      this.onAudioSourceEnded = this.onAudioSourceEnded.bind(this);
    }

    onAudioSourceEnded() {
      this._playing = false;
    }

    play(opts = DEFAULT_SOURCE_PARAMS) {
      if (!this.buffer) return;
      if (this._source) this.destroy();
      const ctx = this.context;
      let source = ctx.createBufferSource();
      source.addEventListener('ended', this.onAudioSourceEnded);
      source.buffer = this.buffer;
      source.loop = opts.loop;
      let prevNode = source; // https://www.oreilly.com/library/view/web-audio-api/9781449332679/ch04.html
      // Add pitch

      if (opts.pitch) {
        source.detune.value = opts.pitch * 100;
      } // Add gain


      if (opts.gain) {
        const gainNode = ctx.createGain();
        gainNode.gain.value = opts.gain;
        prevNode = prevNode.connect(gainNode);
      } // Add stereo pan


      if (opts.pan) {
        const pannerNode = ctx.createStereoPanner();
        pannerNode.pan.value = opts.pan;
        prevNode = prevNode.connect(pannerNode);
      }

      prevNode.connect(ctx.destination);
      source.start();
      this._source = source;
      this._playing = true;
    }

    pause() {
      this._source.stop();

      this._playing = false;
    }

    destroy() {
      if (this._source) this._source.disconnect();
      this._source = null;
    }

  }

  async function autoUnlock(ctx) {
    const callback = () => {
      if (ctx.state === 'suspended') {
        ctx.resume();
      }
    };

    document.addEventListener('click', callback);
  }

  const ASSETS = new AssetManager().registerLoader('audio', loadAudio);

  const MATERIAL_COMPONENT = 'material';
  async function load(assets) {
    assets.registerAsset('audio', 'dirt', 'arroyo/dirt.wav');
    assets.registerAsset('audio', 'stone', 'arroyo/stone.wav');
    assets.registerAsset('audio', 'fluid', 'arroyo/waterpop.wav');
    assets.registerAsset('audio', 'metal', 'arroyo/ding.wav');
  }
  function playPlaceSound(blockId) {
    let material = getMaterial(blockId);

    switch (material) {
      case 'dirt':
        ASSETS.getAsset('audio', 'dirt').play({
          pitch: Random.range(-5, 5)
        });
        break;

      case 'fluid':
        ASSETS.getAsset('audio', 'fluid').play({
          pitch: Random.range(-5, 5)
        });
        break;

      case 'metal':
        ASSETS.getAsset('audio', 'metal').play({
          gain: 4,
          pitch: Random.range(-5, 5)
        });
        break;

      case 'stone':
      default:
        ASSETS.getAsset('audio', 'stone').play({
          gain: 1.5,
          pitch: Random.range(-5, 5)
        });
        break;
    }
  }
  function getMaterial(blockId) {
    if (BLOCKS.hasComponent(MATERIAL_COMPONENT, blockId)) {
      return BLOCKS.getComponent(MATERIAL_COMPONENT, blockId);
    } else {
      return 'stone';
    }
  }

  const AIR_COMPONENT$1 = 'air';
  const FALLING_COMPONENT = 'falling';
  function initialize$2(world) {
    world.on(WORLD_UPDATE_EVENT, onWorldUpdate$1);
  } // TODO: What happens if it falls in water?
  // TODO: It should not update neighbor until it is stable.

  function onWorldUpdate$1(world) {
    let sortedChunks = sortChunksByBottomFirst$1(world.map.getLoadedChunks());

    for (let chunk of sortedChunks) {
      updateFallingInChunk(world, chunk);
    }
  }

  function sortChunksByBottomFirst$1(chunks) {
    return chunks.sort((a, b) => {
      if (a.chunkCoordY < b.chunkCoordY) {
        return 1;
      } else if (a.chunkCoordY > b.chunkCoordY) {
        return -1;
      } else if (a.chunkCoordX < b.chunkCoordX) {
        return 1;
      } else if (a.chunkCoordX > b.chunkCoordX) {
        return -1;
      } else {
        return 0;
      }
    });
  }

  function updateFallingInChunk(world, chunk) {
    const worldMap = world.map;
    const chunkX = chunk.chunkCoordX * worldMap.chunkWidth;
    const chunkY = chunk.chunkCoordY * worldMap.chunkHeight; // Do falling physics.

    let blockPos = worldMap.at(0, 0);

    for (let y = worldMap.chunkHeight - 1; y >= 0; --y) {
      for (let x = 0; x < worldMap.chunkWidth; ++x) {
        blockPos.set(x + chunkX, y + chunkY);
        let blockId = worldMap.getBlockId(blockPos);

        if (BLOCKS.hasComponent(FALLING_COMPONENT, blockId)) {
          updateFallingBlock(world, blockPos);
        }
      }
    }
  }

  function updateFallingBlock(world, blockPos) {
    const worldMap = world.map;

    if (!tryFallingDown(worldMap, blockPos)) ;
  }

  function tryFallingDown(worldMap, blockPos) {
    let toBlockPos = blockPos.copy().down();
    return fallBlock(worldMap, blockPos, toBlockPos);
  }

  function fallBlock(worldMap, fromBlockPos, toBlockPos) {
    if (!worldMap.isWithinBounds(toBlockPos)) return false;

    if (!worldMap.isWithinLoaded(toBlockPos)) {
      worldMap.setBlockId(fromBlockPos, 0);
      return true;
    }

    let fromBlock = worldMap.getBlockId(fromBlockPos);
    let toBlock = worldMap.getBlockId(toBlockPos);

    if (BLOCKS.hasComponent(AIR_COMPONENT$1, toBlock)) {
      worldMap.setBlockId(toBlockPos, fromBlock).setBlockId(fromBlockPos, 0);
      return true;
    }
  }

  const IMINO = [{
    w: 1,
    h: 4,
    m: [1, 1, 1, 1]
  }, {
    w: 4,
    h: 1,
    m: [1, 1, 1, 1]
  }];
  const OMINO = [{
    w: 2,
    h: 2,
    m: [1, 1, 1, 1]
  }];
  const TMINO = [{
    w: 3,
    h: 2,
    m: [0, 1, 0, 1, 1, 1]
  }, {
    w: 2,
    h: 3,
    m: [1, 0, 1, 1, 1, 0]
  }, {
    w: 3,
    h: 2,
    m: [1, 1, 1, 0, 1, 0]
  }, {
    w: 2,
    h: 3,
    m: [0, 1, 1, 1, 0, 1]
  }];
  const LMINO = [{
    w: 2,
    h: 3,
    m: [1, 0, 1, 0, 1, 1]
  }, {
    w: 3,
    h: 2,
    m: [0, 0, 1, 1, 1, 1]
  }, {
    w: 2,
    h: 3,
    m: [1, 1, 0, 1, 0, 1]
  }, {
    w: 3,
    h: 2,
    m: [1, 1, 1, 1, 0, 0]
  }];
  const JMINO = [{
    w: 2,
    h: 3,
    m: [0, 1, 0, 1, 1, 1]
  }, {
    w: 3,
    h: 2,
    m: [1, 0, 0, 1, 1, 1]
  }, {
    w: 2,
    h: 3,
    m: [1, 1, 1, 0, 1, 0]
  }, {
    w: 3,
    h: 2,
    m: [1, 1, 1, 0, 0, 1]
  }];
  const ZMINO = [{
    w: 3,
    h: 2,
    m: [1, 1, 0, 0, 1, 1]
  }, {
    w: 2,
    h: 3,
    m: [0, 1, 1, 1, 1, 0]
  }];
  const SMINO = [{
    w: 3,
    h: 2,
    m: [0, 1, 1, 1, 1, 0]
  }, {
    w: 2,
    h: 3,
    m: [1, 0, 1, 1, 0, 1]
  }];
  const ALL = [IMINO, OMINO, TMINO, JMINO, LMINO, SMINO, ZMINO];
  let minw = Infinity;
  let minh = Infinity;
  let maxw = 1;
  let maxh = 1;

  for (let tetromino of ALL) {
    for (let shape of tetromino) {
      minw = Math.min(shape.w, minw);
      minh = Math.min(shape.h, minh);
      maxw = Math.max(shape.w, maxw);
      maxh = Math.max(shape.h, maxh);
    }
  }
  const MAX_WIDTH = maxw;
  const MAX_HEIGHT = maxh;

  const RESPAWN_PLACEMENT_TICKS = 30;
  const PLACEMENT_BLOCK_IDS = [1, 3, 4, 6, 7, 8, 9, 10, 11, 12];
  function initialize$3() {
    return {
      placing: false,
      floating: true,
      shape: null,
      shapeType: null,
      shapeMap: new ChunkMap(0, 0, MAX_WIDTH, MAX_HEIGHT),
      value: 0,
      placeX: 0,
      placeY: 0,
      placeTicks: 0
    };
  }
  function update(dt, state, placeInput, rotateInput, world, cx, cy, onplace, onreset) {
    const worldMap = world.map; // Block placement

    if (state.placing) {
      const shape = state.shape;
      const nextPlaceX = Math.min(worldMap.bounds.right - shape.w, Math.max(worldMap.bounds.left, cx - Math.floor((shape.w - 1) / 2)));
      const nextPlaceY = Math.min(worldMap.bounds.bottom - shape.h, Math.max(worldMap.bounds.top, cy - Math.floor((shape.h - 1) / 2)));

      if (state.floating) {
        const dx = Math.sign(nextPlaceX - state.placeX);
        const dy = Math.sign(nextPlaceY - state.placeY);

        if (!intersectBlock(shape, state.placeX + dx, state.placeY + dy, worldMap)) {
          state.floating = false;
        }

        state.placeX += dx;
        state.placeY += dy;
        state.valid = false;
      } else {
        const prevPlaceX = state.placeX;

        if (prevPlaceX < nextPlaceX) {
          if (!intersectBlock(shape, prevPlaceX + 1, state.placeY, worldMap)) {
            state.placeX += 1;
          }
        } else if (prevPlaceX > nextPlaceX) {
          if (!intersectBlock(shape, prevPlaceX - 1, state.placeY, worldMap)) {
            state.placeX -= 1;
          }
        }

        const prevPlaceY = state.placeY;

        if (prevPlaceY < nextPlaceY) {
          if (!intersectBlock(shape, state.placeX, prevPlaceY + 1, worldMap)) {
            state.placeY += 1;
          }
        } else if (prevPlaceY > nextPlaceY) {
          if (!intersectBlock(shape, state.placeX, prevPlaceY - 1, worldMap)) {
            state.placeY -= 1;
          }
        }

        state.valid = canPlaceBlockShape(state.value, shape, state.placeX, state.placeY, worldMap);
      }
    } // Try placing and rotating


    if (state.placeTicks <= 0) {
      if (state.placing) {
        if (placeInput.value && state.valid) {
          placeBlockShape(state.value, state.shape, state.placeX, state.placeY, world);
          state.placing = false;
          state.placeTicks = RESPAWN_PLACEMENT_TICKS;
          onplace(state);
        }

        if (rotateInput.value) {
          state.placing = false;
        }
      } else {
        randomizePlacement(state);
        state.placing = true;
        state.floating = true;
        state.valid = false;
        onreset(state);
      }
    } else {
      state.placeTicks -= dt;
    }
  }

  function intersectBlock(blockShape, blockX, blockY, worldMap) {
    const {
      w,
      h,
      m
    } = blockShape;
    let blockPos = worldMap.at(0, 0);

    for (let y = 0; y < h; ++y) {
      for (let x = 0; x < w; ++x) {
        let i = x + y * w;

        if (m[i]) {
          blockPos.set(x + blockX, y + blockY);

          if (!worldMap.isWithinLoaded(blockPos)) {
            continue;
          }

          let blockId = worldMap.getBlockId(blockPos);

          if (BLOCKS.hasComponent(FLUID_COMPONENT, blockId)) {
            if (worldMap.getBlockMeta(blockPos) >= MAX_FLUID_LEVELS) {
              return true;
            }
          } else if (!BLOCKS.hasComponent(AIR_COMPONENT, blockId)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  function canPlaceBlockShape(blockValue, blockShape, blockX, blockY, worldMap) {
    if (BLOCKS.hasComponent(FLUID_COMPONENT, blockValue)) return true;
    let blockPos = worldMap.at(blockX, blockY);
    const {
      w,
      h,
      m
    } = blockShape;

    for (let y = 0; y < h; ++y) {
      for (let x = 0; x < w; ++x) {
        blockPos.set(x + blockX, y + blockY);
        let i = x + y * w;

        if (m[i]) {
          if (!worldMap.isWithinLoaded(blockPos)) {
            continue;
          }

          if (worldMap.getBlockNeighbor(blockPos) !== 0b1111) {
            return true;
          }
        }
      }
    }

    return false;
  }

  function placeBlockShape(blockId, blockShape, blockX, blockY, world) {
    const {
      w,
      h,
      m
    } = blockShape;
    let blockPos = world.map.at(0, 0);

    for (let y = 0; y < h; ++y) {
      for (let x = 0; x < w; ++x) {
        let i = x + y * w;

        if (m[i]) {
          blockPos.set(x + blockX, y + blockY);
          placeBlock(world, blockPos, blockId);
        }
      }
    }
  }

  function setBlockShape(blockId, blockShape, blockX, blockY, shapeMap) {
    const {
      w,
      h,
      m
    } = blockShape;
    let blockPos = shapeMap.at(0, 0);

    for (let y = 0; y < h; ++y) {
      for (let x = 0; x < w; ++x) {
        let i = x + y * w;

        if (m[i]) {
          blockPos.set(x + blockX, y + blockY);
          shapeMap.setBlockId(blockPos, blockId);
        }
      }
    }
  }

  function randomizePlacement(state) {
    const shapeType = Random.choose(ALL);
    const shapeIndex = Math.floor(Random.range(0, shapeType.length));
    const currentBlockId = state.value;
    let flag = false;

    switch (currentBlockId) {
      case 0:
        flag = true;
        break;

      case 1:
        // Water
        flag = Random.next() < 1 / 4;
        break;

      case 3:
        // Dirt
        flag = Random.next() < 1 / 8;
        break;

      case 4:
        // Gold
        flag = Random.next() < 1 / 4;
        break;

      case 6:
        // Stone
        flag = Random.next() < 1 / 8;
        break;

      default:
        flag = Random.next() < 1 / 6;
        break;
    }

    const nextBlockId = flag ? Random.choose(PLACEMENT_BLOCK_IDS) : currentBlockId;
    state.value = nextBlockId;
    state.shapeType = shapeType;
    state.shape = shapeType[shapeIndex];
    state.shapeMap.clear();
    setBlockShape(nextBlockId, state.shape, 0, 0, state.shapeMap);
  }

  function getPlacementSpawnPosition(cursorX, cursorY, blockSize, displayWidth, displayHeight, viewMatrix, projectionMatrix) {
    let resultX = 0;
    let resultY = 0;
    const quadIndex = (cursorX <= 0.5 ? 0 : 2) + (cursorY <= 0.5 ? 0 : 1);

    switch (quadIndex) {
      case 0:
        // TopLeft
        {
          let corner = Camera2D.screenToWorld(0, 0, viewMatrix, projectionMatrix);
          resultX = corner[0];
          resultY = corner[1];
        }
        break;

      case 1:
        // BottomLeft
        {
          let corner = Camera2D.screenToWorld(0, displayHeight, viewMatrix, projectionMatrix);
          resultX = corner[0];
          resultY = corner[1];
        }
        break;

      case 2:
        // TopRight
        {
          let corner = Camera2D.screenToWorld(displayWidth, 0, viewMatrix, projectionMatrix);
          resultX = corner[0];
          resultY = corner[1];
        }
        break;

      case 3:
        // BottomRight
        {
          let corner = Camera2D.screenToWorld(displayWidth, displayHeight, viewMatrix, projectionMatrix);
          resultX = corner[0];
          resultY = corner[1];
        }
        break;
    }

    return [Math.floor(resultX / blockSize), Math.floor(resultY / blockSize)];
  }

  function loadWorld(world, worldData) {
    const chunkWidth = world.map.chunkWidth;
    const chunkHeight = world.map.chunkHeight;
    if (chunkWidth !== worldData.chunkWidth || chunkHeight !== worldData.chunkHeight) return null;
    world.score = worldData.score || 0;
    world.cameraX = worldData.cameraX || 0;
    world.cameraY = worldData.cameraY || 0;
    const length = chunkWidth * chunkHeight;

    for (let chunkId of Object.keys(worldData.chunks)) {
      const chunkData = worldData.chunks[chunkId];
      const [chunkCoordX, chunkCoordY] = toChunkCoords(chunkId);
      let data = new ChunkData(chunkWidth, chunkHeight);

      for (let i = 0; i < length; ++i) {
        data.block[i] = chunkData.block[i];
        data.meta[i] = chunkData.meta[i];
        data.neighbor[i] = chunkData.neighbor[i];
      }

      let chunk = new Chunk(this, chunkId, chunkCoordX, chunkCoordY, data);
      world.map.chunks[chunkId] = chunk;
    }

    return world;
  }
  function saveWorld(world, worldData) {
    const chunkWidth = world.map.chunkWidth;
    const chunkHeight = world.map.chunkHeight;
    worldData.score = world.score;
    worldData.cameraX = world.cameraX;
    worldData.cameraY = world.cameraY;
    worldData.chunkWidth = chunkWidth;
    worldData.chunkHeight = chunkHeight;
    let chunks = {};
    const length = chunkWidth * chunkHeight;

    for (let chunk of world.map.getLoadedChunks()) {
      const chunkId = chunk.chunkId;
      let data = {
        block: new Array(length),
        meta: new Array(length),
        neighbor: new Array(length)
      };

      for (let i = 0; i < length; ++i) {
        data.block[i] = chunk.data.block[i];
        data.meta[i] = chunk.data.meta[i];
        data.neighbor[i] = chunk.data.neighbor[i];
      }

      chunks[chunkId] = data;
    }

    worldData.chunks = chunks;
    return worldData;
  }

  class CanvasView {
    constructor() {
      this.prevTransformMatrix = null;
      this.domProjectionMatrix = new DOMMatrix();
      this.domViewMatrix = new DOMMatrix();
      this.ctx = null;
    }

    begin(ctx, viewMatrix, projectionMatrix) {
      if (this.ctx) {
        throw new Error('View already begun - maybe missing end() call?');
      }

      if (viewMatrix) setDOMMatrix(this.domViewMatrix, viewMatrix);
      if (projectionMatrix) setDOMMatrix(this.domProjectionMatrix, projectionMatrix);
      this.prevTransformMatrix = ctx.getTransform();
      ctx.setTransform(this.domProjectionMatrix);
      const {
        a,
        b,
        c,
        d,
        e,
        f
      } = this.domViewMatrix;
      ctx.transform(a, b, c, d, e, f);
      this.ctx = ctx;
    }

    end(ctx) {
      ctx.setTransform(this.prevTransformMatrix);
      this.ctx = null;
    }

  }
  function setDOMMatrix(domMatrix, glMatrix) {
    domMatrix.a = glMatrix[0];
    domMatrix.b = glMatrix[1];
    domMatrix.c = glMatrix[4];
    domMatrix.d = glMatrix[5];
    domMatrix.e = glMatrix[12];
    domMatrix.f = glMatrix[13];
    return domMatrix;
  }

  const MAX_BLOCK_TICKS = 10;
  const MAX_AUTO_SAVE_TICKS = 100;
  const MAX_FADE_IN_TICKS = 300;
  const BLOCK_SIZE = 4;
  const CAMERA_SPEED = 0.1;

  function renderBlock(ctx, world, blockPos, blockSize) {
    let blockId = world.map.getBlockId(blockPos);
    if (BLOCKS.hasComponent('air', blockId)) return;

    if (BLOCKS.hasComponent('fluid', blockId)) {
      renderBlockFluid(ctx, world, blockPos, blockSize, blockId);
      return;
    }

    if (BLOCKS.hasComponent('solid', blockId)) {
      renderBlockSolid(ctx, world, blockPos, blockSize, blockId);
      return;
    }
  }

  function renderBlockFluid(ctx, world, blockPos, blockSize, blockId) {
    const worldMap = world.map;
    const blockMeta = worldMap.getBlockMeta(blockPos);
    const fluidRatio = blockMeta <= 0 ? 1 : blockMeta / MAX_FLUID_LEVELS;
    const color = BLOCKS.getComponent('color', blockId);
    ctx.fillStyle = color;
    ctx.fillRect(0, (1 - fluidRatio) * blockSize, blockSize, blockSize * fluidRatio);
    let time = Date.now() / 2000;
    let rx = blockPos.x / worldMap.chunkWidth;
    let ry = blockPos.y / worldMap.chunkHeight;
    let osx = blockPos.blockCoordX % 2 === 0;
    let osy = blockPos.blockCoordY % 2 === 0;
    let sfactor = Math.sin(time + rx - ry + (osx ? 0.3 : 0) + (osy ? 0.1 : 0));
    ctx.fillStyle = `rgba(0, 0, 100, ${(sfactor + 1) / 2 * 0.4})`;
    ctx.fillRect(0, (1 - fluidRatio) * blockSize, blockSize, blockSize * fluidRatio);
  }

  function renderBlockSolid(ctx, world, blockPos, blockSize, blockId) {
    const worldMap = world.map;
    const color = BLOCKS.getComponent('color', blockId);
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, blockSize, blockSize);

    if (blockId === GOLD.blockId) {
      let time = Date.now() / 500;
      let rx = blockPos.x / worldMap.chunkWidth;
      let ry = blockPos.y / worldMap.chunkHeight;
      let sfactor = Math.sin(time + rx * 4 + ry * 4);
      ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, sfactor - 0.6)})`;
      ctx.fillRect(0, 0, blockSize, blockSize);
    } else if (blockId === DIRT.blockId) {
      let osx = blockPos.blockCoordX % 2 === 0;
      let osy = blockPos.blockCoordY % 2 === 0;
      ctx.fillStyle = `rgba(0, 0, 0, ${osx && osy ? 0.1 : 0})`;
      ctx.fillRect(0, 0, blockSize, blockSize);
      const blockNeighbor = worldMap.getBlockNeighbor(blockPos);
      const grassSize = Math.ceil(blockSize / 4);

      if (!hasUpNeighbor(blockNeighbor)) {
        let upBlockId = worldMap.getBlockId(blockPos.up());

        if (BLOCKS.hasComponent(AIR_COMPONENT, upBlockId)) {
          ctx.fillStyle = 'limegreen';
          ctx.fillRect(0, 0, blockSize, grassSize);
        }

        blockPos.down();
      }
    } else if (blockId === GRASS.blockId) {
      let osx = blockPos.blockCoordX % 2 === 0;
      ctx.fillStyle = `rgba(0, 0, 0, ${osx ? 0.1 : 0})`;
      ctx.fillRect(0, 0, blockSize, blockSize);
    }
  }

  async function load$1() {}
  function drawChunkMap(ctx, chunkMap, blockSize) {
    const chunkBlockWidth = chunkMap.chunkWidth * blockSize;
    const chunkBlockHeight = chunkMap.chunkHeight * blockSize;

    for (let chunk of chunkMap.getLoadedChunks()) {
      const chunkX = chunk.chunkCoordX * chunkBlockWidth;
      const chunkY = chunk.chunkCoordY * chunkBlockHeight;
      ctx.translate(chunkX, chunkY);
      {
        drawChunk(ctx, chunkMap, chunk, blockSize); // ctx.fillStyle = 'white';
        // ctx.fillText(chunk.chunkId, 0, 16);
        // ctx.strokeStyle = 'white';
        // ctx.strokeRect(0, 0, chunkBlockWidth, chunkBlockHeight);
      }
      ctx.translate(-chunkX, -chunkY);
    }
  }
  function drawPlacement(ctx, placementState, blockSize) {
    drawChunkMap(ctx, placementState.shapeMap, blockSize);
  }
  function drawChunk(ctx, chunkMap, chunk, blockSize) {
    const chunkWidth = chunkMap.chunkWidth;
    const chunkHeight = chunkMap.chunkHeight;
    const chunkOffsetX = chunk.chunkCoordX * chunkWidth;
    const chunkOffsetY = chunk.chunkCoordY * chunkHeight;
    let blockPos = chunkMap.at(chunkOffsetX, chunkOffsetY);

    for (let y = 0; y < chunkHeight; ++y) {
      for (let x = 0; x < chunkWidth; ++x) {
        blockPos.set(x + chunkOffsetX, y + chunkOffsetY);
        ctx.translate(x * blockSize, y * blockSize);
        {
          renderBlock(ctx, {
            map: chunkMap
          }, blockPos, blockSize); // ctx.fillStyle = 'white';
          // ctx.fillText(chunkMap.getBlockNeighbor(blockPos), 0, 0);
        }
        ctx.translate(-x * blockSize, -y * blockSize);
      }
    }
  }

  async function GameRenderer(game) {
    await load$1();
    /** @type {import('@milque/display').DisplayPort} */

    const display = game.display;
    const ctx = display.canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    const view = new CanvasView();
    let world = game.world;
    /** @type {import('./view/Camera2D.js').Camera2D} */

    let camera = game.camera;
    let placement = game.placement;
    return function () {
      let viewMatrix = camera.getViewMatrix();
      let projectionMatrix = camera.getProjectionMatrix();
      ctx.clearRect(0, 0, display.width, display.height);
      view.begin(ctx, viewMatrix, projectionMatrix);
      {
        drawChunkMap(ctx, world.map, BLOCK_SIZE);

        if (placement.placing) {
          ctx.translate(placement.placeX * BLOCK_SIZE, placement.placeY * BLOCK_SIZE);
          {
            drawPlacement(ctx, placement, BLOCK_SIZE);
          }
          ctx.translate(-placement.placeX * BLOCK_SIZE, -placement.placeY * BLOCK_SIZE);
        }
      }
      view.end(ctx);

      if (world.time < MAX_FADE_IN_TICKS) {
        ctx.fillStyle = `rgba(0, 0, 0, ${1 - world.time / MAX_FADE_IN_TICKS})`;
        ctx.fillRect(0, 0, display.width, display.height);
      }

      ctx.fillStyle = 'white';
      ctx.fillText(world.score, 4, 12);
    };
  }

  // TODO: Regionize the block maps.
  // TODO: Multiple fluids?
  // TODO: Sound?
  // TODO: Trees? Plants?
  // TODO: Sunlight? Light map.

  /**
   * @typedef {import('@milque/display').DisplayPort} DisplayPort
   * @typedef {import('@milque/display').FrameEvent} FrameEvent
   * @typedef {import('@milque/input').InputPort} InputPort
   */

  document.addEventListener('DOMContentLoaded', main);

  async function load$2(assets) {
    // Load all assets
    assets.registerAsset('audio', 'flick', 'arroyo/flick.wav');
    assets.registerAsset('audio', 'melt', 'arroyo/melt.mp3');
    assets.registerAsset('audio', 'reset', 'arroyo/flick.wav');
    assets.registerAsset('audio', 'background', 'arroyo/melt.mp3');
    await load(assets);
    await assets.loadAssets();
  }

  async function main() {
    /** @type {DisplayPort} */
    const display = document.querySelector('#display');
    /** @type {InputPort} */

    const input = document.querySelector('#input');
    input.src = {
      PointerX: 'Mouse:PosX',
      PointerY: 'Mouse:PosY',
      Place: 'Mouse:Button0',
      Change: {
        key: 'Mouse:Button2',
        event: 'down'
      },
      Reset: 'Keyboard:KeyR',
      Save: 'Keyboard:KeyS',
      Load: 'Keyboard:KeyL'
    };
    await load$2(ASSETS); // Initialize world

    const world = {
      map: new ChunkMap(),
      score: 0,
      cameraX: 0,
      cameraY: 0,
      time: 0,
      firstPlace: true
    };
    Eventable$1.assign(world); // Initialize systems

    initialize(world);
    initialize$1(world);
    initialize$2(world);
    let worldData = localStorage.getItem('worldData');

    if (!worldData || !loadWorld(world, JSON.parse(worldData))) {
      initializeWorld(world, display);
    }

    let placement = initialize$3();
    const camera = new Camera2D();
    camera.moveTo(world.cameraX, world.cameraY);
    const game = {
      display,
      input,
      world,
      camera,
      placement,
      blockTicks: 0,
      autoSaveTicks: 0
    };
    const renderer = await GameRenderer(game);
    display.addEventListener('frame', e => {
      const frameEvent =
      /** @type {FrameEvent} */
      e;
      const dt = frameEvent.detail.deltaTime / 1000 * 60;
      if (updateWorldControls(game)) return;
      world.time += dt;
      updateCamera(game, dt, camera);
      updatePlacement(game, dt);
      simulateWorld(game, dt);
      updateAutoSave(game, dt);
      renderer();
    });
  }

  function updatePlacement(game, dt) {
    let world = game.world;
    const display = game.display;
    const input = game.input;
    const camera = game.camera;
    const placement = game.placement;
    let viewMatrix = camera.getViewMatrix();
    let projectionMatrix = camera.getProjectionMatrix(); // Cursor worldPos

    const [cursorX, cursorY] = Camera2D.screenToWorld(input.getInputState('PointerX') * display.width, input.getInputState('PointerY') * display.height, viewMatrix, projectionMatrix);
    const nextPlaceX = Math.floor(cursorX / BLOCK_SIZE);
    const nextPlaceY = Math.floor(cursorY / BLOCK_SIZE);

    function onPlace(placeState) {
      // Move towards placement
      const [centerX, centerY] = Camera2D.screenToWorld(display.width / 2, display.height / 2, viewMatrix, projectionMatrix);
      const centerCoordX = Math.floor(centerX / BLOCK_SIZE);
      const centerCoordY = Math.floor(centerY / BLOCK_SIZE);
      let dx = Math.ceil((placeState.placeX - centerCoordX) / 4);
      let dy = Math.ceil((placeState.placeY - centerCoordY) / 4);
      world.cameraX += dx * BLOCK_SIZE;
      world.cameraY += dy * BLOCK_SIZE;
      world.score += 1;
      playPlaceSound(placeState.value);

      if (world.firstPlace) {
        world.firstPlace = false;
        ASSETS.getAsset('audio', 'background').play();
      }
    }

    function onReset(placeState) {
      let [resetPlaceX, resetPlaceY] = getPlacementSpawnPosition(input.getInputState('PointerX'), input.getInputState('PointerY'), BLOCK_SIZE, display.width, display.height, viewMatrix, projectionMatrix);
      placeState.placeX = resetPlaceX;
      placeState.placeY = resetPlaceY;
      ASSETS.getAsset('audio', 'reset').play({
        pitch: Random.range(-5, 5)
      });
    }

    update(dt, placement, input.getInput('Place'), input.getInput('Rotate'), world, nextPlaceX, nextPlaceY, onPlace, onReset);
  }

  function updateWorldControls(game) {
    const world = game.world;
    const display = game.display;
    const input = game.input; // Reset world

    if (input.getInputState('Reset')) {
      localStorage.removeItem('worldData');
      world.map.clear();
      initializeWorld(world, display);
      return true;
    } // Save world
    else if (input.getInputState('Save')) {
        let worldData = saveWorld(world, {});
        Downloader.downloadText('worldData.json', JSON.stringify(worldData));
        return true;
      } // Load world
      else if (input.getInputState('Load')) {
          Uploader.uploadFile(['.json'], false).then(fileBlob => fileBlob.text()).then(textData => {
            let worldData = JSON.parse(textData);
            world.map.clear();

            if (!worldData || !loadWorld(world, worldData)) {
              initializeWorld(world, display);
            }
          });
          return true;
        }

    return false;
  }

  function initializeWorld(world, display) {
    // Initialize new world
    world.score = 0;
    world.time = 0;
    world.firstPlace = true;
    let blockPos = world.map.at(0, 0);
    let out = blockPos.clone();
    placeBlock(world, blockPos, GOLD.blockId);
    placeBlock(world, blockPos.offset(out, -1, 0), GOLD.blockId);
    placeBlock(world, blockPos.offset(out, 0, -1), GOLD.blockId);
    placeBlock(world, blockPos.offset(out, -1, -1), GOLD.blockId);
    world.cameraX = -display.width / 2;
    world.cameraY = -display.height / 2;
  }

  function simulateWorld(game, dt) {
    let blockTicks = game.blockTicks || 0;
    const world = game.world;
    emitUpdateEvent(world);

    if (blockTicks <= 0) {
      blockTicks = MAX_BLOCK_TICKS; // if (Debug.value)

      {
        emitWorldUpdateEvent(world);
        const chunks = world.map.getLoadedChunks();
        const chunkWidth = world.map.chunkWidth;
        const chunkHeight = world.map.chunkHeight;
        let blockPos = world.map.at(0, 0);

        for (let chunk of chunks) {
          const chunkX = chunk.chunkCoordX * chunkWidth;
          const chunkY = chunk.chunkCoordY * chunkHeight;
          emitChunkUpdateEvent(world, chunk);

          for (let y = 0; y < chunkHeight; ++y) {
            for (let x = 0; x < chunkWidth; ++x) {
              blockPos.set(x + chunkX, y + chunkY);
              emitBlockUpdateEvent(world, chunk, blockPos);
            }
          }
        }
      }
    } else {
      blockTicks -= dt;
    } // Update blockTicks


    game.blockTicks = blockTicks;
  }

  function updateAutoSave(game, dt) {
    let autoSaveTicks = game.autoSaveTicks || 0;
    let world = game.world;

    if (autoSaveTicks <= 0) {
      autoSaveTicks = MAX_AUTO_SAVE_TICKS;
      let worldData = saveWorld(world, {});
      localStorage.setItem('worldData', JSON.stringify(worldData));
    } else {
      autoSaveTicks -= dt;
    } // Update autoSaveTicks


    game.autoSaveTicks = autoSaveTicks;
  }

  function updateCamera(game, dt, camera) {
    const display = game.display;
    const input = game.input;
    const world = game.world;
    const CursorX = input.getInput('PointerX');
    const CursorY = input.getInput('PointerY');
    let aspectRatio = display.width / display.height;
    let cw = aspectRatio <= 1 ? aspectRatio : 1;
    let ch = aspectRatio <= 1 ? 1 : 1 / aspectRatio;
    let cx = CursorX.value - 0.5;
    let cy = CursorY.value - 0.5;
    const cameraOffsetAmount = 4;
    let radian = Math.atan2(cy, cx);
    let distance = distance2(0, 0, cx, cy);
    let clampDist = distance < 0.3 ? 0 : distance - 0.3;
    let cameraOffsetX = Math.cos(radian) * clampDist * BLOCK_SIZE * world.map.chunkWidth * cw * cameraOffsetAmount;
    let cameraOffsetY = Math.sin(radian) * clampDist * BLOCK_SIZE * world.map.chunkWidth * ch * cameraOffsetAmount;
    camera.moveTo(lerp(camera.x, world.cameraX + cameraOffsetX, dt * CAMERA_SPEED), lerp(camera.y, world.cameraY + cameraOffsetY, dt * CAMERA_SPEED));
  }

}());
