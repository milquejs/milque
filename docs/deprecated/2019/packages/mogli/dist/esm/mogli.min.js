import{vec3 as t,quat as r,mat4 as e,mat3 as n}from"gl-matrix";const o=t.fromValues(0,0,0),i=t.fromValues(1,0,0),a=t.fromValues(0,1,0),s=t.fromValues(0,0,1);function u(){return{translation:t.create(),rotation:r.create(),scale:t.fromValues(1,1,1)}}function l(t,r=e.create()){return e.fromRotationTranslationScale(r,t.rotation,t.translation,t.scale)}var c=Object.freeze({__proto__:null,ORIGIN:o,XAXIS:i,YAXIS:a,ZAXIS:s,create:u,lookAt:function(e,n=o){const i=t.create();t.subtract(i,n,e.position),t.normalize(i,i);const a=t.dot(s,i);if(Math.abs(a- -1)<Number.EPSILON)return r.set(e.rotation,0,0,1,Math.PI),e;if(Math.abs(dot-1)<Number.EPSILON)return r.set(e.rotation,0,0,0,1),e;t.cross(i,s,i),t.normalize(i,i);const u=Math.acos(a)/2,l=Math.sin(u);return e.rotation[0]=i[0]*l,e.rotation[1]=i[1]*l,e.rotation[2]=i[2]*l,e.rotation[3]=Math.cos(u),e},getTransformationMatrix:l,getForwardVector:function(r,e=t.create()){return t.transformQuat(e,s,r.rotation),e},getUpVector:function(r,e=t.create()){return t.transformQuat(e,a,r.rotation),e},getRightVector:function(r,e=t.create()){return t.transformQuat(e,i,r.rotation),e}});class f{constructor(){this.root=this.createSceneNode(u(),null)}update(){this.root.updateWorldMatrix()}createSceneNode(t=u(),r=this.root){const n={sceneGraph:this,transform:t,localMatrix:e.create(),worldMatrix:e.create(),parent:null,children:[],setParent(t){if(this.parent){const t=this.parent.children.indexOf(this);this.parent.children.splice(t,1)}return t&&t.children.push(this),this.parent=r,this},updateWorldMatrix(t){l(this.transform,this.localMatrix),t?e.multiply(this.worldMatrix,t,this.localMatrix):e.copy(this.worldMatrix,this.localMatrix);for(const t of this.children)t.updateWorldMatrix(this.worldMatrix)}};return r&&n.setParent(r),n}}function h(t,r,e,n,o){if(!o){const r=Math.random(),e=Math.random(),n=Math.random();o=[];for(let i=0;i<t.length;i+=3)o.push(r,e,n)}return{position:t,texcoord:r,normal:e,indices:n,color:o,elementSize:3,elementCount:n.length}}function d(t,r,e,n){for(let o=0;o<n.color.length;o+=3)n.color[o+0]=t,n.color[o+1]=r,n.color[o+2]=e;return n}function m(r,e){const o=e.position,i=e.normal,a=n.create();n.normalFromMat4(a,r);const s=t.create();for(let e=0;e<o.length;e+=3)s[0]=o[e+0],s[1]=o[e+1],s[2]=o[e+2],t.transformMat4(s,s,r),o[e+0]=s[0],o[e+1]=s[1],o[e+2]=s[2],s[0]=i[e+0],s[1]=i[e+1],s[2]=i[e+2],t.transformMat3(s,s,a),i[e+0]=s[0],i[e+1]=s[1],i[e+2]=s[2];return e}function A(...t){const r=[],e=[],n=[],o=[],i=[];let a=0;for(const s of t)r.push(...s.position),e.push(...s.texcoord),n.push(...s.normal),i.push(...s.color),o.push(...s.indices.map(t=>t+a)),a+=s.position.length/3;return h(r,e,n,o,i)}function y(t=!1){let r;if(t){const t=.5,e=.5;r=[0-t,0-e,0,0+t,0-e,0,0-t,0+e,0,0+t,0+e,0]}else r=[0,0,0,1,0,0,0,1,0,1,1,0];return h(r,[0,0,1,0,0,1,1,1],[0,0,1,0,0,1,0,0,1,0,0,1],[0,1,2,2,1,3])}var p=Object.freeze({__proto__:null,create:y});function T(t=!0){const r=y(!0);if(t){const t=y(!0);return m(e.fromYRotation(e.create(),Math.PI),t),d(r.color[0],r.color[1],r.color[2],t),A(r,t)}return r}var _=Object.freeze({__proto__:null,create:T});function b(t=!0,r=!0,n=!0,o=!0,i=!0,a=!0){const s=Math.PI/2,u=e.create(),l=[];if(t){const t=T(!1);e.fromTranslation(u,[0,0,.5]),m(u,t),l.push(t)}if(n){const t=T(!1);e.fromXRotation(u,-s),e.translate(u,u,[0,0,.5]),m(u,t),l.push(t)}if(r){const t=T(!1);e.fromYRotation(u,Math.PI),e.translate(u,u,[0,0,.5]),m(u,t),l.push(t)}if(o){const t=T(!1);e.fromXRotation(u,s),e.translate(u,u,[0,0,.5]),m(u,t),l.push(t)}if(i){const t=T(!1);e.fromYRotation(u,-s),e.translate(u,u,[0,0,.5]),m(u,t),l.push(t)}if(a){const t=T(!1);e.fromYRotation(u,s),e.translate(u,u,[0,0,.5]),m(u,t),l.push(t)}return A(...l)}var E=Object.freeze({__proto__:null,create:b});var g=Object.freeze({__proto__:null,create:function(){const t=e.create(),r=b(!0,!0,!0,!0,!1,!0);e.fromTranslation(t,[.1,.4,0]),e.scale(t,t,[.4,.2,.2]),m(t,r),d(r.color[0],r.color[1],r.color[2],r);const n=b(!0,!0,!0,!0,!1,!0);e.fromScaling(t,[.2,.2,.2]),m(t,n),d(r.color[0],r.color[1],r.color[2],n);const o=b(!0,!0,!0,!0,!0,!0);return e.fromTranslation(t,[-.2,0,0]),e.scale(t,t,[.2,1,.2]),m(t,o),d(r.color[0],r.color[1],r.color[2],o),A(o,r,n)}}),R=Object.freeze({__proto__:null,Quad:p,Plane:_,Cube:E,GlyphF:g,create:h,applyColor:d,applyTransformation:m,joinGeometry:A});function M(t,r,e,n){if(!n){const r=Math.random(),e=Math.random(),o=Math.random();n=[];for(let i=0;i<t.length;i+=3)n.push(r,e,o)}return{position:t,texcoord:r,indices:e,color:n,elementSize:2,elementCount:e.length}}function S(t,r){const e=r.position,n=vec2.create();for(let r=0;r<e.length;r+=2)n[0]=e[r+0],n[1]=e[r+1],vec3.transformMat3(n,n,t),e[r+0]=n[0],e[r+1]=n[1];return r}function z(...t){const r=[],e=[],n=[],o=[];let i=0;for(const a of t){r.push(...a.position),e.push(...a.texcoord),o.push(...a.color);for(let t=0;t<a.indices.length;++t){const r=a.indices[t];n.push(r+i)}i+=a.position.length/2}return M(r,e,n,o)}function F(t=!1){let r;if(t){const t=.5,e=.5;r=[0-t,0-e,0+t,0-e,0-t,0+e,0+t,0+e]}else r=[0,0,1,0,0,1,1,1];return M(r,[0,0,1,0,0,1,1,1],[0,1,2,2,1,3])}var I=Object.freeze({__proto__:null,create:F});var O=Object.freeze({__proto__:null,create:function(){const t=n.create(),r=F();n.fromTranslation(t,[.1,.4]),n.scale(t,t,[.4,.2]),S(t,r),d(r.color[0],r.color[1],r.color[2],r);const e=F();n.fromScaling(t,[.2,.2]),S(t,e),d(r.color[0],r.color[1],r.color[2],e);const o=F();return n.fromTranslation(t,[-.2,0]),n.scale(t,t,[.2,1]),S(t,o),d(r.color[0],r.color[1],r.color[2],o),z(o,r,e)}}),x=Object.freeze({__proto__:null,Quad2D:I,GlyphF2D:O,create:M,applyTransformation2D:S,joinGeometry2D:z,applyColor2D:d});function U(t,r,e,n=[]){const o=B(t,t.VERTEX_SHADER,r),i=B(t,t.FRAGMENT_SHADER,e),a=v(t,o,i,n);return t.detachShader(a,o),t.detachShader(a,i),t.deleteShader(o),t.deleteShader(i),{handle:a,_gl:t,uniforms:w(t,a),attributes:L(t,a),uniform(t,r){return t in this.uniforms&&this.uniforms[t](this._gl,r),this},attribute(t,r){return t in this.attributes&&this.attributes[t](this._gl,r),this},elementAttribute(t){return this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,t),this}}}function B(t,r,e){const n=t.createShader(r);if(t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS)){const r=t.getShaderInfoLog(n);throw t.deleteShader(n),new Error(r)}return n}function v(t,r,e,n=[]){const o=t.createProgram();t.attachShader(o,r),t.attachShader(o,e);for(let r=0;r<n.length;++r)t.bindAttribLocation(o,r,n[r]);if(t.linkProgram(o),!t.getProgramParameter(o,t.LINK_STATUS)){const r=t.getProgramInfoLog(o);throw t.deleteProgram(o),new Error(r)}return o}function L(t,r){const e={},n=t.getProgramParameter(r,t.ACTIVE_ATTRIBUTES);for(let o=0;o<n;++o){const n=t.getActiveAttrib(r,o);if(!n)break;const i=n.name,a=t.getAttribLocation(r,i);e[i]=C(a)}return e}function C(t){const r=function(t,r,e){r.enableVertexAttribArray(t),r.bindBuffer(r.ARRAY_BUFFER,e.handle),r.vertexAttribPointer(t,e.size,e.type,e.normalize,e.stride,e.offset)}.bind(null,t);return r.location=t,r}function w(t,r){const e={},n={textureUnit:0},o=t.getProgramParameter(r,t.ACTIVE_UNIFORMS);for(let i=0;i<o;++i){const o=t.getActiveUniform(r,i);if(!o)break;let a=o.name;"[0]"===a.substring(a.length-3)&&(a=a.substring(0,a.length-3));const s=P(t,r,o,n);e[a]=s}return e}function P(t,r,e,n){const o=e.name,i=t.getUniformLocation(r,o),a=e.type,s=e.size>1&&"[0]"===o.substring(o.length-3),u=V(t,a);if(!u)throw new Error(`Unknown uniform type 0x${a.toString(16)}.`);switch(a){case t.FLOAT:case t.INT:case t.BOOL:return u.setter(i,s);case t.SAMPLER_2D:case t.SAMPLER_CUBE:let r;if(s){r=[];for(let t=0;t<e.size;++t)r.push(n.textureUnit++)}else r=n.textureUnit++;return u.setter(i,s,r);default:return u.setter(i)}}let N=null;function V(t,r){if(N)return N[r];function e(t,r,e=!1,n=0){if(e&&!Array.isArray(n))throw new Error("Cannot create sampler array for non-array texture unit.");const o=(e?function(t,r,e,n,o){n.uniform1fv(t,r),o.forEach((t,o)=>{n.activeTexture(n.TEXTURE0+r[o]),n.bindTexture(e,t)})}:function(t,r,e,n,o){n.uniform1i(t,r),n.activeTexture(n.TEXTURE0+r),n.bindTexture(e,o)}).bind(null,r,n,t);return o.location=r,o}return N={[t.FLOAT]:{TypedArray:Float32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1fv(t,e)}:function(t,r,e){r.uniform1f(t,e)}).bind(null,t);return e.location=t,e}},[t.FLOAT_VEC2]:{TypedArray:Float32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2fv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_VEC3]:{TypedArray:Float32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3fv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_VEC4]:{TypedArray:Float32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4fv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT]:{TypedArray:Int32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1iv(t,e)}:function(t,r,e){r.uniform1i(t,e)}).bind(null,t);return e.location=t,e}},[t.INT_VEC2]:{TypedArray:Int32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2iv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT_VEC3]:{TypedArray:Int32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3iv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT_VEC4]:{TypedArray:Int32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL]:{TypedArray:Uint32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1iv(t,e)}:function(t,r,e){r.uniform1i(t,e)}).bind(null,t);return e.location=t,e}},[t.BOOL_VEC2]:{TypedArray:Uint32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL_VEC3]:{TypedArray:Uint32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL_VEC4]:{TypedArray:Uint32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4iv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT2]:{TypedArray:Float32Array,size:16,setter(t){const r=function(t,r,e){r.uniformMatrix2fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT3]:{TypedArray:Float32Array,size:36,setter(t){const r=function(t,r,e){r.uniformMatrix3fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT4]:{TypedArray:Float32Array,size:64,setter(t){const r=function(t,r,e){r.uniformMatrix4fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.SAMPLER_2D]:{TypedArray:null,size:0,setter:e.bind(null,t.TEXTURE_2D)},[t.SAMPLER_CUBE]:{TypedArray:null,size:0,setter:e.bind(null,t.TEXTURE_CUBE)}},N[r]}function D(t,r,e,n,o=!1,i=0,a=0,s=t.ARRAY_BUFFER,u=t.STATIC_DRAW){const l=t.createBuffer(),c=G(t,r);if(!c)throw new Error(`Unknown uniform type 0x${r.toString(16)}.`);if(e instanceof c.TypedArray)t.bindBuffer(s,l),t.bufferData(s,e,u);else if(Array.isArray(e))e=new c.TypedArray(e),t.bindBuffer(s,l),t.bufferData(s,e,u);else{if("number"!=typeof e)throw new Error("Unknown buffer data type - can only be a TypedArray, an Array, or a number.");t.bindBuffer(s,l),t.bufferData(s,e,u)}return{handle:l,size:n,type:r,normalize:o,stride:i,offset:a,updateData(t,e,n=0,o=t.STATIC_DRAW){t.bindBuffer(t.ARRAY_BUFFER,this.handle);const i=G(t,r);e instanceof i.TypedArray||(e=new i.TypedArray(e)),n>0?t.bufferSubData(t.ARRAY_BUFFER,n,e):t.bufferData(t.ARRAY_BUFFER,e,o)}}}function Y(t,r,e,n=0,o=0,i=t.STATIC_DRAW){return D(t,r,e,1,!1,n,o,t.ELEMENT_ARRAY_BUFFER,i)}let j=null;function G(t,r){return j?j[r]:(j={[t.BYTE]:{TypedArray:Int8Array,size:1},[t.SHORT]:{TypedArray:Int16Array,size:2},[t.UNSIGNED_BYTE]:{TypedArray:Uint8Array,size:1},[t.UNSIGNED_SHORT]:{TypedArray:Uint16Array,size:2},[t.FLOAT]:{TypedArray:Float32Array,size:4}},j[r])}function X(t,r=[]){const e=t.createVertexArray(),n={};for(let t=0;t<r.length;++t)n[r[t]]={location:t,setter:C(t)};return{handle:e,attributes:n,_gl:t,elementBuffer:null,elementType:null,elementCount:0,attributeBuffers:{},setElementCount(t){return this.elementCount=t,this},elementAttribute(t){this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,t.handle);const r=G(this._gl,t.type);return this.elementCount=this._gl.getBufferParameter(this._gl.ELEMENT_ARRAY_BUFFER,this._gl.BUFFER_SIZE)/r.size,this.elementBuffer=t,this.elementType=t.type,this},sharedAttribute(t,r){return t in this.attributes&&this.attributes[t].setter(this._gl,r),this.attributeBuffers[t]=r,this},programAttribute(t,r,...e){for(const n of e)n.attribute(t,r);return this.attributeBuffers[t]=r,this}}}function k(t){return{handle:t.createTexture()}}function W(t,r,e,n=0,o=null){return{programInfo:t,vertexArrayInfo:r,uniforms:e,drawArrayOffset:n,drawMode:o}}function Q(t,r,e={}){for(const n of r){const r=n.programInfo,o=n.vertexArrayInfo,i=n.uniforms,a=n.drawArrayOffset,s=n.drawMode||t.TRIANGLES;t.useProgram(r.handle),t.bindVertexArray(o.handle);for(const[t,n]of Object.entries(e))r.uniform(t,n);for(const[t,e]of Object.entries(i))r.uniform(t,e);o.elementBuffer?t.drawElements(s,o.elementCount,o.elementType,a*o.elementBuffer.size):t.drawArrays(s,a,o.elementCount)}}export{R as Geometry,x as Geometry2D,f as SceneGraph,c as Transform,D as createBufferInfo,W as createDrawInfo,Y as createElementBufferInfo,B as createShader,v as createShaderProgram,C as createShaderProgramAttributeSetter,L as createShaderProgramAttributeSetters,U as createShaderProgramInfo,P as createShaderProgramUniformSetter,w as createShaderProgramUniformSetters,k as createTextureInfo,X as createVertexArrayInfo,Q as draw,G as getBufferTypeInfo,V as getUniformTypeInfo};
