!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("gl-matrix")):"function"==typeof define&&define.amd?define(["exports","gl-matrix"],r):r((t=t||self).Mogli={},t.glMatrix)}(this,(function(t,r){"use strict";const e=r.vec3.fromValues(0,0,0),n=r.vec3.fromValues(1,0,0),o=r.vec3.fromValues(0,1,0),a=r.vec3.fromValues(0,0,1);function i(){return{translation:r.vec3.create(),rotation:r.quat.create(),scale:r.vec3.fromValues(1,1,1)}}function c(t,e=r.mat4.create()){return r.mat4.fromRotationTranslationScale(e,t.rotation,t.translation,t.scale)}var s=Object.freeze({__proto__:null,ORIGIN:e,XAXIS:n,YAXIS:o,ZAXIS:a,create:i,lookAt:function(t,n=e){const o=r.vec3.create();r.vec3.subtract(o,n,t.position),r.vec3.normalize(o,o);const i=r.vec3.dot(a,o);if(Math.abs(i- -1)<Number.EPSILON)return r.quat.set(t.rotation,0,0,1,Math.PI),t;if(Math.abs(dot-1)<Number.EPSILON)return r.quat.set(t.rotation,0,0,0,1),t;r.vec3.cross(o,a,o),r.vec3.normalize(o,o);const c=Math.acos(i)/2,s=Math.sin(c);return t.rotation[0]=o[0]*s,t.rotation[1]=o[1]*s,t.rotation[2]=o[2]*s,t.rotation[3]=Math.cos(c),t},getTransformationMatrix:c,getForwardVector:function(t,e=r.vec3.create()){return r.vec3.transformQuat(e,a,t.rotation),e},getUpVector:function(t,e=r.vec3.create()){return r.vec3.transformQuat(e,o,t.rotation),e},getRightVector:function(t,e=r.vec3.create()){return r.vec3.transformQuat(e,n,t.rotation),e}});function u(t,r,e,n,o){if(!o){const r=Math.random(),e=Math.random(),n=Math.random();o=[];for(let a=0;a<t.length;a+=3)o.push(r,e,n)}return{position:t,texcoord:r,normal:e,indices:n,color:o,elementSize:3,elementCount:n.length}}function l(t,r,e,n){for(let o=0;o<n.color.length;o+=3)n.color[o+0]=t,n.color[o+1]=r,n.color[o+2]=e;return n}function f(t,e){const n=e.position,o=e.normal,a=r.mat3.create();r.mat3.normalFromMat4(a,t);const i=r.vec3.create();for(let e=0;e<n.length;e+=3)i[0]=n[e+0],i[1]=n[e+1],i[2]=n[e+2],r.vec3.transformMat4(i,i,t),n[e+0]=i[0],n[e+1]=i[1],n[e+2]=i[2],i[0]=o[e+0],i[1]=o[e+1],i[2]=o[e+2],r.vec3.transformMat3(i,i,a),o[e+0]=i[0],o[e+1]=i[1],o[e+2]=i[2];return e}function m(...t){const r=[],e=[],n=[],o=[],a=[];let i=0;for(const c of t)r.push(...c.position),e.push(...c.texcoord),n.push(...c.normal),a.push(...c.color),o.push(...c.indices.map(t=>t+i)),i+=c.position.length/3;return u(r,e,n,o,a)}function d(t=!1){let r;if(t){const t=.5,e=.5;r=[0-t,0-e,0,0+t,0-e,0,0-t,0+e,0,0+t,0+e,0]}else r=[0,0,0,1,0,0,0,1,0,1,1,0];return u(r,[0,0,1,0,0,1,1,1],[0,0,1,0,0,1,0,0,1,0,0,1],[0,1,2,2,1,3])}var h=Object.freeze({__proto__:null,create:d});function A(t=!0){const e=d(!0);if(t){const t=d(!0);return f(r.mat4.fromYRotation(r.mat4.create(),Math.PI),t),l(e.color[0],e.color[1],e.color[2],t),m(e,t)}return e}var y=Object.freeze({__proto__:null,create:A});function p(t=!0,e=!0,n=!0,o=!0,a=!0,i=!0){const c=Math.PI/2,s=r.mat4.create(),u=[];if(t){const t=A(!1);r.mat4.fromTranslation(s,[0,0,.5]),f(s,t),u.push(t)}if(n){const t=A(!1);r.mat4.fromXRotation(s,-c),r.mat4.translate(s,s,[0,0,.5]),f(s,t),u.push(t)}if(e){const t=A(!1);r.mat4.fromYRotation(s,Math.PI),r.mat4.translate(s,s,[0,0,.5]),f(s,t),u.push(t)}if(o){const t=A(!1);r.mat4.fromXRotation(s,c),r.mat4.translate(s,s,[0,0,.5]),f(s,t),u.push(t)}if(a){const t=A(!1);r.mat4.fromYRotation(s,-c),r.mat4.translate(s,s,[0,0,.5]),f(s,t),u.push(t)}if(i){const t=A(!1);r.mat4.fromYRotation(s,c),r.mat4.translate(s,s,[0,0,.5]),f(s,t),u.push(t)}return m(...u)}var T=Object.freeze({__proto__:null,create:p});var _=Object.freeze({__proto__:null,create:function(){const t=r.mat4.create(),e=p(!0,!0,!0,!0,!1,!0);r.mat4.fromTranslation(t,[.1,.4,0]),r.mat4.scale(t,t,[.4,.2,.2]),f(t,e),l(e.color[0],e.color[1],e.color[2],e);const n=p(!0,!0,!0,!0,!1,!0);r.mat4.fromScaling(t,[.2,.2,.2]),f(t,n),l(e.color[0],e.color[1],e.color[2],n);const o=p(!0,!0,!0,!0,!0,!0);return r.mat4.fromTranslation(t,[-.2,0,0]),r.mat4.scale(t,t,[.2,1,.2]),f(t,o),l(e.color[0],e.color[1],e.color[2],o),m(o,e,n)}}),b=Object.freeze({__proto__:null,Quad:h,Plane:y,Cube:T,GlyphF:_,create:u,applyColor:l,applyTransformation:f,joinGeometry:m});function g(t,r,e,n){if(!n){const r=Math.random(),e=Math.random(),o=Math.random();n=[];for(let a=0;a<t.length;a+=3)n.push(r,e,o)}return{position:t,texcoord:r,indices:e,color:n,elementSize:2,elementCount:e.length}}function E(t,r){const e=r.position,n=vec2.create();for(let r=0;r<e.length;r+=2)n[0]=e[r+0],n[1]=e[r+1],vec3.transformMat3(n,n,t),e[r+0]=n[0],e[r+1]=n[1];return r}function S(...t){const r=[],e=[],n=[],o=[];let a=0;for(const i of t){r.push(...i.position),e.push(...i.texcoord),o.push(...i.color);for(let t=0;t<i.indices.length;++t){const r=i.indices[t];n.push(r+a)}a+=i.position.length/2}return g(r,e,n,o)}function R(t=!1){let r;if(t){const t=.5,e=.5;r=[0-t,0-e,0+t,0-e,0-t,0+e,0+t,0+e]}else r=[0,0,1,0,0,1,1,1];return g(r,[0,0,1,0,0,1,1,1],[0,1,2,2,1,3])}var v=Object.freeze({__proto__:null,create:R});var M=Object.freeze({__proto__:null,create:function(){const t=r.mat3.create(),e=R();r.mat3.fromTranslation(t,[.1,.4]),r.mat3.scale(t,t,[.4,.2]),E(t,e),l(e.color[0],e.color[1],e.color[2],e);const n=R();r.mat3.fromScaling(t,[.2,.2]),E(t,n),l(e.color[0],e.color[1],e.color[2],n);const o=R();return r.mat3.fromTranslation(t,[-.2,0]),r.mat3.scale(t,t,[.2,1]),E(t,o),l(e.color[0],e.color[1],e.color[2],o),S(o,e,n)}}),I=Object.freeze({__proto__:null,Quad2D:v,GlyphF2D:M,create:g,applyTransformation2D:E,joinGeometry2D:S,applyColor2D:l});function x(t,r,e){const n=t.createShader(r);if(t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS)){const r=t.getShaderInfoLog(n);throw t.deleteShader(n),new Error(r)}return n}function z(t,r,e,n=[]){const o=t.createProgram();t.attachShader(o,r),t.attachShader(o,e);for(let r=0;r<n.length;++r)t.bindAttribLocation(o,r,n[r]);if(t.linkProgram(o),!t.getProgramParameter(o,t.LINK_STATUS)){const r=t.getProgramInfoLog(o);throw t.deleteProgram(o),new Error(r)}return o}function F(t,r){const e={},n=t.getProgramParameter(r,t.ACTIVE_ATTRIBUTES);for(let o=0;o<n;++o){const n=t.getActiveAttrib(r,o);if(!n)break;const a=n.name,i=t.getAttribLocation(r,a);e[a]=O(i)}return e}function O(t){const r=function(t,r,e){r.enableVertexAttribArray(t),r.bindBuffer(r.ARRAY_BUFFER,e.handle),r.vertexAttribPointer(t,e.size,e.type,e.normalize,e.stride,e.offset)}.bind(null,t);return r.location=t,r}function U(t,r){const e={},n={textureUnit:0},o=t.getProgramParameter(r,t.ACTIVE_UNIFORMS);for(let a=0;a<o;++a){const o=t.getActiveUniform(r,a);if(!o)break;let i=o.name;"[0]"===i.substring(i.length-3)&&(i=i.substring(0,i.length-3));const c=B(t,r,o,n);e[i]=c}return e}function B(t,r,e,n){const o=e.name,a=t.getUniformLocation(r,o),i=e.type,c=e.size>1&&"[0]"===o.substring(o.length-3),s=L(t,i);if(!s)throw new Error(`Unknown uniform type 0x${i.toString(16)}.`);switch(i){case t.FLOAT:case t.INT:case t.BOOL:return s.setter(a,c);case t.SAMPLER_2D:case t.SAMPLER_CUBE:let r;if(c){r=[];for(let t=0;t<e.size;++t)r.push(n.textureUnit++)}else r=n.textureUnit++;return s.setter(a,c,r);default:return s.setter(a)}}let P=null;function L(t,r){if(P)return P[r];function e(t,r,e=!1,n=0){if(e&&!Array.isArray(n))throw new Error("Cannot create sampler array for non-array texture unit.");const o=(e?function(t,r,e,n,o){n.uniform1fv(t,r),o.forEach((t,o)=>{n.activeTexture(n.TEXTURE0+r[o]),n.bindTexture(e,t)})}:function(t,r,e,n,o){n.uniform1i(t,r),n.activeTexture(n.TEXTURE0+r),n.bindTexture(e,o)}).bind(null,r,n,t);return o.location=r,o}return P={[t.FLOAT]:{TypedArray:Float32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1fv(t,e)}:function(t,r,e){r.uniform1f(t,e)}).bind(null,t);return e.location=t,e}},[t.FLOAT_VEC2]:{TypedArray:Float32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2fv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_VEC3]:{TypedArray:Float32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3fv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_VEC4]:{TypedArray:Float32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4fv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT]:{TypedArray:Int32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1iv(t,e)}:function(t,r,e){r.uniform1i(t,e)}).bind(null,t);return e.location=t,e}},[t.INT_VEC2]:{TypedArray:Int32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2iv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT_VEC3]:{TypedArray:Int32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3iv(t,e)}.bind(null,t);return r.location=t,r}},[t.INT_VEC4]:{TypedArray:Int32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL]:{TypedArray:Uint32Array,size:4,setter(t,r=!1){const e=(r?function(t,r,e){r.uniform1iv(t,e)}:function(t,r,e){r.uniform1i(t,e)}).bind(null,t);return e.location=t,e}},[t.BOOL_VEC2]:{TypedArray:Uint32Array,size:8,setter(t){const r=function(t,r,e){r.uniform2iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL_VEC3]:{TypedArray:Uint32Array,size:12,setter(t){const r=function(t,r,e){r.uniform3iv(t,e)}.bind(null,t);return r.location=t,r}},[t.BOOL_VEC4]:{TypedArray:Uint32Array,size:16,setter(t){const r=function(t,r,e){r.uniform4iv(t,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT2]:{TypedArray:Float32Array,size:16,setter(t){const r=function(t,r,e){r.uniformMatrix2fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT3]:{TypedArray:Float32Array,size:36,setter(t){const r=function(t,r,e){r.uniformMatrix3fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.FLOAT_MAT4]:{TypedArray:Float32Array,size:64,setter(t){const r=function(t,r,e){r.uniformMatrix4fv(t,!1,e)}.bind(null,t);return r.location=t,r}},[t.SAMPLER_2D]:{TypedArray:null,size:0,setter:e.bind(null,t.TEXTURE_2D)},[t.SAMPLER_CUBE]:{TypedArray:null,size:0,setter:e.bind(null,t.TEXTURE_CUBE)}},P[r]}function w(t,r,e,n,o=!1,a=0,i=0,c=t.ARRAY_BUFFER,s=t.STATIC_DRAW){const u=t.createBuffer(),l=N(t,r);if(!l)throw new Error(`Unknown uniform type 0x${r.toString(16)}.`);if(e instanceof l.TypedArray)t.bindBuffer(c,u),t.bufferData(c,e,s);else if(Array.isArray(e))e=new l.TypedArray(e),t.bindBuffer(c,u),t.bufferData(c,e,s);else{if("number"!=typeof e)throw new Error("Unknown buffer data type - can only be a TypedArray, an Array, or a number.");t.bindBuffer(c,u),t.bufferData(c,e,s)}return{handle:u,size:n,type:r,normalize:o,stride:a,offset:i,updateData(t,e,n=0,o=t.STATIC_DRAW){t.bindBuffer(t.ARRAY_BUFFER,this.handle);const a=N(t,r);e instanceof a.TypedArray||(e=new a.TypedArray(e)),n>0?t.bufferSubData(t.ARRAY_BUFFER,n,e):t.bufferData(t.ARRAY_BUFFER,e,o)}}}let C=null;function N(t,r){return C?C[r]:(C={[t.BYTE]:{TypedArray:Int8Array,size:1},[t.SHORT]:{TypedArray:Int16Array,size:2},[t.UNSIGNED_BYTE]:{TypedArray:Uint8Array,size:1},[t.UNSIGNED_SHORT]:{TypedArray:Uint16Array,size:2},[t.FLOAT]:{TypedArray:Float32Array,size:4}},C[r])}t.Geometry=b,t.Geometry2D=I,t.SceneGraph=class{constructor(){this.root=this.createSceneNode(i(),null)}update(){this.root.updateWorldMatrix()}createSceneNode(t=i(),e=this.root){const n={sceneGraph:this,transform:t,localMatrix:r.mat4.create(),worldMatrix:r.mat4.create(),parent:null,children:[],setParent(t){if(this.parent){const t=this.parent.children.indexOf(this);this.parent.children.splice(t,1)}return t&&t.children.push(this),this.parent=e,this},updateWorldMatrix(t){c(this.transform,this.localMatrix),t?r.mat4.multiply(this.worldMatrix,t,this.localMatrix):r.mat4.copy(this.worldMatrix,this.localMatrix);for(const t of this.children)t.updateWorldMatrix(this.worldMatrix)}};return e&&n.setParent(e),n}},t.Transform=s,t.createBufferInfo=w,t.createDrawInfo=function(t,r,e,n=0,o=null){return{programInfo:t,vertexArrayInfo:r,uniforms:e,drawArrayOffset:n,drawMode:o}},t.createElementBufferInfo=function(t,r,e,n=0,o=0,a=t.STATIC_DRAW){return w(t,r,e,1,!1,n,o,t.ELEMENT_ARRAY_BUFFER,a)},t.createShader=x,t.createShaderProgram=z,t.createShaderProgramAttributeSetter=O,t.createShaderProgramAttributeSetters=F,t.createShaderProgramInfo=function(t,r,e,n=[]){const o=x(t,t.VERTEX_SHADER,r),a=x(t,t.FRAGMENT_SHADER,e),i=z(t,o,a,n);return t.detachShader(i,o),t.detachShader(i,a),t.deleteShader(o),t.deleteShader(a),{handle:i,_gl:t,uniforms:U(t,i),attributes:F(t,i),uniform(t,r){return t in this.uniforms&&this.uniforms[t](this._gl,r),this},attribute(t,r){return t in this.attributes&&this.attributes[t](this._gl,r),this},elementAttribute(t){return this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,t),this}}},t.createShaderProgramUniformSetter=B,t.createShaderProgramUniformSetters=U,t.createTextureInfo=function(t){return{handle:t.createTexture()}},t.createVertexArrayInfo=function(t,r=[]){const e=t.createVertexArray(),n={};for(let t=0;t<r.length;++t)n[r[t]]={location:t,setter:O(t)};return{handle:e,attributes:n,_gl:t,elementBuffer:null,elementType:null,elementCount:0,attributeBuffers:{},setElementCount(t){return this.elementCount=t,this},elementAttribute(t){this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER,t.handle);const r=N(this._gl,t.type);return this.elementCount=this._gl.getBufferParameter(this._gl.ELEMENT_ARRAY_BUFFER,this._gl.BUFFER_SIZE)/r.size,this.elementBuffer=t,this.elementType=t.type,this},sharedAttribute(t,r){return t in this.attributes&&this.attributes[t].setter(this._gl,r),this.attributeBuffers[t]=r,this},programAttribute(t,r,...e){for(const n of e)n.attribute(t,r);return this.attributeBuffers[t]=r,this}}},t.draw=function(t,r,e={}){for(const n of r){const r=n.programInfo,o=n.vertexArrayInfo,a=n.uniforms,i=n.drawArrayOffset,c=n.drawMode||t.TRIANGLES;t.useProgram(r.handle),t.bindVertexArray(o.handle);for(const[t,n]of Object.entries(e))r.uniform(t,n);for(const[t,e]of Object.entries(a))r.uniform(t,e);o.elementBuffer?t.drawElements(c,o.elementCount,o.elementType,i*o.elementBuffer.size):t.drawArrays(c,i,o.elementCount)}},t.getBufferTypeInfo=N,t.getUniformTypeInfo=L,Object.defineProperty(t,"__esModule",{value:!0})}));
