
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
  'use strict';

  var INNER_HTML = "<div class=\"container\">\n    <label class=\"hidden\" id=\"title\">display-port</label>\n    <label class=\"hidden\" id=\"fps\">00</label>\n    <label class=\"hidden\" id=\"dimension\">0x0</label>\n    <div class=\"content\">\n        <canvas></canvas>\n        <slot id=\"inner\"></slot>\n    </div>\n    <slot name=\"frame\"></slot>\n</div>";
  var INNER_STYLE = ":host{display:inline-block;color:#555}.container{display:flex;position:relative;width:100%;height:100%}.content{position:relative;margin:auto}.content>*{width:100%;height:100%}canvas{background:#000;-ms-interpolation-mode:nearest-neighbor;image-rendering:-moz-crisp-edges;image-rendering:pixelated}label{font-family:monospace;color:currentColor}#inner,label{position:absolute}#inner{display:flex;flex-direction:column;align-items:center;justify-content:center;top:0;left:0;pointer-events:none}#title{left:.5rem;top:.5rem}#fps{right:.5rem;top:.5rem}#dimension{left:.5rem;bottom:.5rem}.hidden{display:none}:host([debug]) .container{outline:6px dashed rgba(0,0,0,.1);outline-offset:-4px;background-color:rgba(0,0,0,.1)}:host([mode=noscale]) canvas{margin:0;top:0;left:0}:host([mode=center]),:host([mode=fit]),:host([mode=stretch]){width:100%;height:100%}:host([full]){width:100vw!important;height:100vh!important}:host([disabled]){display:none}slot{display:flex;flex-direction:column;align-items:center;justify-content:center;position:absolute;width:100%;height:100%;top:0;left:0;pointer-events:none}::slotted(*){pointer-events:auto}";
  /**
   * No scaling is applied. The canvas size maintains a 1:1 pixel ratio to the defined
   * display dimensions.
   */

  const MODE_NOSCALE = 'noscale';
  /**
   * Scales the canvas to fill the entire viewport and maintains the same aspect ratio
   * with respect to the defined display dimensions. In effect, this will upscale and
   * downscale the pixel size depending on the viewport resolution and aspect ratio. This
   * is the default scaling mode.
   */

  const MODE_FIT = 'fit';
  /**
   * Scales the canvas to fill the entire viewport. This does not maintain the aspect
   * ratio. If you care about aspect ratio, consider using 'fit' mode instead.
   */

  const MODE_STRETCH = 'stretch'; // The default display dimensions. This is the same as the canvas element default.

  const DEFAULT_WIDTH = 300;
  const DEFAULT_HEIGHT = 150; // The default display scaling mode.

  const DEFAULT_MODE = MODE_FIT;
  /**
   * @typedef {CustomEvent} FrameEvent
   * @property {number} detail.now The current time in milliseconds.
   * @property {number} detail.prevTime The previous frame time in milliseconds.
   * @property {number} detail.deltaTime The time taken between the current and previous frame in milliseconds.
   * @property {HTMLCanvasElement} detail.canvas The canvas element.
   */

  /**
   * A canvas that can scale and stretch with respect to the aspect ratio to fill
   * the viewport size.
   * 
   * To start drawing, you should get the canvas context like so:
   * 
   * For Canvas2D:
   * ```
   * const display = document.querySelector('display-port');
   * const ctx = display.canvas.getContext('2d');
   * ctx.drawText(0, 0, 'Hello World!');
   * ```
   * 
   * For WebGL:
   * ```
   * const display = document.querySelector('display-port');
   * const gl = display.canvas.getContext('webgl');
   * gl.clear(gl.COLOR_BUFFER_BIT);
   * ```
   * 
   * Usually, you would want to set the `width` and `height` attributes to define
   * the canvas size and aspect ratio in pixels. You can also change the scaling
   * behavior by setting the `mode` attribute.
   * 
   * And for convenience, this element also dispatches a `frame` event every animation
   * frame (60 fps). This is basically the same as calling `requestAnimationFrame()`.
   * 
   * NOTE: The viewport size is usually the parent container size. However, in the
   * rare case the element must be nested in a child container, you can define the
   * boolean attribute `full` to force the dimensions to be the actual window size.
   */

  class DisplayPort extends HTMLElement {
    /** Generated by cuttle.js */
    static get [Symbol.for("cuttleTemplate")]() {
      let t = document.createElement("template");
      t.innerHTML = INNER_HTML;
      Object.defineProperty(this, Symbol.for("cuttleTemplate"), {
        value: t
      });
      return t;
    }
    /** Generated by cuttle.js */


    static get [Symbol.for("cuttleStyle")]() {
      let s = document.createElement("style");
      s.innerHTML = INNER_STYLE;
      Object.defineProperty(this, Symbol.for("cuttleStyle"), {
        value: s
      });
      return s;
    }
    /** @override */


    static get observedAttributes() {
      return ["onframe", "width", "height", "disabled", "debug", 'id', 'class'];
    }

    static get properties() {
      return {
        /** The canvas width in pixels. This determines the aspect ratio and canvas buffer size. */
        width: Number,

        /** The canvas height in pixels. This determines the aspect ratio and canvas buffer size. */
        height: Number,

        /** If disabled, animation frames will not fire. */
        disabled: Boolean,

        /** Enable for debug information. */
        debug: Boolean,

        /**
         * The scaling mode.
         * - `noscale`: Does not perform scaling. This is effectively the same as a regular
         * canvas.
         * - `center`: Does not perform pixel scaling but stretches the display to fill the
         * entire viewport. The unscaled canvas is centered.
         * - `fit`: Performs scaling to fill the entire viewport and maintains the aspect
         * ratio. This is the default behavior.
         * - `stretch`: Performs scaling to fill the entire viewport but does not maintain
         * aspect ratio.
         */
        mode: {
          type: String,
          value: DEFAULT_MODE,
          observed: false
        }
      };
    }
    /**
                 * The scaling mode.
                 * - `noscale`: Does not perform scaling. This is effectively the same as a regular
                 * canvas.
                 * - `center`: Does not perform pixel scaling but stretches the display to fill the
                 * entire viewport. The unscaled canvas is centered.
                 * - `fit`: Performs scaling to fill the entire viewport and maintains the aspect
                 * ratio. This is the default behavior.
                 * - `stretch`: Performs scaling to fill the entire viewport but does not maintain
                 * aspect ratio.
                 */


    get mode() {
      return this.getAttribute("mode");
    }

    set mode(value) {
      this.setAttribute("mode", value);
    }
    /** Enable for debug information. */


    get debug() {
      return this._debug;
    }

    set debug(value) {
      this.toggleAttribute("debug", value);
    }
    /** If disabled, animation frames will not fire. */


    get disabled() {
      return this._disabled;
    }

    set disabled(value) {
      this.toggleAttribute("disabled", value);
    }
    /** The canvas height in pixels. This determines the aspect ratio and canvas buffer size. */


    get height() {
      return this._height;
    }

    set height(value) {
      this.setAttribute("height", String(value));
    }
    /** The canvas width in pixels. This determines the aspect ratio and canvas buffer size. */


    get width() {
      return this._width;
    }

    set width(value) {
      this.setAttribute("width", String(value));
    }

    static get customEvents() {
      return [
      /** Fired every animation frame. */
      'frame'];
    }
    /** Fired every animation frame. */


    get onframe() {
      return this._onframe;
    }

    set onframe(value) {
      if (this._onframe) this.removeEventListener("frame", this._onframe);
      this._onframe = value;
      if (this._onframe) this.addEventListener("frame", value);
    }

    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleTemplate")].content.cloneNode(true));
      this.shadowRoot.appendChild(this.constructor[Symbol.for("cuttleStyle")].cloneNode(true));
      /** @private */

      this._canvasElement = this.shadowRoot.querySelector('canvas');
      /** @private */

      this._contentElement = this.shadowRoot.querySelector('.content');
      /** @private */

      this._innerElement = this.shadowRoot.querySelector('#inner');
      /** @private */

      this._titleElement = this.shadowRoot.querySelector('#title');
      /** @private */

      this._fpsElement = this.shadowRoot.querySelector('#fps');
      /** @private */

      this._dimensionElement = this.shadowRoot.querySelector('#dimension');
      /** @private */

      this._animationRequestHandle = 0;
      /** @private */

      this._prevAnimationFrameTime = 0;
      /** @private */

      this._width = DEFAULT_WIDTH;
      /** @private */

      this._height = DEFAULT_HEIGHT;
      /** @private */

      this.update = this.update.bind(this);
    }
    /** Get the canvas element. */


    get canvas() {
      return this._canvasElement;
    }
    /** @override */


    connectedCallback() {
      if (Object.prototype.hasOwnProperty.call(this, "onframe")) {
        let value = this.onframe;
        delete this.onframe;
        this.onframe = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "width")) {
        let value = this.width;
        delete this.width;
        this.width = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "height")) {
        let value = this.height;
        delete this.height;
        this.height = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "disabled")) {
        let value = this.disabled;
        delete this.disabled;
        this.disabled = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "debug")) {
        let value = this.debug;
        delete this.debug;
        this.debug = value;
      }

      if (Object.prototype.hasOwnProperty.call(this, "mode")) {
        let value = this.mode;
        delete this.mode;
        this.mode = value;
      }

      if (!this.hasAttribute("mode")) {
        this.setAttribute("mode", DEFAULT_MODE);
      } // Allows this element to be focusable


      if (!this.hasAttribute('tabindex')) this.setAttribute('tabindex', 0);
      this.updateCanvasSize();
      this.resume();
    }
    /** @override */


    disconnectedCallback() {
      this.pause();
    }
    /** @override */


    attributeChangedCallback(attribute, prev, value) {
      /** Generated by cuttle.js */
      switch (attribute) {
        case "width":
          {
            this._width = Number(value);
          }
          break;

        case "height":
          {
            this._height = Number(value);
          }
          break;

        case "disabled":
          {
            this._disabled = value !== null;
          }
          break;

        case "debug":
          {
            this._debug = value !== null;
          }
          break;

        case "onframe":
          {
            this.onframe = new Function('event', 'with(document){with(this){' + value + '}}').bind(this);
          }
          break;
      }

      ((attribute, prev, value) => {
        switch (attribute) {
          case 'disabled':
            if (value) {
              this.update(0);
              this.pause();
            } else {
              this.resume();
            }

            break;
          // NOTE: For debugging purposes...

          case 'id':
          case 'class':
            this._titleElement.innerHTML = `display-port${this.className ? '.' + this.className : ''}${this.hasAttribute('id') ? '#' + this.getAttribute('id') : ''}`;
            break;

          case 'debug':
            this._titleElement.classList.toggle('hidden', value);

            this._fpsElement.classList.toggle('hidden', value);

            this._dimensionElement.classList.toggle('hidden', value);

            break;
        }
      })(attribute, prev, value);
    }
    /** Pause animation of the display frames. */


    pause() {
      cancelAnimationFrame(this._animationRequestHandle);
    }
    /** Resume animation of the display frames. */


    resume() {
      this._animationRequestHandle = requestAnimationFrame(this.update);
    }
    /** @private */


    update(now) {
      this._animationRequestHandle = requestAnimationFrame(this.update);
      this.updateCanvasSize();
      const deltaTime = now - this._prevAnimationFrameTime;
      this._prevAnimationFrameTime = now; // NOTE: For debugging purposes...

      if (this.debug) {
        // Update FPS...
        const frames = deltaTime <= 0 ? '--' : String(Math.round(1000 / deltaTime)).padStart(2, '0');

        if (this._fpsElement.innerText !== frames) {
          this._fpsElement.innerText = frames;
        } // Update dimensions...


        if (this.mode === MODE_NOSCALE) {
          let result = `${this._width}x${this._height}`;

          if (this._dimensionElement.innerText !== result) {
            this._dimensionElement.innerText = result;
          }
        } else {
          let result = `${this._width}x${this._height}|${this.shadowRoot.host.clientWidth}x${this.shadowRoot.host.clientHeight}`;

          if (this._dimensionElement.innerText !== result) {
            this._dimensionElement.innerText = result;
          }
        }
      }

      this.dispatchEvent(new CustomEvent('frame', {
        detail: {
          now,
          prevTime: this._prevAnimationFrameTime,
          deltaTime: deltaTime,
          canvas: this._canvasElement
        },
        bubbles: false,
        composed: true
      }));
    }
    /** @private */


    updateCanvasSize() {
      let clientRect = this.shadowRoot.host.getBoundingClientRect();
      const clientWidth = clientRect.width;
      const clientHeight = clientRect.height;
      let canvas = this._canvasElement;
      let canvasWidth = this._width;
      let canvasHeight = this._height;
      const mode = this.mode;

      if (mode === MODE_STRETCH) {
        canvasWidth = clientWidth;
        canvasHeight = clientHeight;
      } else if (mode !== MODE_NOSCALE) {
        let flag = clientWidth < canvasWidth || clientHeight < canvasHeight || mode === MODE_FIT;

        if (flag) {
          let ratioX = clientWidth / canvasWidth;
          let ratioY = clientHeight / canvasHeight;

          if (ratioX < ratioY) {
            canvasWidth = clientWidth;
            canvasHeight = canvasHeight * ratioX;
          } else {
            canvasWidth = canvasWidth * ratioY;
            canvasHeight = clientHeight;
          }
        }
      }

      canvasWidth = Math.floor(canvasWidth);
      canvasHeight = Math.floor(canvasHeight);
      let fontSize = Math.min(canvasWidth / this._width, canvasHeight / this._height) * 0.5; // NOTE: Update the inner container for the default slotted children.
      // To anchor children outside the canvas, use the slot named 'frame'.

      this._innerElement.style = `font-size: ${fontSize}em`;

      if (canvas.clientWidth !== canvasWidth || canvas.clientHeight !== canvasHeight) {
        canvas.width = this._width;
        canvas.height = this._height;
        this._contentElement.style = `width: ${canvasWidth}px; height: ${canvasHeight}px`;
        this.dispatchEvent(new CustomEvent('resize', {
          detail: {
            width: canvasWidth,
            height: canvasHeight
          },
          bubbles: false,
          composed: true
        }));
      }
    }

  }

  window.customElements.define('display-port', DisplayPort);

  class RandomGenerator {
    /** @abstract */
    next() {
      return Math.random();
    }

  }

  let RAND;

  class Random {
    constructor(randomGenerator = new RandomGenerator()) {
      this.generator = randomGenerator;
    }

    static next() {
      return RAND.next();
    }

    next() {
      return this.generator.next();
    }

    static choose(list) {
      return RAND.choose(list);
    }

    choose(list) {
      return list[Math.floor(this.generator.next() * list.length)];
    }

    static range(min, max) {
      return RAND.range(min, max);
    }

    range(min, max) {
      return (max - min) * this.generator.next() + min;
    }

    static sign() {
      return RAND.sign();
    }

    sign() {
      return this.generator.next() < 0.5 ? -1 : 1;
    }

  }

  RAND = new Random();

  const LAYERS = ['back', 'main', 'fore'];
  const LAYER_COLORS = {
    back: '#000000',
    main: '#333333',
    fore: '#888888'
  };
  const LAYER_SPEED = {
    back: 0.3,
    main: 0.5,
    fore: 1
  };
  const LAYER_OFFSET = {
    back: 0,
    main: -8,
    fore: -16
  };
  const WEIGHTED_LAYERS = ['back', 'back', 'back', 'back', 'main', 'main', 'fore'];
  const MAX_BUILDING_COUNT = 80;
  const BUILDING_RAND = new Random();

  const BUILDING_LAYER_RAND = () => BUILDING_RAND.choose(WEIGHTED_LAYERS);

  const BUILDING_POS_RAND = max => Math.trunc(BUILDING_RAND.range(0, max));

  const BUILDING_WIDTH_RAND = () => Math.trunc(BUILDING_RAND.range(16, 32));

  const BUILDING_HEIGHT_RAND = () => Math.trunc(BUILDING_RAND.range(36, 80));

  const RAILING_WIDTH = 80;
  const RAILING_HEIGHT = 8;
  const RAILING_SPEED = 6;
  const ROAD_HEIGHT = 64;

  function createBuilding(world) {
    const layer = 'main';
    const building = {
      x: 0,
      width: 36,
      height: 16,
      layer: layer
    };
    world.background.buildings.push(building);
    world.background.buildingLayers[layer].push(building);
    return building;
  }

  function randomizeBuilding(world, building) {
    building.x = BUILDING_POS_RAND(world.display.width);
    building.width = BUILDING_WIDTH_RAND();
    building.height = BUILDING_HEIGHT_RAND();
    let prevLayer = building.layer;
    let nextLayer = BUILDING_LAYER_RAND();
    let layers = world.background.buildingLayers;
    layers[prevLayer].splice(layers[prevLayer].indexOf(building), 1);
    layers[nextLayer].push(building);
    building.layer = nextLayer;
  }

  function load(world) {
    world.background = {
      buildingLayers: {
        fore: [],
        back: [],
        main: []
      },
      buildings: [],
      progress: 0
    };

    for (let i = 0; i < MAX_BUILDING_COUNT; ++i) {
      let b = createBuilding(world);
      randomizeBuilding(world, b);
    }
  }
  function update(dt, world) {
    world.background.progress += dt;

    for (let layer of LAYERS) {
      for (let building of world.background.buildingLayers[layer]) {
        if (building.x > world.display.width) {
          randomizeBuilding(world, building);
          building.x -= world.display.width + building.width;
        } else {
          building.x += LAYER_SPEED[layer];
        }
      }
    }
  }
  function render(ctx, world) {
    const worldWidth = world.display.width;
    const worldHeight = world.display.height; // Draw sky

    ctx.fillStyle = '#561435';
    ctx.fillRect(0, 0, worldWidth, worldHeight);
    ctx.fillStyle = '#8e3e13';
    ctx.fillRect(0, 0, worldWidth, worldHeight / 3);
    ctx.fillStyle = '#a09340';
    ctx.fillRect(0, 0, worldWidth, worldHeight / 10);
    ctx.fillStyle = '#e8d978';
    ctx.fillRect(0, 0, worldWidth, worldHeight / 30); // Draw parallax buildings

    for (let layer of LAYERS) {
      ctx.fillStyle = LAYER_COLORS[layer];

      for (let building of world.background.buildingLayers[layer]) {
        drawBuilding(ctx, world, building);
      }
    }

    const roadOffsetY = worldHeight - ROAD_HEIGHT; // Draw railings

    ctx.fillStyle = '#000000';
    let y = roadOffsetY - RAILING_HEIGHT;
    let dx = world.background.progress % RAILING_WIDTH * RAILING_SPEED;
    ctx.translate(dx, y);

    for (let x = -RAILING_WIDTH * RAILING_SPEED; x < worldWidth; x += RAILING_WIDTH) {
      ctx.translate(x, 0);
      drawRailing(ctx);
      ctx.translate(-x, 0);
    }

    ctx.translate(-dx, -y); // Draw road

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, roadOffsetY, worldWidth, ROAD_HEIGHT);
  }

  function drawRailing(ctx, world) {
    let railCount = 5;
    let railWidth = RAILING_WIDTH / railCount;

    for (let i = 0; i < railCount; ++i) {
      let x = i * railWidth;
      let t = x % 3;
      ctx.translate(x, 0);
      {
        ctx.fillRect(0, -t * 2, 3, RAILING_HEIGHT + t * 2);
        ctx.fillRect(8, 0, 3, RAILING_HEIGHT);
        ctx.fillRect(0, 2 + t, railWidth, 3);
      }
      ctx.translate(-x, 0);
    }
  }

  function drawBuilding(ctx, world, building) {
    let offsetY = LAYER_OFFSET[building.layer];
    let x = Math.trunc(building.x);
    let y = Math.trunc(world.display.height - ROAD_HEIGHT - building.height - offsetY);
    ctx.translate(x, y);
    {
      ctx.fillRect(0, 0, building.width, building.height + offsetY);
    }
    ctx.translate(-x, -y);
  }

  const ANIMATED_TEXT_STATE_KEY = Symbol('animatedText');
  const ERROR_FRAME_TIME = 1_000_000;
  const DEFAULT_CHAR_TIME = 30;
  const INITIAL_WAIT_TIME = 300;
  const INITIAL_INLINE_TIME = DEFAULT_CHAR_TIME;
  const WHITE_PATTERN = /\s/;
  const LONG_PATTERN = /[.!?]/;
  const SHORT_PATTERN = /[-,:;]/;
  const SUSTAIN_PATTERN = /[.-]/;

  function charTime(c, next) {
    let nextWhite = WHITE_PATTERN.test(next);

    if (nextWhite || SUSTAIN_PATTERN.test(c)) {
      if (LONG_PATTERN.test(c)) return 800;else if (SHORT_PATTERN.test(c)) return 250;
    } else {
      if (LONG_PATTERN.test(c)) return 200;else if (SHORT_PATTERN.test(c)) return 100;
    }

    return DEFAULT_CHAR_TIME;
  }

  class AnimatedTextState {
    constructor(rootElement, speed = 1) {
      /** @type {Element} */
      this.rootElement = rootElement;
      /** @type {Text} */

      this.targetNode = null;
      this.animatedNodes = new Set();
      this.nodeContents = new Map();
      this.deltaTime = 0;
      this.prevTime = 0;
      this.waitTime = INITIAL_WAIT_TIME;
      this.targetText = '';
      this.index = -1;
      this.disabled = true;
      this.complete = false;
      this.speed = speed;
      this.callback = null;
      this.error = null;
      this.animationFrameHandle = null;
      /** @private */

      this.onAnimationFrame = this.onAnimationFrame.bind(this);
    }

    toggle(force = !this.disabled) {
      if (force) {
        this.pause();
      } else {
        this.resume();
      }
    }

    pause() {
      this.disabled = true;
      cancelAnimationFrame(this.animationFrameHandle);
      this.animationFrameHandle = null; // NOTE: Removes dead wait time after unpause to feel more impactful.

      this.deltaTime = this.waitTime;
    }

    resume() {
      this.disabled = false;

      if (!this.canSafelyResumeWithTarget(this.targetNode)) {
        this.targetNode = null;
      }

      this.prevTime = performance.now();
      this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);
    }

    reset() {
      this.targetNode = null;
      this.animatedNodes.clear();
    }

    skipAll() {
      if (this.targetNode) {
        this.targetNode.nodeValue = this.targetText;
        this.targetNode = null;
      }

      this.completeRemainingChildText();
    }
    /** @private */


    onAnimationFrame(now) {
      this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);

      if (this.targetNode == null) {
        let next = this.findNextChildText();

        if (next) {
          let inline = next.previousSibling || window.getComputedStyle(next.parentElement).display === 'inline';
          this.targetNode = next;
          this.targetText = this.nodeContents.get(next);
          this.animatedNodes.add(next);
          this.index = -1;
          this.waitTime = inline ? INITIAL_INLINE_TIME : INITIAL_WAIT_TIME;
          this.deltaTime = 0;
          this.complete = false;
        } else {
          // The end of the road.
          this.complete = true;
          this.callback.call(undefined);
          return;
        }
      }

      let frameDelta = now - this.prevTime;
      this.deltaTime += frameDelta * this.speed;
      this.prevTime = now;

      if (frameDelta > ERROR_FRAME_TIME) {
        this.skipAll();
        this.error(new Error('Frame took too long; skipping animation.'));
        return;
      }

      const text = this.targetText;
      let flag = false;

      while (!flag && this.deltaTime >= this.waitTime) {
        this.deltaTime -= this.waitTime;
        let i = ++this.index;

        if (i < text.length) {
          let current = text.charAt(i);
          let next = text.charAt(i + 1);
          this.waitTime = charTime(current, next);
        } else {
          this.index = text.length;
          flag = true;
        }
      } // Update DOM content


      if (!flag) {
        let newText = text.substring(0, this.index + 1);
        this.targetNode.nodeValue = newText;
      } else {
        this.targetNode.nodeValue = text;
        this.targetNode = null;
      }
    }
    /** @private */


    canSafelyResumeWithTarget(node) {
      if (!node) return false;
      if (!node.isConnected) return false;
      let content = node.nodeValue;
      let expected = this.targetText.substring(0, this.index + 1);
      if (content !== expected) return false;
      return true;
    }
    /** @private */


    completeRemainingChildText(parent = this.rootElement) {
      for (let child of parent.childNodes) {
        if (child instanceof Text) {
          if (this.nodeContents.has(child)) {
            if (!this.animatedNodes.has(child)) {
              child.nodeValue = this.nodeContents.get(child);
              this.animatedNodes.add(child);
            }
          }
        } else {
          this.completeRemainingChildText(child);
        }
      }
    }
    /**
     * @private
     * @param {HTMLElement|Text} parent 
     * @returns {Text|null}
     */


    findNextChildText(parent = this.rootElement, result = null) {
      for (let child of parent.childNodes) {
        if (child instanceof Text) {
          let hasAnimated = this.animatedNodes.has(child);
          let content = child.nodeValue;

          if (content && content.trim().length > 0 && this.nodeContents.get(child) !== content) {
            this.nodeContents.set(child, content);
            child.nodeValue = '';

            if (hasAnimated) {
              this.animatedNodes.delete(child);
            }
          }

          if (!result && !hasAnimated && this.nodeContents.has(child)) {
            result = child;
          }
        } else {
          result = this.findNextChildText(child, result);
        }
      }

      return result;
    }

  }

  const AnimatedText = {
    async play(element, speed = 1) {
      if (!(element instanceof Element)) {
        throw new Error('Cannot animate text for non-element.');
      }

      if (speed <= 0) {
        throw new Error('Cannot animate text at non-positive speed.');
      }

      let state = new AnimatedTextState(element, speed);
      element[ANIMATED_TEXT_STATE_KEY] = state;
      return new Promise((resolve, reject) => {
        state.error = e => {
          reject(e);
        };

        state.callback = () => {
          state.pause();
          delete element[ANIMATED_TEXT_STATE_KEY];
          resolve();
        };

        state.resume();
      });
    },

    pause(element) {
      if (element && ANIMATED_TEXT_STATE_KEY in element) {
        let state = element[ANIMATED_TEXT_STATE_KEY];
        state.pause();
      }
    },

    resume(element) {
      if (element && ANIMATED_TEXT_STATE_KEY in element) {
        let state = element[ANIMATED_TEXT_STATE_KEY];
        state.resume();
      }
    },

    skip(element) {
      if (element && ANIMATED_TEXT_STATE_KEY in element) {
        let state = element[ANIMATED_TEXT_STATE_KEY];
        state.skipAll();
      }
    },

    toggle(element, force = undefined) {
      if (element && ANIMATED_TEXT_STATE_KEY in element) {
        let state = element[ANIMATED_TEXT_STATE_KEY];
        state.toggle(force);
      }
    }

  };

  function load$1(world) {
    let container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.bottom = '0.8em';
    container.style.right = '0.8em';
    container.innerHTML = `
        <style>
            .container {
                position: relative;
                background-color: #091b3d;
                color: #eeeeee;
                padding: 0.5em;
                width: 20em;
                height: 5em;
                overflow: auto;
                font-family: monospace;
            }
        </style>
        <div class="container">
            <article>
                There is something amiss in Maird. There is not one corner of this town left
                untainted
                by the smell of foul blood. No windows unshattered. No doors unlocked.
            </article>
        </div>`;
    world.display.appendChild(container);
    let article = container.querySelector('article');
    article.addEventListener('click', () => {
      AnimatedText.skip(article);
    });
    AnimatedText.play(article);
    world.dialogue = {
      text: '',
      element: container
    };
  }

  function load$2(world) {
    let container = document.createElement('div');
    let vacancyButton = document.createElement('button');
    vacancyButton.textContent = 'VACANT';
    vacancyButton.style.backgroundColor = '#aa3333';
    vacancyButton.style.color = '#eeeeee';
    vacancyButton.style.border = '0.3em ridge #660000';
    vacancyButton.style.fontSize = '1.5em';
    vacancyButton.style.padding = '0.1em 0.5em';
    vacancyButton.style.position = 'absolute';
    vacancyButton.style.left = '0.2em';
    vacancyButton.style.bottom = '0.2em';
    container.appendChild(vacancyButton);
    let distanceMeter = document.createElement('label');
    distanceMeter.textContent = '0000 fare';
    distanceMeter.style.color = '#eeeeee';
    distanceMeter.style.fontSize = '1.5em';
    distanceMeter.style.position = 'absolute';
    distanceMeter.style.bottom = '0.2em';
    distanceMeter.style.left = '7em';
    container.appendChild(distanceMeter);
    world.display.appendChild(container);
  }

  window.addEventListener('DOMContentLoaded', main);
  window.addEventListener('error', error, true);
  window.addEventListener('unhandledrejection', error, true);

  function error(e) {
    if (e instanceof PromiseRejectionEvent) {
      window.alert(e.reason.stack);
    } else if (e instanceof ErrorEvent) {
      window.alert(e.error.stack);
    } else {
      window.alert(JSON.stringify(e));
    }
  }

  async function main() {
    /** @type {import('@milque/display').DisplayPort}  */
    const display = document.querySelector('#display');
    const ctx = display.canvas.getContext('2d');
    const world = {
      display,
      ctx,
      frames: 0
    };
    load(world);
    load$1(world);
    load$2(world);
    display.addEventListener('frame', e => {
      const {
        deltaTime
      } = e.detail;
      const dt = deltaTime / 60;
      update$1(dt, world);
      render$1(ctx, world);
      world.frames += 1;
    });
  }

  function update$1(dt, world) {
    update(dt, world);
  }

  function render$1(ctx, world) {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, world.display.width, world.display.height);
    render(ctx, world);
  }

}());
