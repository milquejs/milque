{
  "version": 3,
  "sources": ["node-modules-polyfills:path", "node-modules-polyfills-commonjs:path", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/constants.js", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/utils.js", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/scan.js", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/parse.js", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/lib/picomatch.js", "../../../common/temp/node_modules/.pnpm/picomatch@2.3.0/node_modules/picomatch/index.js", "../../../packages/display/dist/esm/index.js", "../../../packages/input/dist/esm/index.js", "../../../common/temp/node_modules/.pnpm/fflate@0.6.10/node_modules/fflate/esm/browser.js", "../../../packages/asset/dist/esm/index.js", "../src/error.js", "../src/util/Directional.js", "../src/junction/Junction.js", "../src/render2d.js", "../src/acreworld/Directable.js", "../src/acreworld/Persistence.js", "../../../packages/util/dist/esm/index.js", "../src/acreworld/RoadMaker.js", "../src/cartworld/TrafficSimulator.js", "../src/util/astar.js", "../src/cartworld/PathFinder.js", "../src/acreworld/Cargo.js", "../src/cartworld/CartManager.js", "../src/cartworld/Navigator.js", "../src/acreworld/Demolition.js", "../src/acreworld/Housing.js", "../src/acreworld/Solids.js", "../src/acreworld/ScoreKeeper.js", "../src/acreworld/AcreWorld.js", "../src/acreworld/main.js", "../src/main.js"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexport function resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexport function normalize(path) {\n  var isPathAbsolute = isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isPathAbsolute).join('/');\n\n  if (!path && !isPathAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexport function isAbsolute(path) {\n  return path.charAt(0) === '/';\n}\n\n// posix version\nexport function join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n}\n\n\n// path.relative(from, to)\n// posix version\nexport function relative(from, to) {\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nexport var sep = '/';\nexport var delimiter = ':';\n\nexport function dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nexport function basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n\n\nexport function extname(path) {\n  return splitPath(path)[3];\n}\nexport default {\n  extname: extname,\n  basename: basename,\n  dirname: dirname,\n  sep: sep,\n  delimiter: delimiter,\n  relative: relative,\n  join: join,\n  isAbsolute: isAbsolute,\n  normalize: normalize,\n  resolve: resolve\n};\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ?\n    function (str, start, len) { return str.substr(start, len) } :\n    function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n", "\nconst polyfill = require('path')\n\nif (polyfill && polyfill.default) {\n    module.exports = polyfill.default\n} else if (polyfill)  {\n    module.exports = polyfill\n}\n\nif (polyfill) {\n    for (let k in polyfill) {\n        module.exports[k] = polyfill[k]\n    }\n}\n", "'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n", "'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n", "'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n", "'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        output = token.close = `)${rest})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n", "'use strict';\n\nmodule.exports = require('./lib/picomatch');\n", "var INNER_HTML = \"<div class=\\\"container\\\">\\n    <label class=\\\"hidden\\\" id=\\\"title\\\">display-port</label>\\n    <label class=\\\"hidden\\\" id=\\\"fps\\\">00</label>\\n    <label class=\\\"hidden\\\" id=\\\"dimension\\\">0x0</label>\\n    <div class=\\\"content\\\">\\n        <canvas>\\n            Oh no! Your browser does not support canvas.\\n        </canvas>\\n        <slot id=\\\"inner\\\"></slot>\\n    </div>\\n    <slot name=\\\"frame\\\"></slot>\\n</div>\";\n\nvar INNER_STYLE = \":host {\\n    display: inline-block;\\n    color: #555555;\\n}\\n\\n.container {\\n    display: flex;\\n    position: relative;\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.content {\\n    position: relative;\\n    margin: auto;\\n}\\n\\n.content > *:not(canvas) {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\ncanvas {\\n    background: #000000;\\n    image-rendering: pixelated;\\n}\\n\\nlabel {\\n    position: absolute;\\n    font-family: monospace;\\n    color: currentColor;\\n}\\n\\n#inner {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    pointer-events: none;\\n}\\n\\n#title {\\n    left: 0.5rem;\\n    top: 0.5rem;\\n}\\n\\n#fps {\\n    right: 0.5rem;\\n    top: 0.5rem;\\n}\\n\\n#dimension {\\n    left: 0.5rem;\\n    bottom: 0.5rem;\\n}\\n\\n.hidden {\\n    display: none;\\n}\\n\\n:host([debug]) .container {\\n    outline: 6px dashed rgba(0, 0, 0, 0.1);\\n    outline-offset: -4px;\\n    background-color: rgba(0, 0, 0, 0.1);\\n}\\n\\n:host([mode=\\\"noscale\\\"]) canvas {\\n    margin: 0;\\n    top: 0;\\n    left: 0;\\n}\\n\\n:host([mode=\\\"stretch\\\"]) canvas,\\n:host([mode=\\\"scale\\\"]) canvas {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n:host([mode=\\\"fit\\\"]),\\n:host([mode=\\\"scale\\\"]),\\n:host([mode=\\\"center\\\"]),\\n:host([mode=\\\"stretch\\\"]),\\n:host([mode=\\\"fill\\\"]) {\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n:host([full]) {\\n    width: 100vw !important;\\n    height: 100vh !important;\\n}\\n\\n:host([disabled]) {\\n    display: none;\\n}\\n\\nslot {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    position: absolute;\\n    width: 100%;\\n    height: 100%;\\n    top: 0;\\n    left: 0;\\n    pointer-events: none;\\n}\\n\\n::slotted(*) {\\n    pointer-events: auto;\\n}\\n\";\n\n/**\n * No scaling is applied. The canvas size maintains a\n * 1:1 pixel ratio to the defined display dimensions.\n */\nconst MODE_NOSCALE = 'noscale';\n\n/**\n * Scales the canvas to fill the entire viewport and\n * maintains the same aspect ratio. This will adjust\n * canvas resolution to fit the viewport dimensions.\n * In other words, the canvas pixel size remains\n * constant, but the number of pixels in the canvas\n * will increase or decrease to compensate. This is\n * the default scaling mode.\n */\nconst MODE_FIT = 'fit';\n\n/**\n * Scales the canvas to fill the entire viewport and\n * maintains the same aspect ratio and pixel\n * resolution. This will upscale and downscale the\n * pixel size depending on the viewport dimentions\n * in order to preserve the canvas pixel count. In\n * other words, the number of pixels in the canvas\n * remain constant but appear larger or smaller to\n * compensate.\n */\nconst MODE_SCALE = 'scale';\n\n/**\n * Resizes the canvas to fill the entire viewport.\n * This does not maintain the aspect ratio nor pixel\n * count (adds and removes pixels to fill size). If you\n * care about aspect ratio but not pixel count, consider\n * using 'fit' mode instead.\n */\nconst MODE_FILL = 'fill';\n\n/**\n * Scales the canvas to fill the entire viewport.\n * This does not maintain the aspect ratio but\n * does preserve pixel count (by stretching the pixel\n * size). If you care about aspect ratio and pixel\n * count, consider using 'scale' mode instead.\n */\nconst MODE_STRETCH = 'stretch';\n\n/**\n * The default display x dimensions. This is\n * the same as the canvas element default.\n */\nconst DEFAULT_WIDTH = 300;\n/**\n * The default display y dimensions. This is\n * the same as the canvas element default.\n */\nconst DEFAULT_HEIGHT = 150;\n\n/** The default display scaling mode. */\nconst DEFAULT_MODE = MODE_FIT;\n\n/** The default resize timeout */\nconst DELAYED_RESIZE_MILLIS = 200;\n\n/**\n * @typedef {CustomEvent} FrameEvent\n * @property {number} detail.now\n * The current time in milliseconds.\n * @property {number} detail.prevTime\n * The previous frame time in milliseconds.\n * @property {number} detail.deltaTime\n * The time taken between the current and previous\n * frame in milliseconds.\n * @property {HTMLCanvasElement} detail.canvas\n * The canvas element.\n */\n\n/**\n * @typedef {MODE_CENTER\n *          |MODE_FIT\n *          |MODE_NOSCALE\n *          |MODE_SCALE\n *          |MODE_STRETCH} DisplayScaling\n */\n\n/**\n * A canvas that can scale and stretch with respect to the aspect ratio to fill\n * the viewport size.\n * \n * To start drawing, you should get the canvas context like so:\n * \n * For Canvas2D:\n * ```\n * const display = document.querySelector('display-port');\n * const ctx = display.canvas.getContext('2d');\n * ctx.drawText(0, 0, 'Hello World!');\n * ```\n * \n * For WebGL:\n * ```\n * const display = document.querySelector('display-port');\n * const gl = display.canvas.getContext('webgl');\n * gl.clear(gl.COLOR_BUFFER_BIT);\n * ```\n * \n * Usually, you would want to set the `width` and `height` attributes to define\n * the canvas size and aspect ratio in pixels. You can also change the scaling\n * behavior by setting the `mode` attribute.\n * \n * And for convenience, this element also dispatches a `frame` event every animation\n * frame (60 fps). This is basically the same as calling `requestAnimationFrame()`.\n * \n * NOTE: The viewport size is usually the parent container size. However, in the\n * rare case the element must be nested in a child container, you can define the\n * boolean attribute `full` to force the dimensions to be the actual window size.\n */\nclass DisplayPort extends HTMLElement\n{\n    /** @private */\n    static get [Symbol.for('templateNode')]()\n    {\n        let t = document.createElement('template');\n        t.innerHTML = INNER_HTML;\n        Object.defineProperty(this, Symbol.for('templateNode'), { value: t });\n        return t;\n    }\n\n    /** @private */\n    static get [Symbol.for('styleNode')]()\n    {\n        let t = document.createElement('style');\n        t.innerHTML = INNER_STYLE;\n        Object.defineProperty(this, Symbol.for('styleNode'), { value: t });\n        return t;\n    }\n\n    static define(customElements = window.customElements)\n    {\n        customElements.define('display-port', this);\n    }\n\n    /** @override */\n    static get observedAttributes()\n    {\n        return [\n            'debug',\n            'disabled',\n            // 'mode',\n            'width',\n            'height',\n            'onframe',\n            // Built-in attributes\n            'id',\n            'class',\n        ];\n    }\n\n    /**\n     * The scaling mode.\n     * - `noscale`: Do not perform scaling.\n     * - `center`: Do not perform scaling but stretch the display to fill the entire\n     * viewport. The unscaled canvas is centered.\n     * - `fit`: Resize resolution to fill the entire viewport and maintains the aspect\n     * ratio. The pixel resolution is changed. This is the default behavior.\n     * - `fill`: Resize resolution to fill the entire viewport but does not maintain\n     * aspect ratio.\n     * - `stretch`: Perform scaling to fill the entire viewport but does not maintain\n     * aspect ratio.\n     * - `scale`: Perform scaling to fill the entire viewport and maintains the\n     * aspect ratio and resolution. The pixel resolution remains constant.\n     * @returns {DisplayScaling} The current scaling mode.\n     */\n    get mode()\n    {\n        return /** @type {DisplayScaling} */(this.getAttribute('mode'));\n    }\n\n    set mode(value)\n    {\n        this.setAttribute('mode', value);\n    }\n\n    /**\n     * Set to true for debug information.\n     * @returns {boolean}\n     */\n    get debug()\n    {\n        return this._debug;\n    }\n\n    set debug(value)\n    {\n        this.toggleAttribute('debug', value);\n    }\n\n    /**\n     * If disabled, animation frames will not fire.\n     * @returns {boolean}\n     */\n    get disabled()\n    {\n        return this._disabled;\n    }\n\n    set disabled(value)\n    {\n        this.toggleAttribute('disabled', value);\n    }\n\n    /**\n     * The canvas width in pixels. This determines the aspect ratio and canvas buffer size.\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value)\n    {\n        this.setAttribute('width', String(value));\n    }\n\n    /**\n     * The canvas height in pixels. This determines the aspect ratio and canvas buffer size.\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value)\n    {\n        this.setAttribute('height', String(value));\n    }\n\n    /** Fired every animation frame. */\n    get onframe()\n    {\n        return this._onframe;\n    }\n\n    set onframe(value)\n    {\n        if (this._onframe) this.removeEventListener('frame', this._onframe);\n        this._onframe = value;\n        if (this._onframe) this.addEventListener('frame', value);\n    }\n\n    constructor()\n    {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('templateNode')].content.cloneNode(true));\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('styleNode')].cloneNode(true));\n        \n        /** @private */\n        this._canvasElement = this.shadowRoot.querySelector('canvas');\n        /**\n         * @private\n         * @type {HTMLDivElement}\n         */\n        this._contentElement = this.shadowRoot.querySelector('.content');\n        /**\n         * @private\n         * @type {HTMLSlotElement}\n         */\n        this._innerElement = this.shadowRoot.querySelector('#inner');\n\n        /** @private */\n        this._titleElement = this.shadowRoot.querySelector('#title');\n        /** @private */\n        this._fpsElement = this.shadowRoot.querySelector('#fps');\n        /** @private */\n        this._dimensionElement = this.shadowRoot.querySelector('#dimension');\n\n        /** @private */\n        this._debug = false;\n        /** @private */\n        this._disabled = false;\n        /** @private */\n        this._width = DEFAULT_WIDTH;\n        /** @private */\n        this._height = DEFAULT_HEIGHT;\n        /** @private */\n        this._onframe = undefined;\n\n        /** @private */\n        this._animationRequestHandle = 0;\n        /** @private */\n        this._prevAnimationFrameTime = 0;\n\n        /** @private */\n        this._resizeTimeoutHandle = 0;\n        this._resizeCanvasWidth = 0;\n        this._resizeCanvasHeight = 0;\n\n        /** @private */\n        this.update = this.update.bind(this);\n        /** @private */\n        this.onDelayCanvasResize = this.onDelayCanvasResize.bind(this);\n    }\n\n    /** Get the canvas element. */\n    get canvas() { return this._canvasElement; }\n    \n    /** @override */\n    connectedCallback()\n    {\n        upgradeProperty(this, 'mode');\n        upgradeProperty(this, 'debug');\n        upgradeProperty(this, 'disabled');\n        upgradeProperty(this, 'width');\n        upgradeProperty(this, 'height');\n        upgradeProperty(this, 'onframe');\n\n        if (!this.hasAttribute('mode'))\n        {\n            this.setAttribute('mode', DEFAULT_MODE);\n        }\n\n        // Allows this element to be focusable\n        if (!this.hasAttribute('tabindex'))\n        {\n            this.setAttribute('tabindex', '0');\n        }\n        \n        this.updateCanvasSize(true);\n        this.resume();\n    }\n\n    /** @override */\n    disconnectedCallback()\n    {\n        this.pause();\n    } \n\n    /** @override */\n    attributeChangedCallback(attribute, prev, value)\n    {\n        switch(attribute) {\n            case 'debug':\n                {\n                    this._debug = value !== null;\n                }\n                break;\n            case 'disabled':\n                {\n                    this._disabled = value !== null;\n                }\n                break;\n            case 'width':\n                {\n                    this._width = Number(value);\n                }\n                break;\n            case 'height':\n                {\n                    this._height = Number(value);\n                }\n                break;\n            case 'onframe':\n                {\n                    this.onframe = new Function('event',\n                        'with(document){with(this){' + value + '}}').bind(this);\n                }\n                break;\n        }\n\n        switch(attribute) {\n            case 'disabled':\n                if (value)\n                {\n                    this.update(0);\n                    this.pause();\n                }\n                else\n                {\n                    this.resume();\n                }\n                break;\n            // NOTE: For debugging purposes...\n            case 'id':\n            case 'class':\n                this._titleElement.innerHTML = `display-port${this.className ? '.' + this.className : ''}${this.hasAttribute('id') ? '#' + this.getAttribute('id') : ''}`;\n                break;\n            case 'debug':\n                this._titleElement.classList.toggle('hidden', value);\n                this._fpsElement.classList.toggle('hidden', value);\n                this._dimensionElement.classList.toggle('hidden', value);\n                break;\n        }\n    }\n\n    /**\n     * @param {'2d'|'webgl'|'webgl2'} [contextId]\n     * @param {CanvasRenderingContext2DSettings} [options] \n     */\n    getContext(contextId = '2d', options = undefined)\n    {\n        return this._canvasElement.getContext(contextId, options);\n    }\n\n    /** Pause animation of the display frames. */\n    pause()\n    {\n        cancelAnimationFrame(this._animationRequestHandle);\n    }\n\n    /** Resume animation of the display frames. */\n    resume()\n    {\n        this._animationRequestHandle = requestAnimationFrame(this.update);\n    }\n\n    /** @private */\n    update(now)\n    {\n        this._animationRequestHandle = requestAnimationFrame(this.update);\n        this.updateCanvasSize(false);\n        const deltaTime = now - this._prevAnimationFrameTime;\n        this._prevAnimationFrameTime = now;\n\n        // NOTE: For debugging purposes...\n        if (this._debug)\n        {\n            // Update FPS...\n            const frames = deltaTime <= 0\n                ? '--'\n                : String(Math.round(1000 / deltaTime)).padStart(2, '0');\n            if (this._fpsElement.textContent !== frames)\n            {\n                this._fpsElement.textContent = frames;\n            }\n\n            // Update dimensions...\n            const mode = this.mode;\n            if (mode === MODE_NOSCALE)\n            {\n                let result = `${this._width}x${this._height}`;\n                if (this._dimensionElement.textContent !== result)\n                {\n                    this._dimensionElement.textContent = result;\n                }\n            }\n            else\n            {\n                let result = `${this._width}x${this._height}|${this.shadowRoot.host.clientWidth}x${this.shadowRoot.host.clientHeight}`;\n                if (this._dimensionElement.textContent !== result)\n                {\n                    this._dimensionElement.textContent = result;\n                }\n            }\n        }\n\n        this.dispatchEvent(new CustomEvent('frame', {\n            detail: {\n                now,\n                prevTime: this._prevAnimationFrameTime,\n                deltaTime: deltaTime,\n                canvas: this._canvasElement,\n            },\n            bubbles: false,\n            composed: true\n        }));\n    }\n\n    /** @private */\n    onDelayCanvasResize()\n    {\n        this._resizeTimeoutHandle = 0;\n        this.updateCanvasSize(true);\n    }\n\n    delayCanvasResize(canvasWidth, canvasHeight)\n    {\n        if (canvasWidth !== this._resizeCanvasWidth || canvasHeight !== this._resizeCanvasHeight)\n        {\n            // Only call onDelayCanvasResize, if new canvas size actually changed since last time.\n            this._resizeCanvasWidth = canvasWidth;\n            this._resizeCanvasHeight = canvasHeight;\n            if (this._resizeTimeoutHandle)\n            {\n                clearTimeout(this._resizeTimeoutHandle);\n            }\n            this._resizeTimeoutHandle = setTimeout(this.onDelayCanvasResize, DELAYED_RESIZE_MILLIS);\n        }\n    }\n    \n    /** @private */\n    updateCanvasSize(force = true)\n    {\n        const clientRect = this.shadowRoot.host.getBoundingClientRect();\n        const clientWidth = clientRect.width;\n        const clientHeight = clientRect.height;\n\n        let canvas = this._canvasElement;\n        let canvasWidth = this._width;\n        let canvasHeight = this._height;\n\n        const mode = this.mode;\n        if (mode === MODE_STRETCH || mode === MODE_FILL)\n        {\n            canvasWidth = clientWidth;\n            canvasHeight = clientHeight;\n        }\n        else if (mode !== MODE_NOSCALE)\n        {\n            if (clientWidth < canvasWidth\n                || clientHeight < canvasHeight\n                || mode === MODE_FIT\n                || mode == MODE_SCALE)\n            {\n                let ratioX = clientWidth / canvasWidth;\n                let ratioY = clientHeight / canvasHeight;\n\n                if (ratioX < ratioY)\n                {\n                    canvasWidth = clientWidth;\n                    canvasHeight = canvasHeight * ratioX;\n                }\n                else\n                {\n                    canvasWidth = canvasWidth * ratioY;\n                    canvasHeight = clientHeight;\n                }\n            }\n        }\n\n        canvasWidth = Math.floor(canvasWidth);\n        canvasHeight = Math.floor(canvasHeight);\n\n        if (typeof force === 'undefined')\n        {\n            force = canvas.clientWidth !== canvasWidth || canvas.clientHeight !== canvasHeight;\n        }\n\n        if (!force)\n        {\n            this.delayCanvasResize(canvasWidth, canvasHeight);\n            return;\n        }\n\n        let fontSize = Math.min(\n            canvasWidth / this._width,\n            canvasHeight / this._height) * 0.5;\n        // NOTE: Update the inner container for the default slotted children.\n        // To anchor children outside the canvas, use the slot named 'frame'.\n        this._innerElement.style.fontSize = `font-size: ${fontSize}em`;\n        if (force)\n        {\n            if (mode === MODE_SCALE)\n            {\n                canvas.width = this._width;\n                canvas.height = this._height;\n            }\n            else if (mode !== MODE_STRETCH)\n            {\n                canvas.width = canvasWidth;\n                canvas.height = canvasHeight;\n            }\n            let contentStyle = this._contentElement.style;\n            contentStyle.width = `${canvasWidth}px`;\n            contentStyle.height = `${canvasHeight}px`;\n\n            if (mode === MODE_FIT || mode === MODE_FILL)\n            {\n                this._width = canvasWidth;\n                this._height = canvasHeight;\n            }\n\n            this.dispatchEvent(new CustomEvent('resize', { detail: {\n                width: canvasWidth,\n                height: canvasHeight\n            }, bubbles: false, composed: true }));\n        }\n    }\n}\nDisplayPort.define();\n\nfunction upgradeProperty(element, propertyName)\n{\n    if (Object.prototype.hasOwnProperty.call(element, propertyName))\n    {\n        let value = element[propertyName];\n        delete element[propertyName];\n        element[propertyName] = value;\n    }\n}\n\nexport { DisplayPort };\n", "/**\n * @typedef {number} BindingIndex\n * \n * @typedef BindingOptions\n * @property {boolean} inverted\n * \n * @typedef InputReadOnly\n * @property {number} value\n * @property {boolean} polling\n */\n\nclass InputBase\n{\n    get polling()\n    {\n        let dt = performance.now() - this._lastPollingTime;\n        return dt < 1_000;\n    }\n\n    /** @abstract */\n    get value()\n    {\n        return 0;\n    }\n\n    /** @protected */\n    get size()\n    {\n        return this._size;\n    }\n\n    /**\n     * @abstract\n     * @param {number} size The initial binding state size.\n     */\n    constructor(size)\n    {\n        /** @private */\n        this._size = size;\n        /** @private */\n        this._lastPollingTime = Number.MIN_SAFE_INTEGER;\n    }\n\n    /**\n     * Called to internally resize to accomodate more/less\n     * binding states.\n     * \n     * @protected\n     * @param {number} newSize \n     */\n    resize(newSize)\n    {\n        this._size = newSize;\n    }\n\n    /**\n     * @abstract\n     * @param {BindingIndex} code \n     * @returns {number}\n     */\n    // eslint-disable-next-line no-unused-vars\n    getState(code)\n    {\n        throw new Error('Missing implementation.');\n    }\n\n    /**\n     * @abstract\n     * @param {BindingIndex} code \n     * @param {number} value \n     * @param {number} delta \n     */\n    // eslint-disable-next-line no-unused-vars\n    onUpdate(code, value, delta)\n    {\n        throw new Error('Missing implementation.');\n    }\n\n    /**\n     * @abstract\n     * @param {BindingIndex} code \n     * @param {number} value \n     */\n    // eslint-disable-next-line no-unused-vars\n    onStatus(code, value)\n    {\n        throw new Error('Missing implementation.');\n    }\n\n    /**\n     * Called to poll all bound states.\n     * \n     * @param {number} now \n     */\n    onPoll(now)\n    {\n        this._lastPollingTime = now;\n    }\n\n    /**\n     * Called to bind a state to the given binding code.\n     * \n     * @param {BindingIndex} code\n     * @param {BindingOptions} [opts]\n     */\n    // eslint-disable-next-line no-unused-vars\n    onBind(code, opts = {})\n    {\n        if (code >= this._size)\n        {\n            this.resize(code + 1);\n        }\n    }\n\n    /**\n     * Called to unbind all states.\n     */\n    onUnbind()\n    {\n        this.resize(0);\n    }\n}\n\n/**\n * @typedef {import('./InputBase.js').BindingIndex} BindingIndex The binding index\n * @typedef {import('./InputBase.js').BindingOptions} BindingOptions The binding options\n * \n * @typedef AxisBindingState\n * @property {number} value\n * @property {number} delta\n * @property {boolean} inverted\n * \n * @typedef AxisReadOnly\n * @property {number} value\n * @property {number} delta\n * @property {boolean} polling\n */\n\nclass Axis extends InputBase\n{\n    /** @returns {AxisBindingState} */\n    static createAxisBindingState()\n    {\n        return {\n            value: 0,\n            delta: 0,\n            inverted: false,\n        };\n    }\n\n    /** @returns {number} */\n    get delta()\n    {\n        return this._delta;\n    }\n\n    /**\n     * @override\n     * @returns {number}\n     */\n    get value()\n    {\n        return this._value;\n    }\n\n    /**\n     * @param {number} [size] \n     */\n    constructor(size = 0)\n    {\n        super(size);\n        let state = new Array();\n        for(let i = 0; i < size; ++i)\n        {\n            state.push(this.constructor.createAxisBindingState());\n        }\n        /**\n         * @private\n         * @type {Array<AxisBindingState>}\n         */\n        this._state = state;\n        /** @private */\n        this._value = 0;\n        /** @private */\n        this._delta = 0;\n    }\n\n    /**\n     * @override\n     * @protected\n     */\n    resize(newSize)\n    {\n        let oldState = this._state;\n        let oldSize = oldState.length;\n        let newState;\n        if (newSize <= oldSize)\n        {\n            newState = oldState.slice(0, newSize);\n        }\n        else\n        {\n            newState = oldState;\n            // Fill with new states\n            for(let i = oldSize; i < newSize; ++i)\n            {\n                newState.push(this.constructor.createAxisBindingState());\n            }\n        }\n        this._state = newState;\n        super.resize(newSize);\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code\n     * @returns {number}\n     */\n    getState(code)\n    {\n        return this._state[code].value;\n    }\n\n    /**\n     * @override\n     * @param {number} now\n     */\n    onPoll(now)\n    {\n        let state = this._state;\n        let accumulatedValue = 0;\n        let accumulatedDelta = 0;\n        const len = state.length;\n        for(let i = 0; i < len; ++i)\n        {\n            let value = state[i];\n            accumulatedValue += value.value * (value.inverted ? -1 : 1);\n            accumulatedDelta += value.delta;\n            state[i].delta = 0;\n        }\n        this._value = accumulatedValue;\n        this._delta = accumulatedDelta;\n        super.onPoll(now);\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code \n     * @param {number} value \n     * @param {number} delta \n     */\n    onUpdate(code, value, delta)\n    {\n        if (typeof value === 'undefined')\n        {\n            this.onAxisChange(code, delta);\n        }\n        else\n        {\n            this.onAxisMove(code, value, delta);\n        }\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code \n     * @param {number} value \n     */\n    onStatus(code, value)\n    {\n        this.onAxisStatus(code, value);\n    }\n    \n    /**\n     * @override\n     * @param {BindingIndex} code\n     * @param {BindingOptions} [opts]\n     */\n    onBind(code, opts = {})\n    {\n        super.onBind(code, opts);\n        const { inverted = false } = opts;\n        let state = this._state;\n        state[code].inverted = inverted;\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     * @param {number} x \n     * @param {number} dx \n     */\n    onAxisMove(code, x, dx)\n    {\n        let state = this._state[code];\n        state.value = x;\n        state.delta += dx;\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     * @param {number} dx \n     */\n    onAxisChange(code, dx)\n    {\n        let state = this._state[code];\n        state.value += dx;\n        state.delta += dx;\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     * @param {number} x \n     */\n    onAxisStatus(code, x)\n    {\n        let state = this._state[code];\n        let prev = state.value;\n        state.value = x;\n        state.delta = x - prev;\n    }\n}\n\n/**\n * @typedef {import('./InputBase.js').BindingIndex} BindingIndex\n * @typedef {import('./InputBase.js').BindingOptions} BindingOptions\n * \n * @typedef ButtonReadOnly\n * @property {number} value\n * @property {boolean} pressed\n * @property {boolean} repeated\n * @property {boolean} released\n * @property {boolean} down\n * @property {boolean} polling\n */\n\nconst CLEAR_POLL_BITS = 0b1111_0001;\nconst CLEAR_DOWN_STATE_BITS = 0b1111_1110;\nconst CLEAR_INVERTED_MODIFIER_BITS = 0b1110_1111;\n\nconst DOWN_STATE_BIT = 0b0000_0001;\nconst PRESSED_STATE_BIT = 0b0000_0010;\nconst REPEATED_STATE_BIT = 0b0000_0100;\nconst RELEASED_STATE_BIT = 0b0000_1000;\nconst INVERTED_MODIFIER_BIT = 0b0001_0000;\n\nclass Button extends InputBase\n{\n    /** @returns {boolean} */\n    get pressed()\n    {\n        return this._pressed;\n    }\n\n    /** @returns {boolean} */\n    get repeated()\n    {\n        return this._repeated;\n    }\n\n    /** @returns {boolean} */\n    get released()\n    {\n        return this._released;\n    }\n\n    /** @returns {boolean} */\n    get down()\n    {\n        return this._down;\n    }\n\n    /**\n     * @override\n     * @returns {number}\n     */\n    get value()\n    {\n        return this._value;\n    }\n    \n    /**\n     * @param {number} [size] \n     */\n    constructor(size = 0)\n    {\n        super(size);\n        /** @private */\n        this._state = new Uint8Array(size);\n        /** @private */\n        this._value = 0;\n        /** @private */\n        this._down = false;\n        /** @private */\n        this._pressed = false;\n        /** @private */\n        this._repeated = false;\n        /** @private */\n        this._released = false;\n    }\n\n    /**\n     * @override\n     * @protected\n     */\n    resize(newSize)\n    {\n        let oldState = this._state;\n        let oldSize = oldState.length;\n        let newState;\n        if (newSize <= oldSize)\n        {\n            newState = oldState.slice(0, newSize);\n        }\n        else\n        {\n            newState = new Uint8Array(newSize);\n            newState.set(oldState);\n        }\n        this._state = newState;\n        super.resize(newSize);\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code\n     * @returns {number}\n     */\n    getState(code)\n    {\n        let state = this._state[code];\n        let modifier = state & INVERTED_MODIFIER_BIT ? -1 : 1;\n        let value = state & DOWN_STATE_BIT ? 1 : 0;\n        return value * modifier;\n    }\n\n    /**\n     * @override\n     * @param {number} now\n     */\n    onPoll(now)\n    {\n        let state = this._state;\n        let result = 0;\n        let down = 0;\n        let pressed = 0;\n        let repeated = 0;\n        let released = 0;\n        const len = state.length;\n        for(let i = 0; i < len; ++i)\n        {\n            let value = state[i];\n            let v = value & DOWN_STATE_BIT;\n            let m = value & INVERTED_MODIFIER_BIT;\n            down |= v;\n            pressed |= value & PRESSED_STATE_BIT;\n            repeated |= value & REPEATED_STATE_BIT;\n            released |= value & RELEASED_STATE_BIT;\n            result += (v ? 1 : 0) * (m ? -1 : 1);\n            state[i] &= CLEAR_POLL_BITS;\n        }\n        this._value = result;\n        this._down = down !== 0;\n        this._pressed = pressed !== 0;\n        this._repeated = repeated !== 0;\n        this._released = released !== 0;\n        super.onPoll(now);\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code \n     * @param {number} value \n     * @param {number} delta \n     */\n    onUpdate(code, value, delta)\n    {\n        if (delta > 0)\n        {\n            this.onButtonPressed(code);\n        }\n        else\n        {\n            this.onButtonReleased(code);\n        }\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code \n     * @param {number} value \n     */\n    onStatus(code, value)\n    {\n        this.onButtonStatus(code, value !== 0);\n    }\n\n    /**\n     * @override\n     * @param {BindingIndex} code\n     * @param {BindingOptions} [opts]\n     */\n    onBind(code, opts = {})\n    {\n        super.onBind(code, opts);\n        const { inverted = false } = opts;\n        let state = this._state;\n        if (inverted)\n        {\n            state[code] |= INVERTED_MODIFIER_BIT;\n        }\n        else\n        {\n            state[code] &= CLEAR_INVERTED_MODIFIER_BITS;\n        }\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     */\n    onButtonPressed(code)\n    {\n        let state = this._state;\n        let bits = state[code];\n        if (!(bits & DOWN_STATE_BIT))\n        {\n            bits |= PRESSED_STATE_BIT;\n            bits |= DOWN_STATE_BIT;\n        }\n        bits |= REPEATED_STATE_BIT;\n        state[code] = bits;\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     */\n    onButtonReleased(code)\n    {\n        let state = this._state;\n        let bits = state[code];\n        if (bits & DOWN_STATE_BIT)\n        {\n            bits |= RELEASED_STATE_BIT;\n            bits &= CLEAR_DOWN_STATE_BITS;\n        }\n        state[code] = bits;\n    }\n\n    /**\n     * @protected\n     * @param {BindingIndex} code \n     * @param {boolean} isDown\n     */\n    onButtonStatus(code, isDown)\n    {\n        let state = this._state;\n        let bits = state[code];\n        let wasDown = Boolean(bits & DOWN_STATE_BIT);\n        if (isDown)\n        {\n            bits |= DOWN_STATE_BIT;\n        }\n        else\n        {\n            bits &= CLEAR_DOWN_STATE_BITS;\n        }\n        if (wasDown && !isDown)\n        {\n            bits |= RELEASED_STATE_BIT;\n        }\n        if (!wasDown && isDown)\n        {\n            bits |= PRESSED_STATE_BIT;\n            bits |= REPEATED_STATE_BIT;\n        }\n        state[code] = bits;\n    }\n}\n\nclass KeyCode$1 {\n\n    /**\n     * @param {string} string \n     * @returns {KeyCode}\n     */\n    static parse(string) {\n        string = string.trim();\n        let i = string.indexOf('.');\n        if (i < 0) {\n            throw new Error('Missing device separator for key code.');\n        }\n        let device = string.substring(0, i);\n        if (device.length < 0) {\n            throw new Error('Missing device for key code.');\n        }\n        let key = string.substring(i + 1);\n        if (key.length < 0) {\n            throw new Error('Missing code for key code.');\n        }\n        return new KeyCode$1(device, key);\n    }\n\n    /**\n     * @param {string} device \n     * @param {string} code \n     */\n    constructor(device, code) {\n        this.device = device;\n        this.code = code;\n    }\n\n    /** @override */\n    toString() {\n        return `${this.device}.${this.code}`;\n    }\n}\n\nfunction from$1(device, code) {\n    return new KeyCode$1(device, code);\n}\n\nclass InputBinding {\n    \n    /** @returns {boolean} */\n    get polling() {\n        if (!this.ref) {\n            return false;\n        }\n        return this.ref.polling;\n    }\n\n    /** @returns {number} */\n    get value() {\n        if (!this.ref) {\n            return 0;\n        }\n        return this.ref.value;\n    }\n\n    /**\n     * @param {string} name\n     */\n    constructor(name) {\n        /** @protected */\n        this.name = name;\n\n        /** @protected */\n        this.ref = null;\n    }\n\n    /**\n     * @abstract\n     * @param {import('../InputContext.js').InputContext} inputContext \n     */\n    register(inputContext) {\n        throw new Error('Unsupported operation.');\n    }\n\n    /**\n     * @param {number} code \n     * @returns {number}\n     */\n    getState(code) {\n        if (!this.ref) {\n            return 0;\n        }\n        return this.ref.getState(code);\n    }\n}\n\nclass KeyCode {\n\n    /**\n     * @param {string} string \n     * @returns {KeyCode}\n     */\n    static parse(string) {\n        string = string.trim();\n        let i = string.indexOf('.');\n        if (i < 0) {\n            throw new Error('Missing device separator for key code.');\n        }\n        let device = string.substring(0, i);\n        if (device.length < 0) {\n            throw new Error('Missing device for key code.');\n        }\n        let key = string.substring(i + 1);\n        if (key.length < 0) {\n            throw new Error('Missing code for key code.');\n        }\n        return new KeyCode(device, key);\n    }\n\n    /**\n     * @param {string} device \n     * @param {string} code \n     */\n    constructor(device, code) {\n        this.device = device;\n        this.code = code;\n    }\n\n    /** @override */\n    toString() {\n        return `${this.device}.${this.code}`;\n    }\n}\n\nfunction from(device, code) {\n    return new KeyCode(device, code);\n}\n\nfunction isKeyCode(object) {\n    return 'device' in object && 'code' in object;\n}\n\nconst KEYBOARD = 'Keyboard';\nconst MOUSE = 'Mouse';\n\nconst KEY_A = new KeyCode(KEYBOARD, 'KeyA');\nconst KEY_B = new KeyCode(KEYBOARD, 'KeyB');\nconst KEY_C = new KeyCode(KEYBOARD, 'KeyC');\nconst KEY_D = new KeyCode(KEYBOARD, 'KeyD');\nconst KEY_E = new KeyCode(KEYBOARD, 'KeyE');\nconst KEY_F = new KeyCode(KEYBOARD, 'KeyF');\nconst KEY_G = new KeyCode(KEYBOARD, 'KeyG');\nconst KEY_H = new KeyCode(KEYBOARD, 'KeyH');\nconst KEY_I = new KeyCode(KEYBOARD, 'KeyI');\nconst KEY_J = new KeyCode(KEYBOARD, 'KeyJ');\nconst KEY_K = new KeyCode(KEYBOARD, 'KeyK');\nconst KEY_L = new KeyCode(KEYBOARD, 'KeyL');\nconst KEY_M = new KeyCode(KEYBOARD, 'KeyM');\nconst KEY_N = new KeyCode(KEYBOARD, 'KeyN');\nconst KEY_O = new KeyCode(KEYBOARD, 'KeyO');\nconst KEY_P = new KeyCode(KEYBOARD, 'KeyP');\nconst KEY_Q = new KeyCode(KEYBOARD, 'KeyQ');\nconst KEY_R = new KeyCode(KEYBOARD, 'KeyR');\nconst KEY_S = new KeyCode(KEYBOARD, 'KeyS');\nconst KEY_T = new KeyCode(KEYBOARD, 'KeyT');\nconst KEY_U = new KeyCode(KEYBOARD, 'KeyU');\nconst KEY_V = new KeyCode(KEYBOARD, 'KeyV');\nconst KEY_W = new KeyCode(KEYBOARD, 'KeyW');\nconst KEY_X = new KeyCode(KEYBOARD, 'KeyX');\nconst KEY_Y = new KeyCode(KEYBOARD, 'KeyY');\nconst KEY_Z = new KeyCode(KEYBOARD, 'KeyZ');\n\nconst DIGIT_0 = new KeyCode(KEYBOARD, 'Digit0');\nconst DIGIT_1 = new KeyCode(KEYBOARD, 'Digit1');\nconst DIGIT_2 = new KeyCode(KEYBOARD, 'Digit2');\nconst DIGIT_3 = new KeyCode(KEYBOARD, 'Digit3');\nconst DIGIT_4 = new KeyCode(KEYBOARD, 'Digit4');\nconst DIGIT_5 = new KeyCode(KEYBOARD, 'Digit5');\nconst DIGIT_6 = new KeyCode(KEYBOARD, 'Digit6');\nconst DIGIT_7 = new KeyCode(KEYBOARD, 'Digit7');\nconst DIGIT_8 = new KeyCode(KEYBOARD, 'Digit8');\nconst DIGIT_9 = new KeyCode(KEYBOARD, 'Digit9');\n\nconst MINUS = new KeyCode(KEYBOARD, 'Minus');\nconst EQUAL = new KeyCode(KEYBOARD, 'Equal');\nconst BRACKET_LEFT = new KeyCode(KEYBOARD, 'BracketLeft');\nconst BRACKET_RIGHT = new KeyCode(KEYBOARD, 'BracketRight');\nconst SEMICOLON = new KeyCode(KEYBOARD, 'Semicolon');\nconst QUOTE = new KeyCode(KEYBOARD, 'Quote');\nconst BACKQUOTE = new KeyCode(KEYBOARD, 'Backquote');\nconst BACKSLASH = new KeyCode(KEYBOARD, 'Backslash');\nconst COMMA = new KeyCode(KEYBOARD, 'Comma');\nconst PERIOD = new KeyCode(KEYBOARD, 'Period');\nconst SLASH = new KeyCode(KEYBOARD, 'Slash');\n\nconst ESCAPE = new KeyCode(KEYBOARD, 'Escape');\nconst SPACE = new KeyCode(KEYBOARD, 'Space');\nconst CAPS_LOCK = new KeyCode(KEYBOARD, 'CapsLock');\nconst BACKSPACE = new KeyCode(KEYBOARD, 'Backspace');\nconst DELETE = new KeyCode(KEYBOARD, 'Delete');\nconst TAB = new KeyCode(KEYBOARD, 'Tab');\nconst ENTER = new KeyCode(KEYBOARD, 'Enter');\n\nconst ARROW_UP = new KeyCode(KEYBOARD, 'ArrowUp');\nconst ARROW_DOWN = new KeyCode(KEYBOARD, 'ArrowDown');\nconst ARROW_LEFT = new KeyCode(KEYBOARD, 'ArrowLeft');\nconst ARROW_RIGHT = new KeyCode(KEYBOARD, 'ArrowRight');\n\nconst MOUSE_BUTTON_0 = new KeyCode(MOUSE, 'Button0');\nconst MOUSE_BUTTON_1 = new KeyCode(MOUSE, 'Button1');\nconst MOUSE_BUTTON_2 = new KeyCode(MOUSE, 'Button2');\nconst MOUSE_BUTTON_3 = new KeyCode(MOUSE, 'Button3');\nconst MOUSE_BUTTON_4 = new KeyCode(MOUSE, 'Button4');\n\nconst MOUSE_POS_X = new KeyCode(MOUSE, 'PosX');\nconst MOUSE_POS_Y = new KeyCode(MOUSE, 'PosY');\n\nconst MOUSE_WHEEL_X = new KeyCode(MOUSE, 'WheelX');\nconst MOUSE_WHEEL_Y = new KeyCode(MOUSE, 'WheelY');\nconst MOUSE_WHEEL_Z = new KeyCode(MOUSE, 'WheelZ');\n\nvar KeyCodes = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    from: from,\n    isKeyCode: isKeyCode,\n    KEYBOARD: KEYBOARD,\n    MOUSE: MOUSE,\n    KEY_A: KEY_A,\n    KEY_B: KEY_B,\n    KEY_C: KEY_C,\n    KEY_D: KEY_D,\n    KEY_E: KEY_E,\n    KEY_F: KEY_F,\n    KEY_G: KEY_G,\n    KEY_H: KEY_H,\n    KEY_I: KEY_I,\n    KEY_J: KEY_J,\n    KEY_K: KEY_K,\n    KEY_L: KEY_L,\n    KEY_M: KEY_M,\n    KEY_N: KEY_N,\n    KEY_O: KEY_O,\n    KEY_P: KEY_P,\n    KEY_Q: KEY_Q,\n    KEY_R: KEY_R,\n    KEY_S: KEY_S,\n    KEY_T: KEY_T,\n    KEY_U: KEY_U,\n    KEY_V: KEY_V,\n    KEY_W: KEY_W,\n    KEY_X: KEY_X,\n    KEY_Y: KEY_Y,\n    KEY_Z: KEY_Z,\n    DIGIT_0: DIGIT_0,\n    DIGIT_1: DIGIT_1,\n    DIGIT_2: DIGIT_2,\n    DIGIT_3: DIGIT_3,\n    DIGIT_4: DIGIT_4,\n    DIGIT_5: DIGIT_5,\n    DIGIT_6: DIGIT_6,\n    DIGIT_7: DIGIT_7,\n    DIGIT_8: DIGIT_8,\n    DIGIT_9: DIGIT_9,\n    MINUS: MINUS,\n    EQUAL: EQUAL,\n    BRACKET_LEFT: BRACKET_LEFT,\n    BRACKET_RIGHT: BRACKET_RIGHT,\n    SEMICOLON: SEMICOLON,\n    QUOTE: QUOTE,\n    BACKQUOTE: BACKQUOTE,\n    BACKSLASH: BACKSLASH,\n    COMMA: COMMA,\n    PERIOD: PERIOD,\n    SLASH: SLASH,\n    ESCAPE: ESCAPE,\n    SPACE: SPACE,\n    CAPS_LOCK: CAPS_LOCK,\n    BACKSPACE: BACKSPACE,\n    DELETE: DELETE,\n    TAB: TAB,\n    ENTER: ENTER,\n    ARROW_UP: ARROW_UP,\n    ARROW_DOWN: ARROW_DOWN,\n    ARROW_LEFT: ARROW_LEFT,\n    ARROW_RIGHT: ARROW_RIGHT,\n    MOUSE_BUTTON_0: MOUSE_BUTTON_0,\n    MOUSE_BUTTON_1: MOUSE_BUTTON_1,\n    MOUSE_BUTTON_2: MOUSE_BUTTON_2,\n    MOUSE_BUTTON_3: MOUSE_BUTTON_3,\n    MOUSE_BUTTON_4: MOUSE_BUTTON_4,\n    MOUSE_POS_X: MOUSE_POS_X,\n    MOUSE_POS_Y: MOUSE_POS_Y,\n    MOUSE_WHEEL_X: MOUSE_WHEEL_X,\n    MOUSE_WHEEL_Y: MOUSE_WHEEL_Y,\n    MOUSE_WHEEL_Z: MOUSE_WHEEL_Z\n});\n\n/**\n * @param {string|Array<string>} strings\n * @returns {Array<KeyCode>}\n */\nfunction stringsToKeyCodes(strings) {\n    if (!Array.isArray(strings)) {\n        strings = [strings];\n    }\n    let result = [];\n    for(let str of strings) {\n        let keyCode;\n        try {\n            keyCode = KeyCode.parse(str);\n        } catch (e) {\n            let keyName = camelToSnakeCase(str).toUpperCase();\n            if (!(keyName in KeyCodes)) {\n                throw new Error('Invalid key code string - ' + e);\n            }\n            keyCode = KeyCodes[keyName];\n        }\n        result.push(keyCode);\n    }\n    return result;\n}\n\n/**\n * @param {string} str \n * @returns {string}\n */\nfunction camelToSnakeCase(str) {\n    return str.replace(/([a-z]|(?:[A-Z0-9]+))([A-Z0-9]|$)/g, function(_, a, b) {\n        return a + (b && '_' + b);\n    }).toLowerCase();\n}\n\n/** @typedef {import('../keycode/KeyCode.js').KeyCode} KeyCode */\n\nclass AxisBinding extends InputBinding {\n\n    /**\n     * @param {string} name \n     * @param {string} device \n     * @param {string} code \n     * @param {object} [opts]\n     * @returns {AxisBinding}\n     */\n    static fromBind(name, device, code, opts = undefined) {\n        return new AxisBinding(name, from$1(device, code), opts);\n    }\n\n    /**\n     * @param {string} name\n     * @param {...string} strings\n     * @returns {AxisBinding}\n     */\n    static fromString(name, ...strings) {\n        let keyCodes = stringsToKeyCodes(strings);\n        return new AxisBinding(name, keyCodes);\n    }\n    \n    /** @returns {number} */\n    get delta() {\n        if (!this.ref) {\n            return 0;\n        }\n        return this.ref.delta;\n    }\n\n    /**\n     * @param {string} name \n     * @param {KeyCode|Array<KeyCode>} keyCodes\n     * @param {object} [opts] \n     */\n    constructor(name, keyCodes, opts = undefined) {\n        super(name);\n\n        /** @protected */\n        this.keyCodes = Array.isArray(keyCodes) ? keyCodes : [keyCodes];\n        /** @protected */\n        this.opts = opts;\n    }\n\n    /**\n     * @override\n     * @param {import('../InputContext.js').InputContext} inputContext \n     */\n    register(inputContext) {\n        let name = this.name;\n        let opts = this.opts;\n        for(let keyCode of this.keyCodes) {\n            inputContext.bindAxis(name, keyCode.device, keyCode.code, opts);\n        }\n        this.ref = inputContext.getAxis(name);\n        return this;\n    }\n}\n\n/** @typedef {import('../keycode/KeyCode.js').KeyCode} KeyCode */\n\nclass ButtonBinding extends InputBinding {\n\n    /**\n     * @param {string} name \n     * @param {string} device \n     * @param {string} code \n     * @param {object} [opts]\n     * @returns {ButtonBinding}\n     */\n    static fromBind(name, device, code, opts = undefined) {\n        return new ButtonBinding(name, from(device, code), opts);\n    }\n\n    /**\n     * @param {string} name\n     * @param {...string} strings\n     * @returns {ButtonBinding}\n     */\n    static fromString(name, ...strings) {\n        let keyCodes = stringsToKeyCodes(strings);\n        return new ButtonBinding(name, keyCodes);\n    }\n    \n    /** @returns {boolean} */\n    get pressed() {\n        if (!this.ref) {\n            return false;\n        }\n        return this.ref.pressed;\n    }\n\n    /** @returns {boolean} */\n    get repeated() {\n        if (!this.ref) {\n            return false;\n        }\n        return this.ref.repeated;\n    }\n\n    /** @returns {boolean} */\n    get released() {\n        if (!this.ref) {\n            return false;\n        }\n        return this.ref.released;\n    }\n\n    /** @returns {boolean} */\n    get down() {\n        if (!this.ref) {\n            return false;\n        }\n        return this.ref.down;\n    }\n\n    /**\n     * @param {string} name \n     * @param {KeyCode|Array<KeyCode>} keyCodes\n     * @param {object} [opts] \n     */\n    constructor(name, keyCodes, opts = undefined) {\n        super(name);\n\n        /** @protected */\n        this.keyCodes = Array.isArray(keyCodes) ? keyCodes : [keyCodes];\n        /** @protected */\n        this.opts = opts;\n    }\n\n    /**\n     * @override\n     * @param {import('../InputContext.js').InputContext} inputContext \n     */\n    register(inputContext) {\n        let name = this.name;\n        let opts = this.opts;\n        for(let keyCode of this.keyCodes) {\n            inputContext.bindButton(name, keyCode.device, keyCode.code, opts);\n        }\n        this.ref = inputContext.getButton(name);\n        return this;\n    }\n}\n\n/** @typedef {import('../keycode/KeyCode.js').KeyCode} KeyCode */\n\nclass AxisButtonBinding extends AxisBinding {\n    \n    /**\n     * @param {string} name\n     * @param {string} device\n     * @param {string} negativeCode\n     * @param {string} positiveCode\n     * @returns {AxisButtonBinding}\n     */\n    static fromBind(name, device, negativeCode, positiveCode) {\n        return new AxisButtonBinding(name, from(device, negativeCode), from(device, positiveCode));\n    }\n\n    /**\n     * @param {string} name\n     * @param {KeyCode} negativeKeyCode\n     * @param {KeyCode} positiveKeyCode\n     */\n    constructor(name, negativeKeyCode, positiveKeyCode) {\n        super(name);\n\n        if (negativeKeyCode.device !== positiveKeyCode.device) {\n            throw new Error('Cannot create axis-button codes for different devices.');\n        }\n        \n        /** @protected */\n        this.negativeKeyCode = negativeKeyCode;\n        /** @protected */\n        this.positiveKeyCode = positiveKeyCode;\n    }\n\n    /**\n     * @param {import('../InputContext.js').InputContext} inputContext \n     */\n    register(inputContext) {\n        let name = this.name;\n        let negativeKeyCode = this.negativeKeyCode;\n        let positiveKeyCode = this.positiveKeyCode;\n        inputContext.bindAxisButtons(name, negativeKeyCode.device, negativeKeyCode.code, positiveKeyCode.code);\n        this.ref = inputContext.getAxis(name);\n        return this;\n    }\n}\n\n/**\n * @typedef InputDeviceEvent\n * @property {EventTarget} target\n * @property {string} device\n * @property {string} code\n * @property {string} event\n * @property {number} [value] The input value of the triggered event (usually this is 1).\n * @property {number} [movement] The change in value for the triggered event.\n * @property {boolean} [control] Whether any control keys are down (false if up).\n * @property {boolean} [shift] Whether any shift keys are down (false if up).\n * @property {boolean} [alt] Whether any alt keys are down (false if up).\n * \n * @callback InputDeviceEventListener\n * @param {InputDeviceEvent} e\n */\n\n/**\n * A class that represents a raw system device that\n * emits input events.\n */\nclass InputDevice\n{\n    /** @abstract */\n    // eslint-disable-next-line no-unused-vars\n    static isAxis(code)\n    {\n        return false;\n    }\n\n    /** @abstract */\n    // eslint-disable-next-line no-unused-vars\n    static isButton(code)\n    {\n        return false;\n    }\n\n    /**\n     * @param {string} deviceName \n     * @param {EventTarget} eventTarget \n     */\n    constructor(deviceName, eventTarget)\n    {\n        if (!eventTarget)\n        {\n            throw new Error(`Missing event target for device ${deviceName}.`);\n        }\n\n        this.name = deviceName;\n        this.eventTarget = eventTarget;\n\n        /**\n         * @private\n         * @type {Record<string, Array<InputDeviceEventListener>>}\n         */\n        this.listeners = {\n            input: []\n        };\n    }\n\n    /**\n     * @param {EventTarget} eventTarget \n     */\n    setEventTarget(eventTarget)\n    {\n        if (!eventTarget)\n        {\n            throw new Error(`Missing event target for device ${this.name}.`);\n        }\n        this.eventTarget = eventTarget;\n    }\n\n    destroy()\n    {\n        let listeners = this.listeners;\n        for(let event in listeners)\n        {\n            listeners[event].length = 0;\n        }\n    }\n\n    /**\n     * @param {string} event \n     * @param {InputDeviceEventListener} listener \n     */\n    addEventListener(event, listener)\n    {\n        let listeners = this.listeners;\n        if (event in listeners)\n        {\n            listeners[event].push(listener);\n        }\n        else\n        {\n            listeners[event] = [listener];\n        }\n    }\n\n    /**\n     * @param {string} event \n     * @param {InputDeviceEventListener} listener \n     */\n    removeEventListener(event, listener)\n    {\n        let listeners = this.listeners;\n        if (event in listeners)\n        {\n            let list = listeners[event];\n            let i = list.indexOf(listener);\n            if (i >= 0)\n            {\n                list.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * @param {InputDeviceEvent} e\n     * @returns {boolean} Whether the input event should be consumed.\n     */\n    dispatchInputEvent(e)\n    {\n        let flag = 0;\n        for(let listener of this.listeners.input)\n        {\n            flag |= listener(e);\n        }\n        return Boolean(flag);\n    }\n}\n\n/** @typedef {import('./InputDevice.js').InputDeviceEvent} InputDeviceEvent */\n\n/**\n * A class that listens to the keyboard events from the event target and\n * transforms the events into a valid {@link InputEvent} for the added\n * listeners.\n * \n * - This device uses the `event.code` standard to reference each key.\n * - Use this to help you determine the key code: https://keycode.info/\n */\nclass KeyboardDevice extends InputDevice\n{\n    /** @override */\n    // eslint-disable-next-line no-unused-vars\n    static isAxis(keyCode)\n    {\n        return false;\n    }\n\n    /** @override */\n    // eslint-disable-next-line no-unused-vars\n    static isButton(keyCode)\n    {\n        return true;\n    }\n\n    /**\n     * Constructs a listening keyboard with no listeners (yet).\n     * \n     * @param {string} deviceName\n     * @param {EventTarget} eventTarget \n     * @param {object} [opts] Any additional options.\n     * @param {boolean} [opts.ignoreRepeat] Whether to\n     * accept repeated key events.\n     */\n    constructor(deviceName, eventTarget, opts = {})\n    {\n        super(deviceName, eventTarget);\n\n        const { ignoreRepeat = true } = opts;\n        this.ignoreRepeat = ignoreRepeat;\n\n        /**\n         * @private\n         * @type {InputDeviceEvent}\n         */\n        this._eventObject = {\n            target: eventTarget,\n            device: deviceName,\n            code: '',\n            event: '',\n            // Key values\n            value: 0,\n            control: false,\n            shift: false,\n            alt: false,\n        };\n\n        /** @private */\n        this.onKeyDown = this.onKeyDown.bind(this);\n        /** @private */\n        this.onKeyUp = this.onKeyUp.bind(this);\n\n        eventTarget.addEventListener('keydown', this.onKeyDown);\n        eventTarget.addEventListener('keyup', this.onKeyUp);\n    }\n\n    /** @override */\n    setEventTarget(eventTarget)\n    {\n        if (this.eventTarget) this.destroy();\n        super.setEventTarget(eventTarget);\n        eventTarget.addEventListener('keydown', this.onKeyDown);\n        eventTarget.addEventListener('keyup', this.onKeyUp);\n    }\n\n    /** @override */\n    destroy()\n    {\n        let eventTarget = this.eventTarget;\n        eventTarget.removeEventListener('keydown', this.onKeyDown);\n        eventTarget.removeEventListener('keyup', this.onKeyUp);\n        super.destroy();\n    }\n\n    /**\n     * @private\n     * @param {KeyboardEvent} e\n     */\n    onKeyDown(e)\n    {\n        if (e.repeat && this.ignoreRepeat)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n\n        let event = this._eventObject;\n        // We care more about location (code) than print char (key).\n        event.code = e.code;\n        event.event = 'pressed';\n        event.value = 1;\n        event.control = e.ctrlKey;\n        event.shift = e.shiftKey;\n        event.alt = e.altKey;\n\n        let result = this.dispatchInputEvent(event);\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n    }\n\n    /**\n     * @private\n     * @param {KeyboardEvent} e\n     */\n    onKeyUp(e)\n    {\n        /** @type {InputDeviceEvent} */\n        let event = this._eventObject;\n        // We care more about location (code) than print char (key).\n        event.code = e.code;\n        event.event = 'released';\n        event.value = 1;\n        event.control = e.ctrlKey;\n        event.shift = e.shiftKey;\n        event.alt = e.altKey;\n\n        let result = this.dispatchInputEvent(event);\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n    }\n}\n\n/**\n * @typedef {import('./InputDevice.js').InputDeviceEvent} InputDeviceEvent\n */\n\nconst DEFAULT_LINE_PIXELS = 10;\nconst DEFAULT_PAGE_PIXELS = 100;\n\n/**\n * A class that listens to the mouse events from the event target and\n * transforms the events into a valid {@link InputDeviceEvent} for its\n * listeners.\n * \n * - PosX\n * - PosY\n * - WheelX\n * - WheelY\n * - WheelZ\n * - Button0 (left button)\n * - Button1 (middle button)\n * - Button2 (right button)\n * - Button3 (next button)\n * - Button4 (back button)\n */\nclass MouseDevice extends InputDevice\n{\n    /** @override */\n    static isAxis(keyCode)\n    {\n        return keyCode === 'PosX'\n            || keyCode === 'PosY'\n            || keyCode === 'WheelX'\n            || keyCode === 'WheelY'\n            || keyCode === 'WheelZ';\n    }\n\n    /** @override */\n    static isButton(keyCode)\n    {\n        return !this.isAxis(keyCode);\n    }\n\n    /**\n     * Constructs a listening mouse with no listeners (yet).\n     * \n     * @param {string} deviceName\n     * @param {EventTarget} eventTarget\n     * @param {Object} [opts] Any additional options.\n     * @param {Boolean} [opts.eventsOnFocus=true] Whether to capture events only when it has focus.\n     */\n    constructor(deviceName, eventTarget, opts = {})\n    {\n        super(deviceName, eventTarget);\n\n        const { eventsOnFocus = true } = opts;\n        this.eventsOnFocus = eventsOnFocus;\n        this.canvasTarget = this.getCanvasFromEventTarget(eventTarget);\n\n        /** @private */\n        this._downHasFocus = false;\n\n        /**\n         * @private\n         * @type {InputDeviceEvent}\n         */\n        this._eventObject = {\n            target: eventTarget,\n            device: deviceName,\n            code: '',\n            event: '',\n            // Button values\n            value: 0,\n            control: false,\n            shift: false,\n            alt: false,\n        };\n        /**\n         * @private\n         * @type {InputDeviceEvent}\n         */\n        this._positionObject = {\n            target: eventTarget,\n            device: deviceName,\n            code: '',\n            event: 'move',\n            // Pos values\n            value: 0,\n            movement: 0,\n        };\n        /**\n         * @private\n         * @type {InputDeviceEvent}\n         */\n        this._wheelObject = {\n            target: eventTarget,\n            device: deviceName,\n            code: '',\n            event: 'wheel',\n            // Wheel values\n            movement: 0,\n        };\n\n        /** @private */\n        this.onMouseDown = this.onMouseDown.bind(this);\n        /** @private */\n        this.onMouseUp = this.onMouseUp.bind(this);\n        /** @private */\n        this.onMouseMove = this.onMouseMove.bind(this);\n        /** @private */\n        this.onContextMenu = this.onContextMenu.bind(this);\n        /** @private */\n        this.onWheel = this.onWheel.bind(this);\n        \n        eventTarget.addEventListener('mousedown', this.onMouseDown);\n        eventTarget.addEventListener('contextmenu', this.onContextMenu);\n        eventTarget.addEventListener('wheel', this.onWheel);\n        document.addEventListener('mousemove', this.onMouseMove);\n        document.addEventListener('mouseup', this.onMouseUp);\n    }\n\n    /** @override */\n    setEventTarget(eventTarget)\n    {\n        if (this.eventTarget) this.destroy();\n        super.setEventTarget(eventTarget);\n        this.canvasTarget = this.getCanvasFromEventTarget(eventTarget);\n        eventTarget.addEventListener('mousedown', this.onMouseDown);\n        eventTarget.addEventListener('contextmenu', this.onContextMenu);\n        eventTarget.addEventListener('wheel', this.onWheel);\n        document.addEventListener('mousemove', this.onMouseMove);\n        document.addEventListener('mouseup', this.onMouseUp);\n    }\n\n    /** @override */\n    destroy()\n    {\n        let eventTarget = this.eventTarget;\n        eventTarget.removeEventListener('mousedown', this.onMouseDown);\n        eventTarget.removeEventListener('contextmenu', this.onContextMenu);\n        eventTarget.removeEventListener('wheel', this.onWheel);\n        document.removeEventListener('mousemove', this.onMouseMove);\n        document.removeEventListener('mouseup', this.onMouseUp);\n        super.destroy();\n    }\n\n    setPointerLock(force = true)\n    {\n        if (force)\n        {\n            this.eventTarget.requestPointerLock();\n        }\n        else\n        {\n            this.eventTarget.exitPointerLock();\n        }\n    }\n\n    hasPointerLock()\n    {\n        return document.pointerLockElement === this.eventTarget;\n    }\n\n    /**\n     * @private\n     * @param {MouseEvent} e\n     */\n    onMouseDown(e)\n    {\n        this._downHasFocus = true;\n\n        let event = this._eventObject;\n        // We care more about location (code) than print char (key).\n        event.code = 'Button' + e.button;\n        event.event = 'pressed';\n        event.value = 1;\n        event.control = e.ctrlKey;\n        event.shift = e.shiftKey;\n        event.alt = e.altKey;\n\n        let result = this.dispatchInputEvent(event);\n        if (result)\n        {\n            // Make sure it has focus first.\n            if (document.activeElement === this.eventTarget)\n            {\n                e.preventDefault();\n                e.stopPropagation();\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @private\n     * @param {MouseEvent} e\n     */\n    onContextMenu(e)\n    {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    /**\n     * @private\n     * @param {WheelEvent} e\n     */\n    onWheel(e)\n    {\n        let dx, dy, dz;\n        switch(e.deltaMode)\n        {\n            case WheelEvent.DOM_DELTA_LINE:\n                dx = e.deltaX * DEFAULT_LINE_PIXELS;\n                dy = e.deltaY * DEFAULT_LINE_PIXELS;\n                dz = e.deltaZ * DEFAULT_LINE_PIXELS;\n                break;\n            case WheelEvent.DOM_DELTA_PAGE:\n                dx = e.deltaX * DEFAULT_PAGE_PIXELS;\n                dy = e.deltaY * DEFAULT_PAGE_PIXELS;\n                dz = e.deltaZ * DEFAULT_PAGE_PIXELS;\n                break;\n            case WheelEvent.DOM_DELTA_PIXEL:\n            default:\n                dx = e.deltaX;\n                dy = e.deltaY;\n                dz = e.deltaZ;\n                break;\n        }\n\n        let result = 0;\n        let event = this._wheelObject;\n        event.code = 'WheelX';\n        event.movement = dx;\n        result |= this.dispatchInputEvent(event);\n        event.code = 'WheelY';\n        event.movement = dy;\n        result |= this.dispatchInputEvent(event);\n        event.code = 'WheelZ';\n        event.movement = dz;\n        result |= this.dispatchInputEvent(event);\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n    }\n\n    /**\n     * @private\n     * @param {MouseEvent} e\n     */\n    onMouseUp(e)\n    {\n        // Make sure mouse down was pressed before this (with focus).\n        if (!this._downHasFocus) return;\n        this._downHasFocus = false;\n\n        let event = this._eventObject;\n        // We care more about location (code) than print char (key).\n        event.code = 'Button' + e.button;\n        event.event = 'released';\n        event.value = 1;\n        event.control = e.ctrlKey;\n        event.shift = e.shiftKey;\n        event.alt = e.altKey;\n\n        let result = this.dispatchInputEvent(event);\n        if (result)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }\n    }\n\n    /**\n     * @private\n     * @param {MouseEvent} e\n     */\n    onMouseMove(e)\n    {\n        if (this.eventsOnFocus && document.activeElement !== this.eventTarget) return;\n\n        const element = this.canvasTarget;\n        const { clientWidth, clientHeight } = element;\n        const rect = element.getBoundingClientRect();\n    \n        let dx = e.movementX / clientWidth;\n        let dy = e.movementY / clientHeight;\n        let x = (e.clientX - rect.left) / clientWidth;\n        let y = (e.clientY - rect.top) / clientHeight;\n    \n        let event = this._positionObject;\n        event.code = 'PosX';\n        event.value = x;\n        event.movement = dx;\n        this.dispatchInputEvent(event);\n        event.code = 'PosY';\n        event.value = y;\n        event.movement = dy;\n        this.dispatchInputEvent(event);\n    }\n    \n    /** @private */\n    getCanvasFromEventTarget(eventTarget)\n    {\n        if (eventTarget instanceof HTMLCanvasElement)\n        {\n            return eventTarget;\n        }\n        else\n        {\n            return eventTarget.canvas\n                || eventTarget.querySelector('canvas')\n                || (eventTarget.shadowRoot && eventTarget.shadowRoot.querySelector('canvas'))\n                || eventTarget;\n        }\n    }\n}\n\nvar INNER_HTML$1 = \"<kbd>\\n    <span id=\\\"name\\\"><slot></slot></span>\\n    <span id=\\\"value\\\" class=\\\"hidden\\\"></span>\\n</kbd>\\n\";\n\nvar INNER_STYLE$1 = \"kbd {\\n    position: relative;\\n    display: inline-block;\\n    border-radius: 3px;\\n    border: 1px solid #888888;\\n    font-size: 0.85em;\\n    font-weight: 700;\\n    text-rendering: optimizeLegibility;\\n    line-height: 12px;\\n    height: 14px;\\n    padding: 2px 4px;\\n    color: #444444;\\n    background-color: #eeeeee;\\n    box-shadow: inset 0 -3px 0 #aaaaaa;\\n    overflow: hidden;\\n}\\n\\nkbd:empty::after {\\n    content: \\\"<?>\\\";\\n    opacity: 0.6;\\n}\\n\\n.disabled {\\n    opacity: 0.6;\\n    box-shadow: none;\\n    background-color: #aaaaaa;\\n}\\n\\n.hidden {\\n    display: none;\\n}\\n\\n#value {\\n    position: absolute;\\n    top: 0;\\n    bottom: 0;\\n    right: 0;\\n    font-size: 0.85em;\\n    padding: 0 4px;\\n    padding-top: 2px;\\n    color: #cccccc;\\n    background-color: #333333;\\n    box-shadow: inset 0 3px 0 #222222;\\n}\\n\";\n\nclass InputCode extends HTMLElement\n{\n    /** @protected */\n    static get [Symbol.for('templateNode')]()\n    {\n        let t = document.createElement('template');\n        t.innerHTML = INNER_HTML$1;\n        Object.defineProperty(this, Symbol.for('templateNode'), { value: t });\n        return t;\n    }\n\n    /** @protected */\n    static get [Symbol.for('styleNode')]()\n    {\n        let t = document.createElement('style');\n        t.innerHTML = INNER_STYLE$1;\n        Object.defineProperty(this, Symbol.for('styleNode'), { value: t });\n        return t;\n    }\n\n    static define(customElements = window.customElements)\n    {\n        customElements.define('input-code', this);\n    }\n\n    /** @override */\n    static get observedAttributes()\n    {\n        return [\n            'name',\n            'value',\n            'disabled'\n        ];\n    }\n    \n    /** @returns {boolean} */\n    get disabled()\n    {\n        return this._disabled;\n    }\n\n    set disabled(value)\n    {\n        this.toggleAttribute('disabled', value);\n    }\n\n    /** @returns {string} */\n    get value()\n    {\n        return this._value;\n    }\n\n    set value(value)\n    {\n        this.setAttribute('value', value);\n    }\n\n    /** @returns {string} */\n    get name()\n    {\n        return this._name;\n    }\n\n    set name(value)\n    {\n        this.setAttribute('name', value);\n    }\n\n    constructor()\n    {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('templateNode')].content.cloneNode(true));\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('styleNode')].cloneNode(true));\n\n        /** @private */\n        this._name = '';\n        /** @private */\n        this._value = '';\n        /** @private */\n        this._disabled = false;\n\n        /** @private */\n        this._kbdElement = this.shadowRoot.querySelector('kbd');\n        /** @private */\n        this._nameElement = this.shadowRoot.querySelector('#name');\n        /** @private */\n        this._valueElement = this.shadowRoot.querySelector('#value');\n    }\n\n    /** @override */\n    attributeChangedCallback(attribute, prev, value)\n    {\n        switch (attribute)\n        {\n            case 'name':\n                this._name = value;\n                this._nameElement.textContent = value;\n                break;\n            case 'value':\n                this._value = value;\n                if (value !== null)\n                {\n                    this._valueElement.classList.toggle('hidden', false);\n                    this._valueElement.textContent = value;\n                    this._kbdElement.style.paddingRight = `${this._valueElement.clientWidth + 4}px`;\n                }\n                else\n                {\n                    this._valueElement.classList.toggle('hidden', true);\n                }\n                break;\n            case 'disabled':\n                this._disabled = value !== null;\n                this._kbdElement.classList.toggle('disabled', value !== null);\n                break;\n        }\n    }\n\n    /** @override */\n    connectedCallback()\n    {\n        if (Object.prototype.hasOwnProperty.call(this, 'name'))\n        {\n            let value = this.name;\n            delete this.name;\n            this.name = value;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this, 'value'))\n        {\n            let value = this.value;\n            delete this.value;\n            this.value = value;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this, 'disabled'))\n        {\n            let value = this.disabled;\n            delete this.disabled;\n            this.disabled = value;\n        }\n    }\n}\nInputCode.define();\n\nvar INNER_HTML = \"<table>\\n    <thead>\\n        <tr class=\\\"tableHeader\\\">\\n            <th colspan=3>\\n                <span class=\\\"tableTitle\\\">\\n                    <label id=\\\"title\\\">\\n                        input-source\\n                    </label>\\n                    <span id=\\\"slotContainer\\\">\\n                        <slot></slot>\\n                    </span>\\n                    <p>\\n                        <label for=\\\"poll\\\">poll</label>\\n                        <output id=\\\"poll\\\"></output>\\n                    </p>\\n                    <p>\\n                        <label for=\\\"focus\\\">focus</label>\\n                        <output id=\\\"focus\\\"></output>\\n                    </p>\\n                </span>\\n            </th>\\n        </tr>\\n        <tr class=\\\"colHeader\\\">\\n            <th>name</th>\\n            <th>value</th>\\n            <th>key</th>\\n        </tr>\\n    </thead>\\n    <tbody>\\n    </tbody>\\n</table>\\n\";\n\nvar INNER_STYLE = \":host {\\n    display: block;\\n}\\n\\ntable {\\n    border-collapse: collapse;\\n    font-family: monospace;\\n}\\n\\ntable,\\nth,\\ntd {\\n    border: 1px solid #666666;\\n}\\n\\nth,\\ntd {\\n    padding: 5px 10px;\\n}\\n\\ntd {\\n    text-align: center;\\n}\\n\\nthead th {\\n    padding: 0;\\n}\\n\\n.colHeader > th {\\n    font-size: 0.8em;\\n    padding: 0 10px;\\n    letter-spacing: 3px;\\n    background-color: #aaaaaa;\\n    color: #666666;\\n}\\n\\ntbody output {\\n    border-radius: 0.3em;\\n    padding: 3px;\\n}\\n\\ntr:not(.primary) .name,\\ntr:not(.primary) .value {\\n    opacity: 0.3;\\n}\\n\\ntr:nth-child(2n) {\\n    background-color: #eeeeee;\\n}\\n\\n.tableHeader {\\n    color: #666666;\\n}\\n\\n.tableTitle {\\n    display: flex;\\n    flex-direction: row;\\n    align-items: center;\\n    padding: 4px;\\n}\\n\\n#slotContainer {\\n    flex: 1;\\n}\\n\\np {\\n    display: inline;\\n    margin: 0;\\n    padding: 0;\\n    padding-right: 10px;\\n}\\n\\n#poll:empty::after,\\n#focus:empty::after {\\n    content: \\\"\u2717\\\";\\n    color: #ff0000;\\n}\\n\";\n\n/**\n * @callback OnPollCallback\n * @param {number} now\n * \n * @typedef Pollable\n * @property {OnPollCallback} onPoll\n */\n\n/**\n * A class to automatically call onPoll() on animation frame.\n */\nclass AutoPoller\n{\n    /**\n     * @param {Pollable} pollable \n     */\n    constructor(pollable)\n    {\n        /** @private */\n        this.onAnimationFrame = this.onAnimationFrame.bind(this);\n        /** @private */\n        this.animationFrameHandle = null;\n        /** @private */\n        this.pollable = pollable;\n    }\n\n    get running()\n    {\n        return this.animationFrameHandle !== null;\n    }\n\n    start()\n    {\n        let handle = this.animationFrameHandle;\n        if (handle) cancelAnimationFrame(handle);\n        this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);\n    }\n\n    stop()\n    {\n        let handle = this.animationFrameHandle;\n        if (handle) cancelAnimationFrame(handle);\n        this.animationFrameHandle = null;\n    }\n    \n    /** @private */\n    onAnimationFrame(now)\n    {\n        this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);\n        this.pollable.onPoll(now);\n    }\n}\n\n/** @typedef {import('./InputBindings.js').InputBindings} InputBindings */\n\n/**\n * A class to listen and transform device events through\n * each mapped bindings into an input state.\n * \n * It requires onPoll() to be called to keep the input\n * state up to date. This is usually called from \n * requestAnimationFrame() or using the AutoPoller.\n */\nclass DeviceInputAdapter\n{\n    /**\n     * @param {InputBindings} bindings \n     */\n    constructor(bindings)\n    {\n        /** @private */\n        this.onInput = this.onInput.bind(this);\n        this.onPoll = this.onPoll.bind(this);\n        \n        this.bindings = bindings;\n    }\n\n    onPoll(now)\n    {\n        for(let input of this.bindings.getInputs())\n        {\n            input.onPoll(now);\n        }\n    }\n\n    onInput(e)\n    {\n        const {\n            device, code, event,\n            value, movement,\n            // eslint-disable-next-line no-unused-vars\n            control, shift, alt,\n        } = e;\n        let bindings = this.bindings.getBindings(device, code);\n        switch(event)\n        {\n            case 'pressed':\n                for(let { input, index } of bindings)\n                {\n                    input.onUpdate(index, 1, 1);\n                }\n                break;\n            case 'released':\n                for(let { input, index } of bindings)\n                {\n                    input.onUpdate(index, 0, -1);\n                }\n                break;\n            case 'move':\n                for(let { input, index } of bindings)\n                {\n                    input.onUpdate(index, value, movement);\n                }\n                break;\n            case 'wheel':\n                for(let { input, index } of bindings)\n                {\n                    input.onUpdate(index, undefined, movement);\n                }\n                break;\n        }\n        return bindings.length > 0;\n    }\n}\n\n/**\n * @typedef {import('./axisbutton/InputBase.js').InputBase} InputBase\n * @typedef {import('./axisbutton/InputBase.js').BindingOptions} BindingOptions\n * \n * @typedef {string} DeviceName\n * @typedef {string} KeyCode\n */\n\nclass Binding\n{\n    /**\n     * @param {DeviceName} device The name of the device\n     * @param {KeyCode} code The key code for the device\n     * @param {InputBase} input The parent input\n     * @param {number} index The binding index for the input\n     */\n    constructor(device, code, input, index)\n    {\n        /** Name of the device */\n        this.device = device;\n        /** The key code for the device */\n        this.code = code;\n        /** The parent input */\n        this.input = input;\n        /** The binding index for the input */\n        this.index = index;\n    }\n}\n\n/**\n * A class that maps inputs to their respective key bindings.\n * \n * This does not handle input state (refer to InputBase.js) nor\n * input events (refer to InputDevice.js). It is only responsible\n * for the redirection of key codes to their bound input. Usually\n * this is used together with the interfaces referenced above.\n */\nclass InputBindings\n{\n    constructor()\n    {\n        /**\n         * @private\n         * @type {Record<DeviceName, Record<KeyCode, Array<Binding>>}\n         */\n        this.bindingMap = {};\n        /** \n         * @private\n         * @type {Map<InputBase, Array<Binding>>}\n         */\n        this.inputMap = new Map();\n    }\n\n    clear()\n    {\n        for(let input of this.inputMap.keys())\n        {\n            input.onUnbind();\n        }\n        this.inputMap.clear();\n        this.bindingMap = {};\n    }\n\n    /**\n     * @param {InputBase} input \n     * @param {DeviceName} device \n     * @param {KeyCode} code \n     * @param {BindingOptions} [opts]\n     */\n    bind(input, device, code, opts = {})\n    {\n        let binding;\n\n        let inputMap = this.inputMap;\n        if (inputMap.has(input))\n        {\n            let bindings = inputMap.get(input);\n            let index = input.size;\n            input.onBind(index, opts);\n            binding = new Binding(device, code, input, index);\n            bindings.push(binding);\n        }\n        else\n        {\n            let bindings = [];\n            inputMap.set(input, bindings);\n            let index = 0;\n            input.onBind(index, opts);\n            binding = new Binding(device, code, input, index);\n            bindings.push(binding);\n        }\n\n        let bindingMap = this.bindingMap;\n        if (device in bindingMap)\n        {\n            if (code in bindingMap[device])\n            {\n                bindingMap[device][code].push(binding);\n            }\n            else\n            {\n                bindingMap[device][code] = [binding];\n            }\n        }\n        else\n        {\n            bindingMap[device] = { [code]: [binding] };\n        }\n    }\n\n    /**\n     * @param {InputBase} input \n     */\n    unbind(input)\n    {\n        let inputMap = this.inputMap;\n        if (inputMap.has(input))\n        {\n            let bindingMap = this.bindingMap;\n            let bindings = inputMap.get(input);\n            for(let binding of bindings)\n            {\n                let { device, code } = binding;\n                let boundList = bindingMap[device][code];\n                let i = boundList.indexOf(binding);\n                boundList.splice(i, 1);\n            }\n            bindings.length = 0;\n            input.onUnbind();\n            inputMap.delete(input);\n        }\n    }\n\n    /**\n     * @param {InputBase} input\n     * @returns {boolean}\n     */\n    isBound(input)\n    {\n        return this.inputMap.has(input);\n    }\n    \n    /** @returns {IterableIterator<InputBase>} */\n    getInputs()\n    {\n        return this.inputMap.keys();\n    }\n\n    /** @returns {IterableIterator<Binding>} */\n    getBindingsByInput(input)\n    {\n        return this.inputMap.get(input);\n    }\n\n    /**\n     * @param {DeviceName} device \n     * @param {KeyCode} code \n     * @returns {IterableIterator<Binding>}\n     */\n    getBindings(device, code)\n    {\n        let deviceCodeBindings = this.bindingMap;\n        if (device in deviceCodeBindings)\n        {\n            let codeBindings = deviceCodeBindings[device];\n            if (code in codeBindings)\n            {\n                return codeBindings[code];\n            }\n        }\n        return [];\n    }\n}\n\n/**\n * @typedef {import('./device/InputDevice.js').InputDevice} InputDevice\n * @typedef {import('./device/InputDevice.js').InputDeviceEvent} InputDeviceEvent\n * @typedef {import('./axisbutton/InputBase.js').InputBase} InputBase\n * @typedef {import('./InputBindings.js').DeviceName} DeviceName\n * @typedef {import('./InputBindings.js').KeyCode} KeyCode\n * @typedef {import('./InputBindings.js').BindingOptions} BindingOptions\n * \n * @typedef {import('./binding/InputBinding.js').InputBinding} InputBinding\n * \n * @typedef {string} InputName\n */\n\n/**\n * @typedef {'bind'|'unbind'|'focus'|'blur'} InputContextEventType\n * @typedef {(e: InputContextEvent) => boolean} InputContextEventListener\n * @typedef InputContextEvent\n * @property {InputContextEventType} type\n */\n\nclass InputContext\n{\n    /**\n     * @param {EventTarget} eventTarget \n     * @param {object} [opts]\n     */\n    constructor(eventTarget, opts = {})\n    {\n        /**\n         * @type {Record<string, Axis|Button>}\n         */\n        this.inputs = {};\n        /**\n         * @type {Array<InputDevice>}\n         */\n        this.devices = [\n            new MouseDevice('Mouse', eventTarget),\n            new KeyboardDevice('Keyboard', eventTarget),\n        ];\n        this.bindings = new InputBindings();\n        this.adapter = new DeviceInputAdapter(this.bindings);\n        this.autopoller = new AutoPoller(this.adapter);\n\n        /** @protected */\n        this.eventTarget = eventTarget;\n        /** @protected */\n        this.anyButton = new Button(1);\n        /** @protected */\n        this.anyButtonDevice = '';\n        /** @protected */\n        this.anyButtonCode = '';\n        /** @protected */\n        this.anyAxis = new Axis(1);\n        /** @protected */\n        this.anyAxisDevice = '';\n        /** @protected */\n        this.anyAxisCode = '';\n\n        /**\n         * @private\n         * @type {Record<InputContextEventType, Array<InputContextEventListener>>}\n         */\n        this.listeners = {\n            bind: [],\n            unbind: [],\n            focus: [],\n            blur: [],\n        };\n\n        // Prepare listeners\n        /** @private */\n        this.onInput = this.onInput.bind(this);\n        /** @private */\n        this.onEventTargetBlur = this.onEventTargetBlur.bind(this);\n        /** @private */\n        this.onEventTargetFocus = this.onEventTargetFocus.bind(this);\n\n        // Attach listeners\n        eventTarget.addEventListener('focus', this.onEventTargetFocus);\n        eventTarget.addEventListener('blur', this.onEventTargetBlur);\n        for(let device of this.devices)\n        {\n            device.addEventListener('input', this.onInput);\n        }\n    }\n\n    get autopoll()\n    {\n        return this.autopoller.running;\n    }\n\n    set autopoll(value = undefined)\n    {\n        this.toggleAutoPoll(value);\n    }\n\n    destroy()\n    {\n        let listeners = this.listeners;\n        for(let event in listeners)\n        {\n            listeners[event].length = 0;\n        }\n        if (this.autopoller.running)\n        {\n            this.autopoller.stop();\n        }\n        for(let device of this.devices)\n        {\n            device.removeEventListener('input', this.onInput);\n            device.destroy();\n        }\n        let eventTarget = this.eventTarget;\n        eventTarget.removeEventListener('focus', this.onEventTargetFocus);\n        eventTarget.removeEventListener('blur', this.onEventTargetBlur);\n    }\n\n    setEventTarget(eventTarget)\n    {\n        let oldEventTarget = this.eventTarget;\n        oldEventTarget.removeEventListener('focus', this.onEventTargetFocus);\n        oldEventTarget.removeEventListener('blur', this.onEventTargetBlur);\n        \n        this.eventTarget = eventTarget;\n        for(let device of this.devices)\n        {\n            device.setEventTarget(eventTarget);\n        }\n        eventTarget.addEventListener('focus', this.onEventTargetFocus);\n        eventTarget.addEventListener('blur', this.onEventTargetBlur);\n    }\n\n    toggleAutoPoll(force = undefined)\n    {\n        let current = this.autopoller.running;\n        let next = typeof force === 'undefined' ? !current : Boolean(force);\n        if (next === current) return;\n        if (next)\n        {\n            this.autopoller.start();\n        }\n        else\n        {\n            this.autopoller.stop();\n        }\n    }\n\n    /**\n     * @param {InputContextEventType} event\n     * @param {InputContextEventListener} listener \n     */\n    addEventListener(event, listener)\n    {\n        let listeners = this.listeners;\n        if (event in listeners)\n        {\n            listeners[event].push(listener);\n        }\n        else\n        {\n            listeners[event] = [listener];\n        }\n    }\n\n    /**\n     * @param {InputContextEventType} event \n     * @param {InputContextEventListener} listener\n     */\n    removeEventListener(event, listener)\n    {\n        let listeners = this.listeners;\n        if (event in listeners)\n        {\n            let list = listeners[event];\n            let i = list.indexOf(listener);\n            if (i >= 0)\n            {\n                list.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * @param {InputContextEvent} e\n     * @returns {boolean} Whether the event should be consumed.\n     */\n    dispatchEvent(e)\n    {\n        const { type } = e;\n        let flag = 0;\n        for(let listener of this.listeners[type])\n        {\n            flag |= listener(e);\n        }\n        return Boolean(flag);\n    }\n\n    /**\n     * @param {number} now \n     */\n    poll(now = performance.now())\n    {\n        if (this.autopoller.running)\n        {\n            throw new Error('Should not manually poll() while autopolling.');\n        }\n        this.onPoll(now);\n    }\n\n    /**\n     * @private\n     * @param {InputDeviceEvent} e\n     */\n    onInput(e)\n    {\n        let result = this.adapter.onInput(e);\n        switch(e.event)\n        {\n            case 'pressed':\n                this.anyButtonDevice = e.device;\n                this.anyButtonCode = e.code;\n                this.anyButton.onUpdate(0, 1, 1);\n                break;\n            case 'released':\n                this.anyButtonDevice = e.device;\n                this.anyButtonCode = e.code;\n                this.anyButton.onUpdate(0, 0, -1);\n                break;\n            case 'move':\n            case 'wheel':\n                this.anyAxisDevice = e.device;\n                this.anyAxisCode = e.code;\n                this.anyAxis.onUpdate(0, e.value, e.movement);\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * @private\n     * @param {number} now\n     */\n    onPoll(now)\n    {\n        this.adapter.onPoll(now);\n        this.anyButton.onPoll(now);\n        this.anyAxis.onPoll(now);\n    }\n\n    /** @private */\n    onBind()\n    {\n        this.dispatchEvent({\n            type: 'bind'\n        });\n    }\n\n    /** @private */\n    onUnbind()\n    {\n        this.dispatchEvent({\n            type: 'unbind'\n        });\n    }\n\n    /** @private */\n    onEventTargetFocus()\n    {\n        this.dispatchEvent({\n            type: 'focus'\n        });\n    }\n\n    /** @private */\n    onEventTargetBlur()\n    {\n        // Clear all input states.\n        for(let input of this.bindings.getInputs())\n        {\n            input.onStatus(0, 0);\n        }\n        this.anyButton.onStatus(0, 0);\n        this.anyAxis.onStatus(0, 0);\n        this.dispatchEvent({\n            type: 'blur'\n        });\n    }\n\n    /**\n     * @param {Array<InputBinding>} bindings \n     */\n    bindBindings(bindings) {\n        for(let binding of bindings) {\n            binding.register(this);\n        }\n    }\n\n    /**\n     * @param {InputName} name \n     * @param {DeviceName} device \n     * @param {KeyCode} code \n     * @param {BindingOptions} [opts] \n     */\n    bindButton(name, device, code, opts = undefined)\n    {\n        let input;\n        if (this.hasButton(name))\n        {\n            input = this.getButton(name);\n        }\n        else\n        {\n            input = new Button(1);\n            this.inputs[name] = input;\n        }\n        this.bindings.bind(input, device, code, opts);\n        this.onBind();\n    }\n\n    /**\n     * @param {string} name \n     * @param {DeviceName} device \n     * @param {KeyCode} code \n     * @param {BindingOptions} [opts] \n     */\n    bindAxis(name, device, code, opts = undefined)\n    {\n        let input;\n        if (this.hasAxis(name))\n        {\n            input = this.getAxis(name);\n        }\n        else\n        {\n            input = new Axis(1);\n            this.inputs[name] = input;\n        }\n        this.bindings.bind(input, device, code, opts);\n        this.onBind();\n    }\n\n    /**\n     * @param {string} name \n     * @param {DeviceName} device \n     * @param {KeyCode} negativeCode \n     * @param {KeyCode} positiveCode \n     */\n    bindAxisButtons(name, device, negativeCode, positiveCode)\n    {\n        let input;\n        if (this.hasAxis(name))\n        {\n            input = this.getAxis(name);\n        }\n        else\n        {\n            input = new Axis(2);\n            this.inputs[name] = input;\n        }\n        this.bindings.bind(input, device, positiveCode);\n        this.bindings.bind(input, device, negativeCode, { inverted: true });\n        this.onBind();\n    }\n\n    /**\n     * @param {string} name \n     */\n    unbindButton(name)\n    {\n        if (this.hasButton(name))\n        {\n            let input = this.getButton(name);\n            delete this.inputs[name];\n            this.bindings.unbind(input);\n            this.onUnbind();\n        }\n    }\n\n    /**\n     * @param {string} name \n     */\n    unbindAxis(name)\n    {\n        if (this.hasAxis(name))\n        {\n            let input = this.getAxis(name);\n            delete this.inputs[name];\n            this.bindings.unbind(input);\n            this.onUnbind();\n        }\n    }\n\n    /**\n     * Get the input for the given name. Assumes the input already exists for the name.\n     * @param {InputName} name \n     * @returns {InputBase}\n     */\n    getInput(name)\n    {\n        return this.inputs[name];\n    }\n\n    /**\n     * Get the button for the given name. Assumes a button already exists for the name.\n     * @param {InputName} name\n     * @returns {Button}\n     */\n    getButton(name)\n    {\n        return this.inputs[name];\n    }\n\n    /**\n     * Get the axis for the given name. Assumes an axis already exists for the name.\n     * @param {InputName} name\n     * @returns {Axis}\n     */\n    getAxis(name)\n    {\n        return this.inputs[name];\n    }\n\n    /**\n     * Whether a button exists for the name and that it is of type {@link Button}.\n     * @returns {boolean}\n     */\n    hasButton(name)\n    {\n        return name in this.inputs && this.inputs[name] instanceof Button;\n    }\n\n    /**\n     * Whether an axis exists for the name and that it is of type {@link Axis}.\n     * @returns {boolean}\n     */\n    hasAxis(name)\n    {\n        return name in this.inputs && this.inputs[name] instanceof Axis;\n    }\n\n    /**\n     * Get whether a button for the given name is down. Assumes a button already exists for the name.\n     * @param {InputName} name\n     * @returns {boolean}\n     */\n    isButtonDown(name)\n    {\n        return this.inputs[name].down;\n    }\n\n    /**\n     * Get whether a button for the given name is pressed. Assumes a button already exists for the name.\n     * @param {InputName} name\n     * @returns {boolean}\n     */\n    isButtonPressed(name)\n    {\n        return this.inputs[name].pressed;\n    }\n\n    /**\n     * Get whether a button for the given name is released. Assumes a button already exists for the name.\n     * @param {InputName} name\n     * @returns {boolean}\n     */\n    isButtonReleased(name)\n    {\n        return this.inputs[name].released;\n    }\n\n    /**\n     * @param {InputName} name\n     * @returns {number}\n     */\n    getInputValue(name)\n    {\n        return this.inputs[name].value;\n    }\n\n    /**\n     * @param {InputName} name\n     * @returns {number}\n     */\n    getButtonValue(name)\n    {\n        return this.inputs[name].value;\n    }\n\n    /**\n     * @param {InputName} name\n     * @returns {number}\n     */\n    getAxisValue(name)\n    {\n        return this.inputs[name].value;\n    }\n\n    /**\n     * @param {InputName} name\n     * @returns {number}\n     */\n    getAxisDelta(name)\n    {\n        return this.inputs[name].delta;\n    }\n\n    /** @returns {boolean} */\n    isAnyButtonDown(include = undefined)\n    {\n        if (typeof include === 'undefined')\n        {\n            return this.anyButton.down;\n        }\n        else\n        {\n            let buttons = this.inputs;\n            for(let name of include)\n            {\n                let button = buttons[name];\n                if (button.down)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** @returns {boolean} */\n    isAnyButtonPressed(include = undefined)\n    {\n        if (typeof include === 'undefined')\n        {\n            return this.anyButton.pressed;\n        }\n        else\n        {\n            let buttons = this.inputs;\n            for(let name of include)\n            {\n                let button = buttons[name];\n                if (button.pressed)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** @returns {boolean} */\n    isAnyButtonReleased(include = undefined)\n    {\n        if (typeof include === 'undefined')\n        {\n            return this.anyButton.released;\n        }\n        else\n        {\n            let buttons = this.inputs;\n            for(let name of include)\n            {\n                let button = buttons[name];\n                if (button.released)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /** @returns {number} */\n    getAnyAxisValue(include = undefined)\n    {\n        if (typeof include === 'undefined')\n        {\n            return this.anyAxis.value;\n        }\n        else\n        {\n            let axes = this.inputs;\n            for(let name of include)\n            {\n                let axis = axes[name];\n                if (axis.value)\n                {\n                    return axis.value;\n                }\n            }\n        }\n        return 0;\n    }\n\n    /** @returns {number} */\n    getAnyAxisDelta(include = undefined)\n    {\n        if (typeof include === 'undefined')\n        {\n            return this.anyAxis.delta;\n        }\n        else\n        {\n            let axes = this.inputs;\n            for(let name of include)\n            {\n                let axis = axes[name];\n                if (axis.delta)\n                {\n                    return axis.delta;\n                }\n            }\n        }\n        return 0;\n    }\n\n    getLastButtonDevice()\n    {\n        return this.anyButtonDevice;\n    }\n\n    getLastButtonCode()\n    {\n        return this.anyButtonCode;\n    }\n\n    getLastAxisDevice()\n    {\n        return this.anyAxisDevice;\n    }\n\n    getLastAxisCode()\n    {\n        return this.anyAxisCode;\n    }\n\n    /** @returns {MouseDevice} */\n    getMouse()\n    {\n        return this.devices[0];\n    }\n\n    /** @returns {KeyboardDevice} */\n    getKeyboard()\n    {\n        return this.devices[1];\n    }\n}\n\n/**\n * @typedef {import('../device/InputDevice.js').InputDevice} InputDevice\n * @typedef {import('../device/InputDevice.js').InputDeviceEvent} InputDeviceEvent\n * @typedef {import('../axisbutton/InputBase.js').InputBase} InputBase\n * @typedef {import('../InputBindings.js').DeviceName} DeviceName\n * @typedef {import('../InputBindings.js').KeyCode} KeyCode\n * @typedef {import('../InputBindings.js').BindingOptions} BindingOptions\n * \n * @typedef {string} InputName\n */\n\nclass InputPort extends HTMLElement\n{\n    /** @protected */\n    static get [Symbol.for('templateNode')]()\n    {\n        let t = document.createElement('template');\n        t.innerHTML = INNER_HTML;\n        Object.defineProperty(this, Symbol.for('templateNode'), { value: t });\n        return t;\n    }\n\n    /** @protected */\n    static get [Symbol.for('styleNode')]()\n    {\n        let t = document.createElement('style');\n        t.innerHTML = INNER_STYLE;\n        Object.defineProperty(this, Symbol.for('styleNode'), { value: t });\n        return t;\n    }\n\n    static define(customElements = window.customElements)\n    {\n        customElements.define('input-port', this);\n    }\n\n    /** @override */\n    static get observedAttributes()\n    {\n        return [\n            'autopoll',\n            'for',\n        ];\n    }\n\n    /** @returns {boolean} */\n    get autopoll()\n    {\n        return this._autopoll;\n    }\n\n    set autopoll(value)\n    {\n        this.toggleAttribute('autopoll', value);\n    }\n\n    /** @returns {string} */\n    get for()\n    {\n        return this._for;\n    }\n\n    set for(value)\n    {\n        this.setAttribute('for', value);\n    }\n\n    constructor()\n    {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('templateNode')].content.cloneNode(true));\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('styleNode')].cloneNode(true));\n\n        /** @private */\n        this._titleElement = this.shadowRoot.querySelector('#title');\n        /** @private */\n        this._pollElement = this.shadowRoot.querySelector('#poll');\n        /** @private */\n        this._focusElement = this.shadowRoot.querySelector('#focus');\n        /** @private */\n        this._bodyElement = this.shadowRoot.querySelector('tbody');\n        /** @private */\n        this._outputElements = {};\n\n        /** @private */\n        this.onAnimationFrame = this.onAnimationFrame.bind(this);\n        /** @private */\n        this.animationFrameHandle = null;\n\n        const eventTarget = this;\n        /** @private */\n        this._for = '';\n        /** @private */\n        this._eventTarget = eventTarget;\n        /** @private */\n        this._autopoll = false;\n\n        /** @private */\n        this._context = null;\n        this.onInputContextBind = this.onInputContextBind.bind(this);\n        this.onInputContextUnbind = this.onInputContextUnbind.bind(this);\n        this.onInputContextFocus = this.onInputContextFocus.bind(this);\n        this.onInputContextBlur = this.onInputContextBlur.bind(this);\n    }\n    \n    /** @override */\n    connectedCallback()\n    {\n        if (Object.prototype.hasOwnProperty.call(this, 'for'))\n        {\n            let value = this.for;\n            delete this.for;\n            this.for = value;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this, 'autopoll'))\n        {\n            let value = this.autopoll;\n            delete this.autopoll;\n            this.autopoll = value;\n        }\n\n        // Make sure the table and values are up to date\n        this.updateTable();\n        this.updateTableValues();\n        this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);\n    }\n\n    /** @override */\n    disconnectedCallback()\n    {\n        if (this._context)\n        {\n            this._context.removeEventListener('bind', this.onInputContextBind);\n            this._context.removeEventListener('unbind', this.onInputContextUnbind);\n            this._context.removeEventListener('blur', this.onInputContextBlur);\n            this._context.removeEventListener('focus', this.onInputContextFocus);\n            this._context.destroy();\n            this._context = null;\n        }\n    }\n\n    /** @override */\n    attributeChangedCallback(attribute, prev, value)\n    {\n        switch (attribute)\n        {\n            case 'for':\n                {\n                    this._for = value;\n                    let target;\n                    let name;\n                    if (value)\n                    {\n                        target = document.getElementById(value);\n                        name = `${target.tagName.toLowerCase()}#${value}`;\n                    }\n                    else\n                    {\n                        target = this;\n                        name = 'input-port';\n                    }\n                    this._eventTarget = target;\n                    if (this._context)\n                    {\n                        this._context.setEventTarget(this._eventTarget);\n                    }\n                    // For debug info\n                    this._titleElement.innerHTML = `for ${name}`;\n                }\n                break;\n            case 'autopoll':\n                this._autopoll = value !== null;\n                if (this._context)\n                {\n                    this._context.toggleAutoPoll(this._autopoll);\n                }\n                break;\n        }\n    }\n\n    /** @private */\n    onAnimationFrame()\n    {\n        this.animationFrameHandle = requestAnimationFrame(this.onAnimationFrame);\n        this.updateTableValues();\n        this.updatePollStatus();\n    }\n\n    /** @private */\n    onInputContextBind()\n    {\n        this.updateTable();\n    }\n\n    /** @private */\n    onInputContextUnbind()\n    {\n        this.updateTable();\n    }\n\n    /** @private */\n    onInputContextFocus()\n    {\n        this._focusElement.innerHTML = '\u2713';\n    }\n\n    /** @private */\n    onInputContextBlur()\n    {\n        this._focusElement.innerHTML = '';\n    }\n\n    /**\n     * @param {'axisbutton'} [contextId]\n     * @param {object} [options]\n     * @returns {InputContext}\n     */\n    getContext(contextId = 'axisbutton', options = undefined)\n    {\n        switch(contextId)\n        {\n            case 'axisbutton':\n                if (!this._context)\n                {\n                    this._context = new InputContext(this._eventTarget, options);\n                    this._context.addEventListener('bind', this.onInputContextBind);\n                    this._context.addEventListener('unbind', this.onInputContextUnbind);\n                    this._context.addEventListener('blur', this.onInputContextBlur);\n                    this._context.addEventListener('focus', this.onInputContextFocus);\n                    if (this._autopoll)\n                    {\n                        this._context.toggleAutoPoll(true);\n                    }\n                }\n                return this._context;\n            default:\n                throw new Error(`Input context id '${contextId}' is not supported.`);\n        }\n    }\n\n    /** @private */\n    updateTable()\n    {\n        if (!this.isConnected)\n        {\n            // Don't update the DOM if not connected to any :(\n            return;\n        }\n        else if (!this._context)\n        {\n            // Clear all values if no context is available\n            this._outputElements = {};\n            this._bodyElement.innerHTML = '';\n            return;\n        }\n        else\n        {\n            let context = this._context;\n            let inputs = context.inputs;\n            let bindings = context.bindings;\n            let primaryElements = {};\n            let entries = [];\n            for(let name of Object.keys(inputs))\n            {\n                let input = inputs[name];\n                let primary = true;\n                for(let binding of bindings.getBindingsByInput(input))\n                {\n                    let element = createInputTableEntry(\n                        `${input.constructor.name}.${name}`,\n                        `${binding.device}.${binding.code}`,\n                        0,\n                        primary);\n                    entries.push(element);\n                    if (primary)\n                    {\n                        primaryElements[name] = element.querySelector('output');\n                        primary = false;\n                    }\n                }\n            }\n            this._outputElements = primaryElements;\n            this._bodyElement.innerHTML = '';\n            for (let entry of entries)\n            {\n                this._bodyElement.appendChild(entry);\n            }\n        }\n    }\n\n    /** @private */\n    updateTableValues()\n    {\n        if (!this.isConnected)\n        {\n            // Don't update the DOM if not connected to any :(\n            return;\n        }\n        else if (!this._context)\n        {\n            // Clear all values if no context is available\n            for(let name of Object.keys(this._outputElements))\n            {\n                let element = this._outputElements[name];\n                element.innerText = '---';\n            }\n            return;\n        }\n        else\n        {\n            let context = this._context;\n            let inputs = context.inputs;\n            for(let name of Object.keys(this._outputElements))\n            {\n                let element = this._outputElements[name];\n                let value = inputs[name].value;\n                element.innerText = Number(value).toFixed(2);\n            }\n        }\n    }\n\n    /** @private */\n    updatePollStatus()\n    {\n        if (!this.isConnected)\n        {\n            // Don't update the DOM if not connected to any :(\n            return;\n        }\n        else if (!this._context)\n        {\n            // Clear all values if no context is available\n            this._pollElement.innerHTML = '-';\n            return;\n        }\n        else\n        {\n            let context = this._context;\n            let inputs = context.inputs;\n            for(let input of Object.values(inputs))\n            {\n                if (!input.polling)\n                {\n                    this._pollElement.innerHTML = '';\n                    return;\n                }\n            }\n            this._pollElement.innerHTML = '\u2713';\n        }\n    }\n}\nInputPort.define();\n\nfunction createInputTableEntry(name, key, value, primary = true)\n{\n    let row = document.createElement('tr');\n    if (primary)\n    {\n        row.classList.add('primary');\n    }\n    // Name\n    {\n        let data = document.createElement('td');\n        data.textContent = name;\n        data.classList.add('name');\n        row.appendChild(data);\n    }\n    // Value\n    {\n        let data = document.createElement('td');\n        let output = document.createElement('output');\n        if (primary)\n        {\n            output.innerText = Number(value).toFixed(2);\n        }\n        else\n        {\n            output.innerText = '---';\n        }\n        output.classList.add('value');\n        data.appendChild(output);\n        row.appendChild(data);\n    }\n    // Key\n    {\n        let data = document.createElement('td');\n        data.classList.add('key');\n        let kbd = new InputCode();\n        kbd.innerText = key;\n        data.appendChild(kbd);\n        row.appendChild(data);\n    }\n    return row;\n}\n\n/**\n * @typedef {import('./axisbutton/Button.js').ButtonReadOnly} ButtonReadOnly\n */\n\nconst KEYBOARD_SOURCE = Symbol('keyboardSource');\nclass Keyboard\n{\n    constructor(eventTarget, opts)\n    {\n        /** @type {ButtonReadOnly} */\n        this.KeyA = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyB = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyC = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyD = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyE = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyF = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyG = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyH = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyI = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyJ = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyK = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyL = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyM = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyN = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyO = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyP = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyQ = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyR = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyS = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyT = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyU = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyV = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyW = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyX = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyY = new Button();\n        /** @type {ButtonReadOnly} */\n        this.KeyZ = new Button();\n\n        /** @type {ButtonReadOnly} */\n        this.Digit0 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit1 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit2 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit3 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit4 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit5 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit6 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit7 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit8 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Digit9 = new Button();\n\n        /** @type {ButtonReadOnly} */\n        this.Minus = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Equal = new Button();\n        /** @type {ButtonReadOnly} */\n        this.BracketLeft = new Button();\n        /** @type {ButtonReadOnly} */\n        this.BracketRight = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Semicolon = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Quote = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Backquote = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Backslash = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Comma = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Period = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Slash = new Button();\n\n        /** @type {ButtonReadOnly} */\n        this.Escape = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Space = new Button();\n        /** @type {ButtonReadOnly} */\n        this.CapsLock = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Backspace = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Delete = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Tab = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Enter = new Button();\n\n        /** @type {ButtonReadOnly} */\n        this.ArrowUp = new Button();\n        /** @type {ButtonReadOnly} */\n        this.ArrowDown = new Button();\n        /** @type {ButtonReadOnly} */\n        this.ArrowLeft = new Button();\n        /** @type {ButtonReadOnly} */\n        this.ArrowRight = new Button();\n        \n        const deviceName = KEYBOARD;\n        const device = new KeyboardDevice(deviceName, eventTarget, opts);\n        const bindings = new InputBindings();\n        for(let key in this)\n        {\n            if (Object.prototype.hasOwnProperty.call(this, key))\n            {\n                let input = this[key];\n                bindings.bind(input, deviceName, key);\n            }\n        }\n        const adapter = new DeviceInputAdapter(bindings);\n        device.addEventListener('input', adapter.onInput);\n        const autopoller = new AutoPoller(adapter);\n        autopoller.start();\n        this[KEYBOARD_SOURCE] = {\n            device,\n            bindings,\n            adapter,\n            autopoller,\n        };\n    }\n\n    destroy()\n    {\n        const source = this[KEYBOARD_SOURCE];\n        source.autopoller.stop();\n        source.device.removeEventListener('input', source.adapter.onInput);\n        source.device.destroy();\n        source.bindings.clear();\n    }\n}\n\n/**\n * @typedef {import('./axisbutton/Axis.js').AxisReadOnly} AxisReadOnly\n * @typedef {import('./axisbutton/Button.js').ButtonReadOnly} ButtonReadOnly\n */\n\nconst MOUSE_SOURCE = Symbol('mouseSource');\nclass Mouse\n{\n    constructor(eventTarget, opts)\n    {\n        /** @type {AxisReadOnly} */\n        this.PosX = new Axis();\n        /** @type {AxisReadOnly} */\n        this.PosY = new Axis();\n        \n        /** @type {AxisReadOnly} */\n        this.WheelX = new Axis();\n        /** @type {AxisReadOnly} */\n        this.WheelY = new Axis();\n        /** @type {AxisReadOnly} */\n        this.WheelZ = new Axis();\n\n        /** @type {ButtonReadOnly} */\n        this.Button0 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Button1 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Button2 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Button3 = new Button();\n        /** @type {ButtonReadOnly} */\n        this.Button4 = new Button();\n        \n        const deviceName = MOUSE;\n        const device = new MouseDevice(deviceName, eventTarget, opts);\n        const bindings = new InputBindings();\n        for(let key in this)\n        {\n            if (Object.prototype.hasOwnProperty.call(this, key))\n            {\n                let input = this[key];\n                bindings.bind(input, deviceName, key);\n            }\n        }\n        const adapter = new DeviceInputAdapter(bindings);\n        device.addEventListener('input', adapter.onInput);\n        const autopoller = new AutoPoller(adapter);\n        autopoller.start();\n        this[MOUSE_SOURCE] = {\n            device,\n            bindings,\n            adapter,\n            autopoller,\n        };\n    }\n\n    destroy()\n    {\n        const source = this[MOUSE_SOURCE];\n        source.autopoller.stop();\n        source.device.removeEventListener('input', source.adapter.onInput);\n        source.device.destroy();\n        source.bindings.clear();\n    }\n}\n\nexport { AutoPoller, Axis, AxisBinding, AxisButtonBinding, Button, ButtonBinding, CLEAR_DOWN_STATE_BITS, CLEAR_INVERTED_MODIFIER_BITS, CLEAR_POLL_BITS, DOWN_STATE_BIT, DeviceInputAdapter, INVERTED_MODIFIER_BIT, InputBase, InputBindings, InputCode, InputContext, InputDevice, InputPort, KeyCodes, Keyboard, KeyboardDevice, Mouse, MouseDevice, PRESSED_STATE_BIT, RELEASED_STATE_BIT, REPEATED_STATE_BIT, stringsToKeyCodes };\n", "// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n", "import { unzip } from 'fflate';\nimport { makeRe } from 'picomatch';\n\nclass FileBufferMap\n{\n    constructor()\n    {\n        /**\n         * @private\n         * @type {Record<string, Uint8Array>}\n         */\n        this._buffers = {};\n    }\n\n    clear()\n    {\n        this._buffers = {};\n    }\n\n    /**\n     * @param {string} filePath \n     * @param {Uint8Array} fileBuffer \n     */\n    put(filePath, fileBuffer)\n    {\n        this._buffers[filePath] = fileBuffer;\n    }\n\n    /**\n     * @param {string} filePath \n     * @returns {Uint8Array}\n     */\n    get(filePath)\n    {\n        return this._buffers[filePath];\n    }\n\n    /**\n     * @returns {Array<string>}\n     */\n    keys()\n    {\n        return Object.keys(this._buffers);\n    }\n}\n\nconst INNER_HTML = '';\nconst INNER_STYLE = '';\n\nconst DEFAULT_TIMEOUT_MILLIS = 5_000;\n\nclass AssetPack extends HTMLElement\n{\n    /** @private */\n    static get [Symbol.for('templateNode')]()\n    {\n        let t = document.createElement('template');\n        t.innerHTML = INNER_HTML;\n        Object.defineProperty(this, Symbol.for('templateNode'), { value: t });\n        return t;\n    }\n\n    /** @private */\n    static get [Symbol.for('styleNode')]()\n    {\n        let t = document.createElement('style');\n        t.innerHTML = INNER_STYLE;\n        Object.defineProperty(this, Symbol.for('styleNode'), { value: t });\n        return t;\n    }\n    \n    static define(customElements = window.customElements)\n    {\n        customElements.define('asset-pack', AssetPack);\n    }\n\n    /** @override */\n    static get observedAttributes()\n    {\n        return [\n            'src'\n        ];\n    }\n\n    /** @param {string} value */\n    set src(value)\n    {\n        this.setAttribute('src', value);\n    }\n\n    /** @returns {string} */\n    get src()\n    {\n        return this._src;\n    }\n\n    constructor()\n    {\n        super();\n        this.attachShadow({ mode: 'open' });\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('templateNode')].content.cloneNode(true));\n        this.shadowRoot.appendChild(this.constructor[Symbol.for('styleNode')].cloneNode(true));\n\n        /** @private */\n        this._src = '';\n        /** @private */\n        this._files = new FileBufferMap();\n        /** @private */\n        this._cache = {};\n        /**\n         * @private\n         * @type {Record<string, Loading>}\n         */\n        this._loading = {};\n        /**\n         * @private\n         * @type {Record<string, PipelineStage>}\n         */\n        this._pipeline = {};\n\n        /** @private */\n        this.onLoad = this.onLoad.bind(this);\n    }\n\n    get files()\n    {\n        return this._files;\n    }\n\n    /**\n     * @param {string|RegExp} filter \n     * @param {(assetData, uri) => Promise<any>} handler\n     */\n    async pipe(filter, handler)\n    {\n        let filterKey;\n        if (typeof filter === 'string')\n        {\n            filterKey = filter;\n            if (!(filterKey in this._pipeline))\n            {\n                filter = makeRe(filter);\n            }\n        }\n        else if (filter instanceof RegExp)\n        {\n            filterKey = filter.source;\n        }\n        else\n        {\n            throw new Error('Filter must be either a RegExp or glob string.');\n        }\n\n        /** @type {PipelineStage} */\n        let stage;\n        if (filterKey in this._pipeline)\n        {\n            stage = this._pipeline[filterKey];\n        }\n        else\n        {\n            stage = new PipelineStage(filter);\n            this._pipeline[filterKey] = stage;\n        }\n        stage.addHandler(handler);\n        \n        // Process old assets with new handler...\n        await Promise.all(Object.entries(this._cache).map(([key, value]) => {\n            if (stage.matches(key))\n            {\n                return handler(value, key);\n            }\n            else\n            {\n                return null;\n            }\n        }));\n    }\n\n    /**\n     * @param {string} uri \n     * @param {any} asset \n     * @param {object} [opts]\n     * @param {boolean} [opts.ephemeral]\n     */\n    async cache(uri, asset, opts = {})\n    {\n        const { ephemeral } = opts;\n        const prevValue = this._cache[uri];\n        const loading = this._loading[uri];\n        this._cache[uri] = asset;\n        // Process the asset...\n        await Promise.all(Object.values(this._pipeline).map(stage => {\n            if (stage.matches(uri))\n            {\n                return stage.process(uri, asset);\n            }\n            else\n            {\n                return null;\n            }\n        }));\n        // Send asset to awaiting loaders...\n        if (loading)\n        {\n            loading.resolve(asset);\n            delete this._loading[asset];\n        }\n        // Delete asset if ephemeral (and not yet replaced)...\n        if (ephemeral && this._cache[asset] === asset)\n        {\n            if (prevValue)\n            {\n                this._cache[asset] = prevValue;\n            }\n            else\n            {\n                delete this._cache[asset];\n            }\n        }\n    }\n\n    async loadAsset(uri, timeout = DEFAULT_TIMEOUT_MILLIS)\n    {\n        let value = this._cache[uri];\n        if (value)\n        {\n            return value;\n        }\n        else if (uri in this._loading)\n        {\n            return this._loading[uri].promise;\n        }\n        else\n        {\n            let loading = new Loading(timeout);\n            this._loading[uri] = loading;\n            return loading.promise;\n        }\n    }\n\n    clearAssets()\n    {\n        for(let loading of Object.values(this._loading))\n        {\n            loading.reject(new Error('Stop loading to clear all assets.'));\n        }\n        this._loading = {};\n        this._cache = {};\n    }\n\n    deleteAsset(uri)\n    {\n        if (uri in this._loading)\n        {\n            this._loading[uri].reject(new Error('Stop loading to delete asset.'));\n            delete this._loading[uri];\n        }\n        if (uri in this._cache)\n        {\n            delete this._cache[uri];\n        }\n    }\n\n    getAsset(uri)\n    {\n        return this._cache[uri];\n    }\n\n    hasAsset(uri)\n    {\n        let value = this._cache[uri];\n        if (value)\n        {\n            return value;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    /** @override */\n    connectedCallback()\n    {\n        upgradeProperty(this, 'src');\n    }\n\n    /** @override */\n    attributeChangedCallback(attribute, prev, value)\n    {\n        switch(attribute)\n        {\n            case 'src':\n                this._src = value;\n                if (value)\n                {\n                    fetch(value)\n                        .then(this.onLoad)\n                        .catch(e => console.error(\n                            `Failed to load asset pack: ${e}`));\n                }\n                break;\n        }\n    }\n\n    /**\n     * @private\n     * @param {Response} response\n     */\n    async onLoad(response)\n    {\n        let arrayBuffer = await response.arrayBuffer();\n        await new Promise((resolve, reject) => {\n            unzip(new Uint8Array(arrayBuffer), (err, data) => {\n                if (err)\n                {\n                    reject(err);\n                }\n                else\n                {\n                    // TODO: These files should be ephemeral to save memory\n                    let result = this._files;\n                    Promise.all(Object.entries(data)\n                        .map(([path, data]) => {\n                            // Remove the zip directory name\n                            // let i = path.indexOf('/');\n                            // path = path.substring(i + 1);\n                            // Put the file in cache\n                            result.put(path, data);\n                            return this.cache(path, data);\n                        }))\n                        .then(() => resolve())\n                        .catch(reject);\n                }\n            });\n        });\n        this.dispatchEvent(new CustomEvent('load', {\n            composed: true,\n        }));\n    }\n}\nAssetPack.define();\n\nfunction upgradeProperty(element, propertyName)\n{\n    if (Object.prototype.hasOwnProperty.call(element, propertyName))\n    {\n        let value = element[propertyName];\n        delete element[propertyName];\n        element[propertyName] = value;\n    }\n}\n\nclass PipelineStage\n{\n    constructor(filter)\n    {\n        /** @type {RegExp} */\n        this.filter = filter;\n        this.handlers = [];\n    }\n\n    matches(string)\n    {\n        return this.filter.test(string);\n    }\n\n    async process(uri, asset)\n    {\n        return Promise.all(this.handlers.map(value => value(uri, asset)));\n    }\n\n    addHandler(handler)\n    {\n        this.handlers.push(handler);\n    }\n}\n\nclass Loading\n{\n    constructor(timeout)\n    {\n        /** @private */\n        this._resolve = null;\n        /** @private */\n        this._reject = null;\n        /** @private */\n        this._reason = null;\n        /** @private */\n        this._value = null;\n        /** @private */\n        this._timeoutHandle = timeout > 0\n            ? setTimeout(() => {\n                this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n            }, timeout)\n            : null;\n        /** @private */\n        this._promise = new Promise((resolve, reject) => {\n            if (this._value)\n            {\n                resolve(this._value);\n            }\n            else\n            {\n                this._resolve = resolve;\n            }\n            if (this._reason)\n            {\n                reject(this._reason);\n            }\n            else\n            {\n                this._reject = reject;\n            }\n        });\n    }\n\n    get promise()\n    {\n        return this._promise;\n    }\n\n    resolve(value)\n    {\n        if (this._timeoutHandle)\n        {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._resolve)\n        {\n            this._resolve(value);\n        }\n        else\n        {\n            this._value = value;\n        }\n    }\n\n    reject(reason)\n    {\n        if (this._timeoutHandle)\n        {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._reject)\n        {\n            this._reject(reason);\n        }\n        else\n        {\n            this._reason = reason;\n        }\n    }\n}\n\nexport { AssetPack };\n", "window.addEventListener('error', error, true);\nwindow.addEventListener('unhandledrejection', error, true);\n\nexport function error(e)\n{\n    if (typeof e === 'object')\n    {\n        if (e instanceof PromiseRejectionEvent)\n        {\n            error(e.reason);\n        }\n        else if (e instanceof ErrorEvent)\n        {\n            error(e.error);\n        }\n        else if (e instanceof Error)\n        {\n            window.alert(e.stack);\n        }\n        else\n        {\n            window.alert(JSON.stringify(e));\n        }\n    }\n    else\n    {\n        window.alert(e);\n    }\n}\n", "import { assert } from './assert.js';\n\nconst OPPOSITE_DIRECTIONAL_ENCODING_OFFSET = 4;\nconst CLOCKWISE_ORTHOGONAL_DIRECTIONAL_ENCODING_OFFSET = 2;\n\nexport const DIRECTIONAL_ENCODING_BITS = 8;\nexport const DIRECTIONAL_ENCODING = {\n    EAST: 1 << 0,\n    NORTHEAST: 1 << 1,\n    NORTH: 1 << 2,\n    NORTHWEST: 1 << 3,\n    WEST: 1 << 4,\n    SOUTHWEST: 1 << 5,\n    SOUTH: 1 << 6,\n    SOUTHEAST: 1 << 7,\n};\nexport const DIRECTIONAL_ENCODING_VALUES = Object.values(DIRECTIONAL_ENCODING);\nexport const DIRECTIONAL_ENCODING_NULL = 0;\n\nexport function isDirectionalEncoding(encoding)\n{\n    return Number.isInteger(encoding) && encoding > 0 && encoding <= DIRECTIONAL_ENCODING.SOUTHEAST;\n}\n\nexport function randomSingleDirectionalEncoding()\n{\n    return 0x1 << Math.floor(Math.random() * DIRECTIONAL_ENCODING_BITS);\n}\n\nexport function oppositeDirectionalEncoding(encoding)\n{\n    return (0xF0 & (encoding << 4)) | (0x0F & (encoding >> 4));\n}\n\nexport function rotateDirectionalEncoding(encoding, clockwiseTurns = 1)\n{\n    clockwiseTurns = clockwiseTurns % DIRECTIONAL_ENCODING_BITS;\n    if (clockwiseTurns < 0)\n    {\n        // Invert it.\n        clockwiseTurns = DIRECTIONAL_ENCODING_BITS + clockwiseTurns;\n    }\n    let otherBits = DIRECTIONAL_ENCODING_BITS - clockwiseTurns;\n    return (0xF0 & (encoding << otherBits)) | (encoding >> clockwiseTurns);\n}\n\nexport function getDirectionalBitArrayFromEncoding(encoding)\n{\n    return [\n        (encoding >> 0) & 0x1,\n        (encoding >> 1) & 0x1,\n        (encoding >> 2) & 0x1,\n        (encoding >> 3) & 0x1,\n        (encoding >> 4) & 0x1,\n        (encoding >> 5) & 0x1,\n        (encoding >> 6) & 0x1,\n        (encoding >> 7) & 0x1,\n    ];\n}\n\nexport function getDirectionalEncodingFromBitArray(ee, ne, nn, nw, ww, sw, ss, se)\n{\n    return ee << 0\n        | ne << 1\n        | nn << 2\n        | nw << 3\n        | ww << 4\n        | sw << 5\n        | ss << 6\n        | se << 7;\n}\n\nexport function getDirectionalVectorFromEncoding(encoding)\n{\n    switch(encoding)\n    {\n        case DIRECTIONAL_ENCODING.EAST:\n            return [1, 0];\n        case DIRECTIONAL_ENCODING.NORTHEAST:\n            return [1, -1];\n        case DIRECTIONAL_ENCODING.NORTH:\n            return [0, -1];\n        case DIRECTIONAL_ENCODING.NORTHWEST:\n            return [-1, -1];\n        case DIRECTIONAL_ENCODING.WEST:\n            return [-1, 0];\n        case DIRECTIONAL_ENCODING.SOUTHWEST:\n            return [-1, 1];\n        case DIRECTIONAL_ENCODING.SOUTH:\n            return [0, 1];\n        case DIRECTIONAL_ENCODING.SOUTHEAST:\n            return [1, 1];\n        case DIRECTIONAL_ENCODING_NULL:\n            throw new Error('Cannot get delta vector from null encoding.');\n        default:\n            throw new Error('Cannot get delta vector from multi-directional encoding.');\n    }\n}\n\nexport function getDirectionalEncodingFromVector(dx, dy)\n{\n    if (dx === 0 && dy === 0) return 0;\n    let px = dx > 0;\n    let py = dy > 0;\n    let nx = dx < 0;\n    let ny = dy < 0;\n    let zx = !px && !nx;\n    let zy = !py && !ny;\n    return (px && zy ? 1 : 0) << 0 // East\n        | (px && ny ? 1 : 0) << 1 // North East\n        | (zx && ny ? 1 : 0) << 2 // North\n        | (nx && ny ? 1 : 0) << 3 // North West\n        | (nx && zy ? 1 : 0) << 4 // West\n        | (nx && py ? 1 : 0) << 5 // Sout West\n        | (zx && py ? 1 : 0) << 6 // South\n        | (px && py ? 1 : 0) << 7; // South East\n}\n\n\n\nexport function getOppositeDirectionIndex(directionIndex)\n{\n    return (directionIndex + OPPOSITE_DIRECTIONAL_ENCODING_OFFSET) % DIRECTIONAL_ENCODING_BITS;\n}\n\nexport function getClockwiseOrthogonalDirectionIndex(directionIndex)\n{\n    return (directionIndex + CLOCKWISE_ORTHOGONAL_DIRECTIONAL_ENCODING_OFFSET) % DIRECTIONAL_ENCODING_BITS;\n}\n\nexport function test()\n{\n    testBitArrayConversion();\n    testVectorConversion();\n    testRotate();\n    testOpposite();\n}\n\nfunction testBitArrayConversion()\n{\n    // Cardinal\n    let encoding = getDirectionalEncodingFromBitArray(1, 0, 1, 0, 1, 0, 1, 0);\n    let dirs = getDirectionalBitArrayFromEncoding(encoding);\n    assert(dirs[0] === 1\n        && dirs[1] === 0\n        && dirs[2] === 1\n        && dirs[3] === 0\n        && dirs[4] === 1\n        && dirs[5] === 0\n        && dirs[6] === 1\n        && dirs[7] === 0);\n    // Inter-Cardinal\n    encoding = getDirectionalEncodingFromBitArray(0, 1, 0, 1, 0, 1, 0, 1);\n    dirs = getDirectionalBitArrayFromEncoding(encoding);\n    assert(dirs[0] === 0\n        && dirs[1] === 1\n        && dirs[2] === 0\n        && dirs[3] === 1\n        && dirs[4] === 0\n        && dirs[5] === 1\n        && dirs[6] === 0\n        && dirs[7] === 1);\n}\n\nfunction testVectorConversion()\n{\n    let encoding = getDirectionalEncodingFromVector(0, 1);\n    assert(encoding === DIRECTIONAL_ENCODING.SOUTH);\n\n    let [dx, dy] = getDirectionalVectorFromEncoding(DIRECTIONAL_ENCODING.NORTHEAST);\n    assert(dx === 1 && dy === -1);\n}\n\nfunction testRotate()\n{\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.SOUTHWEST, 1) === DIRECTIONAL_ENCODING.WEST);\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.EAST, 1) === DIRECTIONAL_ENCODING.SOUTHEAST);\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.SOUTHEAST, 1) === DIRECTIONAL_ENCODING.SOUTH);\n\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.SOUTHWEST, 9) === DIRECTIONAL_ENCODING.WEST);\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.SOUTHWEST, 8) === DIRECTIONAL_ENCODING.SOUTHWEST);\n    assert(rotateDirectionalEncoding(DIRECTIONAL_ENCODING.SOUTHWEST, -1) === DIRECTIONAL_ENCODING.SOUTH);\n}\n\nfunction testOpposite()\n{\n    assert(oppositeDirectionalEncoding(DIRECTIONAL_ENCODING.NORTHWEST) === DIRECTIONAL_ENCODING.SOUTHEAST);\n    assert(oppositeDirectionalEncoding(DIRECTIONAL_ENCODING.WEST) === DIRECTIONAL_ENCODING.EAST);\n}\n", "/**\n * @typedef {[number, number]} JunctionCoords\n * @typedef {number} JunctionIndex\n * \n * @typedef {string} LaneIndex\n */\n\nexport const LANE_LENGTH = 6;\n\nexport class JunctionMap\n{\n    constructor(width, height)\n    {\n        this.width = width;\n        this.height = height;\n        this.length = width * height;\n\n        /**\n         * @private\n         * @type {Record<JunctionIndex, Junction>}\n         */\n        this.juncs = {};\n        /**\n         * @private\n         * @type {Record<LaneIndex, Lane>}\n         */\n        this.lanes = {};\n    }\n\n    /**\n     * @param {JunctionIndex} juncIndex \n     * @returns {boolean}\n     */\n    hasJunction(juncIndex)\n    {\n        if (juncIndex < 0) return false;\n        return Boolean(this.juncs[juncIndex]);\n    }\n\n    /**\n     * @param {JunctionIndex} juncIndex \n     * @returns {Junction}\n     */\n    getJunction(juncIndex)\n    {\n        let result = this.juncs[juncIndex];\n        if (!result)\n        {\n            throw new Error(`Cannot get non-existant junction at index ${juncIndex}.`);\n        }\n        return result;\n    }\n\n    /**\n     * @param {JunctionIndex} juncIndex \n     * @param {Junction} junction \n     */\n    setJunction(juncIndex, junction)\n    {\n        let prev = this.juncs[juncIndex];\n        if (prev)\n        {\n            throw new Error(`Cannot replace existing junction at index ${juncIndex}`);\n        }\n        this.juncs[juncIndex] = junction;\n    }\n\n    /**\n     * @param {JunctionIndex} juncIndex\n     */\n    deleteJunction(juncIndex)\n    {\n        let prev = this.juncs[juncIndex];\n        if (!prev)\n        {\n            throw new Error(`Cannot delete non-existant junction at index ${juncIndex}.`);\n        }\n        this.juncs[juncIndex] = undefined;\n    }\n\n    /**\n     * @returns {Array<Junction>}\n     */\n    getJunctions()\n    {\n        return Object.values(this.juncs).filter(junc => Boolean(junc));\n    }\n}\n\nexport class Junction\n{\n    /**\n     * @param {number} coordX \n     * @param {number} coordY \n     * @param {number} parkingCapacity \n     */\n    constructor(coordX, coordY, parkingCapacity)\n    {\n        this.coordX = coordX;\n        this.coordY = coordY;\n\n        /**\n         * @private\n         * @type {Array<JunctionIndex>}\n         */\n        this.outlets = [];\n        /**\n         * @private\n         * @type {Array<JunctionIndex>}\n         */\n        this.inlets = [];\n        /**\n         * @private\n         * @type {Record<JunctionIndex, Lane>}\n         */\n        this.lanes = {};\n\n        /** @type {string} */\n        this.passing = null;\n\n        /** @type {number} */\n        this.parkingCapacity = parkingCapacity;\n        /** @type {number} */\n        this.parking = 0;\n    }\n\n    getInlets()\n    {\n        return Array.from(this.inlets);\n    }\n\n    getOutlets()\n    {\n        return Array.from(this.outlets);\n    }\n\n    hasInlet(juncIndex)\n    {\n        return this.inlets.includes(juncIndex);\n    }\n\n    hasOutlet(juncIndex)\n    {\n        return this.outlets.includes(juncIndex);\n    }\n\n    addInlet(juncIndex, lane)\n    {\n        if (lane.inlet !== juncIndex)\n        {\n            throw new Error('Lane inlet does not match junction inlet.');\n        }\n        this.inlets.push(juncIndex);\n    }\n\n    addOutlet(juncIndex, lane)\n    {\n        if (lane.outlet !== juncIndex)\n        {\n            throw new Error('Lane outlet does not match junction outlet.');\n        }\n        this.outlets.push(juncIndex);\n        let prev = this.lanes[juncIndex];\n        if (prev)\n        {\n            throw new Error(`Cannot replace existing lane at outlet ${juncIndex}`);\n        }\n        this.lanes[juncIndex] = lane;\n    }\n\n    removeInlet(juncIndex)\n    {\n        let i = this.inlets.indexOf(juncIndex);\n        if (i >= 0)\n        {\n            this.inlets.splice(i, 1);\n        }\n        else\n        {\n            throw new Error(`Cannot remove non-existant inlet ${juncIndex} for junction.`);\n        }\n    }\n\n    removeOutlet(juncIndex)\n    {\n        let i = this.outlets.indexOf(juncIndex);\n        if (i >= 0)\n        {\n            this.outlets.splice(i, 1);\n            let prev = this.lanes[juncIndex];\n            if (!prev)\n            {\n                throw new Error(`Cannot delete non-existant lane for outlet ${juncIndex}.`);\n            }\n            this.lanes[juncIndex] = undefined;\n        }\n        else\n        {\n            throw new Error(`Cannot remove non-existant outlet ${juncIndex} for junction.`);\n        }\n    }\n\n    /**\n     * @param {JunctionIndex} outletIndex \n     * @returns {Lane}\n     */\n    getLane(outletIndex)\n    {\n        let result = this.lanes[outletIndex];\n        if (!result)\n        {\n            throw new Error(`Cannot get non-existant lane for outlet ${outletIndex}.`);\n        }\n        return result;\n    }\n\n    /**\n     * @returns {Array<Lane>}\n     */\n    getLanes()\n    {\n        return Object.values(this.lanes).filter(lane => Boolean(lane));\n    }\n\n    isEmpty()\n    {\n        return this.inlets.length <= 0 && this.outlets.length <= 0;\n    }\n}\n\nexport class Lane\n{\n    /**\n     * @param {JunctionIndex} inlet \n     * @param {JunctionIndex} outlet \n     * @param {number} length\n     */\n    constructor(inlet, outlet, length)\n    {\n        if (inlet === outlet)\n        {\n            throw new Error('Cannot create lane with the same inlet and outlet.');\n        }\n        /** @type {JunctionIndex} */\n        this.inlet = inlet;\n        /** @type {JunctionIndex} */\n        this.outlet = outlet;\n        /** @type {Array<string>} */\n        this.slots = new Array(length);\n        /** @type {number} */\n        this.length = length;\n        /** @type {number} */\n        this.blocking = length; // TODO: Not yet implemented. Should allow faster blocking checks.\n    }\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n * @returns {JunctionIndex}\n */\nexport function randomOutletJunctionFromJunction(map, juncIndex)\n{\n    let outlets = map.getJunction(juncIndex).getOutlets();\n    let outlet = outlets[Math.floor(Math.random() * outlets.length)];\n    return outlet;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n * @returns {Junction}\n */\nexport function getJunctionByIndex(map, juncIndex)\n{\n    return map.getJunction(juncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletIndex \n * @param {JunctionIndex} outletIndex\n * @returns {Lane}\n */\nexport function getJunctionLaneByIndex(map, inletIndex, outletIndex)\n{\n    if (typeof map !== 'object') throw new Error('Missing map.');\n    let junc = getJunctionByIndex(map, inletIndex);\n    return junc.lanes[outletIndex];\n}\n\n/**\n * @param {JunctionMap} map \n * @param {number} juncX \n * @param {number} juncY \n * @returns {Junction}\n */\nexport function putJunction(map, juncX, juncY, parkingCapacity = 0)\n{\n    let junc = new Junction(juncX, juncY, parkingCapacity);\n    let i = getJunctionIndexFromCoords(map, juncX, juncY);\n    map.setJunction(i, junc);\n    return junc;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n * @returns {JunctionCoords}\n */\nexport function getJunctionCoordsFromIndex(map, juncIndex)\n{\n    if (typeof map !== 'object') throw new Error('Missing map.');\n    return [\n        juncIndex % map.width,\n        Math.floor(juncIndex / map.width),\n    ];\n}\n\n/**\n * @param {JunctionMap} map \n * @param {number} juncX \n * @param {number} juncY \n * @returns {JunctionIndex}\n */\nexport function getJunctionIndexFromCoords(map, juncX, juncY)\n{\n    if (typeof map !== 'object') throw new Error('Missing map.');\n    return juncX + juncY * map.width;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {Junction} junc \n */\nexport function getJunctionIndexFromJunction(map, junc)\n{\n    return getJunctionIndexFromCoords(map, junc.coordX, junc.coordY);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletJuncIndex \n * @param {JunctionIndex} outletJuncIndex \n */\nexport function doesLaneExist(map, inletJuncIndex, outletJuncIndex)\n{\n    let inletJunc = map.getJunction(inletJuncIndex);\n    return inletJunc.hasOutlet(outletJuncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletJuncIndex \n * @param {JunctionIndex} outletJuncIndex \n */\nexport function putLane(map, inletJuncIndex, outletJuncIndex, laneLength)\n{\n    let inletJunc = map.getJunction(inletJuncIndex);\n    let outletJunc = map.getJunction(outletJuncIndex);\n    let lane = new Lane(inletJuncIndex, outletJuncIndex, laneLength);\n    inletJunc.addOutlet(outletJuncIndex, lane);\n    outletJunc.addInlet(inletJuncIndex, lane);\n    return lane;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletJuncIndex \n * @param {JunctionIndex} outletJuncIndex \n */\nexport function deleteLane(map, inletJuncIndex, outletJuncIndex)\n{\n    let inletJunc = map.getJunction(inletJuncIndex);\n    let outletJunc = map.getJunction(outletJuncIndex);\n    inletJunc.removeOutlet(outletJuncIndex);\n    outletJunc.removeInlet(inletJuncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletJuncIndex \n * @param {JunctionIndex} outletJuncIndex \n */\nexport function getLane(map, inletJuncIndex, outletJuncIndex)\n{\n    let inletJunc = map.getJunction(inletJuncIndex);\n    return inletJunc.getLane(outletJuncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} fromJuncIndex\n * @param {JunctionIndex} toJuncIndex\n */\nexport function connectJunctions(map, fromJuncIndex, toJuncIndex, laneLength = LANE_LENGTH)\n{\n    putLane(map, fromJuncIndex, toJuncIndex, laneLength);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} fromJuncIndex\n * @param {JunctionIndex} toJuncIndex\n */\nexport function disconnectJunctions(map, fromJuncIndex, toJuncIndex)\n{\n    let lane = getLane(map, fromJuncIndex, toJuncIndex);\n    if (lane.blocking < lane.length)\n    {\n        throw new Error('Cannot disconnect junctions with a non-vacated lane.');\n    }\n    deleteLane(map, fromJuncIndex, toJuncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} fromJuncIndex\n * @param {JunctionIndex} toJuncIndex\n * @returns {boolean}\n */\nexport function isJunctionConnectedTo(map, fromJuncIndex, toJuncIndex)\n{\n    let from = map.getJunction(fromJuncIndex);\n    return from.hasOutlet(toJuncIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {number} juncX \n * @param {number} juncY \n * @returns {boolean}\n */\nexport function isJunctionWithinBounds(map, juncX, juncY)\n{\n    return juncX >= 0 && juncY >= 0 && juncX < map.width && juncY < map.height;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} outletIndex \n * @param {JunctionIndex} juncIndex \n * @returns {boolean}\n */\nexport function isJunctionOutletForJunction(map, outletIndex, juncIndex)\n{\n    let from = map.getJunction(juncIndex);\n    return from.hasOutlet(outletIndex);\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex\n */\nexport function removeJunction(map, juncIndex)\n{\n    let from = map.getJunction(juncIndex);\n    if (!isJunctionEmpty(map, juncIndex))\n    {\n        let outlets = from.getOutlets();\n        for(let outlet of outlets)\n        {\n            disconnectJunctions(map, juncIndex, outlet);\n            if (isJunctionEmpty(map, outlet))\n            {\n                map.deleteJunction(outlet);\n            }\n        }\n        let inlets = from.getInlets();\n        for(let inlet of inlets)\n        {\n            disconnectJunctions(map, inlet, juncIndex);\n            if (isJunctionEmpty(map, inlet))\n            {\n                map.deleteJunction(inlet);\n            }\n        }\n    }\n    map.deleteJunction(juncIndex);\n}\n\nexport function removeOnlyJunctionConnections(map, juncIndex, removedIndices)\n{\n    let junc = map.getJunction(juncIndex);\n    for(let outletIndex of junc.getOutlets())\n    {\n        if (removedIndices.includes(outletIndex))\n        {\n            disconnectJunctions(map, juncIndex, outletIndex);\n            if (isJunctionEmpty(map, outletIndex))\n            {\n                removeJunction(map, outletIndex);\n            }\n        }\n    }\n    for(let inletIndex of junc.getInlets())\n    {\n        if (removedIndices.includes(inletIndex))\n        {\n            disconnectJunctions(map, inletIndex, juncIndex);\n            if (isJunctionEmpty(map, inletIndex))\n            {\n                removeJunction(map, inletIndex);\n            }\n        }\n    }\n}\n\nexport function retainOnlyJunctionConnections(map, juncIndex, retainedIndices)\n{\n    let junc = map.getJunction(juncIndex);\n    for(let outletIndex of junc.getOutlets())\n    {\n        if (!retainedIndices.includes(outletIndex))\n        {\n            disconnectJunctions(map, juncIndex, outletIndex);\n            if (isJunctionEmpty(map, outletIndex))\n            {\n                removeJunction(map, outletIndex);\n            }\n        }\n    }\n    for(let inletIndex of junc.getInlets())\n    {\n        if (!retainedIndices.includes(inletIndex))\n        {\n            disconnectJunctions(map, inletIndex, juncIndex);\n            if (isJunctionEmpty(map, inletIndex))\n            {\n                removeJunction(map, inletIndex);\n            }\n        }\n    }\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n * @returns {boolean}\n */\nexport function isJunctionEmpty(map, juncIndex)\n{\n    let junc = map.getJunction(juncIndex);\n    return junc.isEmpty();\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n * @returns {boolean}\n */\nexport function isNullJunction(map, juncIndex)\n{\n    return juncIndex === -1 || !map.hasJunction(juncIndex);\n}\n\nexport const LANE_SLOT_OFFSET = 0.5;\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {JunctionMap} map \n */\nexport function drawJunctions(ctx, map, cellSize)\n{\n    const juncSize = cellSize / 2;\n    const margin = (cellSize - juncSize) / 2;\n    const laneRadius = juncSize / 3;\n    ctx.lineWidth = laneRadius;\n    ctx.strokeStyle = 'teal';\n    for(let junc of map.getJunctions())\n    {\n        const { coordX, coordY } = junc;\n        let xx = coordX * cellSize;\n        let yy = coordY * cellSize;\n        ctx.strokeRect(xx + margin, yy + margin, juncSize, juncSize);\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx \n * @param {JunctionMap} map \n * @param {number} cellSize \n * @param {number} laneRadius \n * @param {number} junctionSize \n */\nexport function drawLanes(ctx, map, cellSize)\n{\n    const juncSize = cellSize / 2;\n    const laneRadius = juncSize / 3;\n    ctx.lineWidth = laneRadius / 4;\n    // let laneId = 0;\n    for(let y = 0; y < map.height; ++y)\n    {\n        for(let x = 0; x < map.width; ++x)\n        {\n            let i = x + y * map.width;\n            if (!map.hasJunction(i)) continue;\n            let junc = map.getJunction(i);\n            let beginX = (x + 0.5) * cellSize;\n            let beginY = (y + 0.5) * cellSize;\n            for(let lane of junc.getLanes())\n            {\n                let [xx, yy] = getJunctionCoordsFromIndex(map, lane.outlet);\n                let endX = (xx + 0.5) * cellSize;\n                let endY = (yy + 0.5) * cellSize;\n                let dx = endX - beginX;\n                let dy = endY - beginY;\n                let dr = Math.atan2(dy, dx);\n                const laneLength = lane.length;\n                let nodeRadius = (cellSize / 3) / laneLength;\n\n                if (junc.passing)\n                {\n                    ctx.strokeStyle = 'red';\n                }\n                else\n                {\n                    ctx.strokeStyle = 'lime';\n                }\n\n                ctx.beginPath();\n                ctx.arc(beginX, beginY, laneRadius / 2, 0, Math.PI * 2);\n                ctx.stroke();\n\n                // Lane Index\n                /*\n                ctx.lineWidth = 1;\n                ctx.font = '32px Arial';\n                ctx.strokeStyle = 'white';\n                ctx.strokeText(`${laneId++}`, beginX + 8, beginY - 8);\n                ctx.lineWidth = laneRadius / 4;\n                */\n\n                for(let i = 0; i < laneLength; ++i)\n                {\n                    let ratio = (i + LANE_SLOT_OFFSET) / laneLength;\n                    let tx = beginX + dx * ratio;\n                    let ty = beginY + dy * ratio;\n                    if (lane.slots[i])\n                    {\n                        ctx.strokeStyle = 'red';\n                    }\n                    else\n                    {\n                        ctx.strokeStyle = 'white';\n                    }\n                    ctx.beginPath();\n                    ctx.arc(tx, ty, nodeRadius, dr, dr + Math.PI);\n                    ctx.stroke();\n                }\n            }\n        }\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx \n * @param {JunctionMap} map \n */\nexport function drawOutlets(ctx, map, cellSize)\n{\n    const juncSize = cellSize / 2;\n    const laneRadius = juncSize;\n    ctx.lineWidth = laneRadius;\n    ctx.lineCap = 'round';\n    ctx.strokeStyle = '#333333';\n    for(let y = 0; y < map.height; ++y)\n    {\n        for(let x = 0; x < map.width; ++x)\n        {\n            let i = x + y * map.width;\n            if (!map.hasJunction(i)) continue;\n            let junc = map.getJunction(i);\n            let beginX = (x + 0.5) * cellSize;\n            let beginY = (y + 0.5) * cellSize;\n            for(let outlet of junc.outlets)\n            {\n                let [xx, yy] = getJunctionCoordsFromIndex(map, outlet);\n                let endX = (xx + 0.5) * cellSize;\n                let endY = (yy + 0.5) * cellSize;\n                ctx.beginPath();\n                ctx.moveTo(beginX, beginY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n        }\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n */\nexport function drawPath(ctx, path, cellSize = 128, pathRadius = 2, junctionSize = 32)\n{\n    if (path && path.length > 1)\n    {\n        let [prevX, prevY] = getJunctionCoordsFromIndex(path[0]);\n        for(let i = 1; i < path.length; ++i)\n        {\n            let [nextX, nextY] = getJunctionCoordsFromIndex(path[i]);\n            let fx = prevX * cellSize + junctionSize / 2;\n            let fy = prevY * cellSize + junctionSize / 2;\n            let tx = nextX * cellSize + junctionSize / 2;\n            let ty = nextY * cellSize + junctionSize / 2;\n            let dx = nextX - prevX;\n            let dy = nextY - prevY;\n            ctx.lineWidth = pathRadius * 2;\n            ctx.strokeStyle = 'gold';\n            ctx.beginPath();\n            ctx.moveTo(fx, fy);\n            ctx.lineTo(tx, ty);\n            ctx.moveTo(tx, ty);\n            let radians = Math.atan2(dy, dx) - Math.PI;\n            let arrowX = Math.cos(radians + Math.PI / 8) * pathRadius * 2;\n            let arrowY = Math.sin(radians + Math.PI / 8) * pathRadius * 2;\n            ctx.lineTo(tx + arrowX, ty + arrowY);\n            ctx.stroke();\n            prevX = nextX;\n            prevY = nextY;\n        }\n    }\n}\n", "export function drawGrid(ctx, gridCols, gridRows, gridCellSize, color = '#222222')\n{\n    for(let y = 0; y < gridRows; ++y)\n    {\n        for(let x = 0; x < gridCols; ++x)\n        {\n            let xx = x * gridCellSize;\n            let yy = y * gridCellSize;\n            ctx.strokeStyle = color;\n            ctx.strokeRect(xx, yy, gridCellSize, gridCellSize);\n        }\n    }\n}\n", "/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n */\n\nimport { DIRECTIONAL_ENCODING_BITS, DIRECTIONAL_ENCODING_NULL, getDirectionalVectorFromEncoding, rotateDirectionalEncoding } from '../util/Directional.js';\nimport { connectJunctions, getJunctionCoordsFromIndex, getJunctionIndexFromCoords, isJunctionConnectedTo, isJunctionWithinBounds } from '../junction/Junction.js';\n\nexport class Directable\n{\n    /**\n     * @param {JunctionMap} junctionMap\n     */\n    constructor(junctionMap)\n    {\n        this.junctionMap = junctionMap;\n        this.directs = new Array(junctionMap.length).fill(-1);\n    }\n\n    markDirectableJunction(juncIndex, childIndex)\n    {\n        const map = this.junctionMap;\n        if (!map.hasJunction(juncIndex))\n        {\n            throw new Error('Cannot mark directable for non-existant junction.');\n        }\n        if (!map.hasJunction(childIndex))\n        {\n            throw new Error('Cannot mark directable child as non-existant junction.');\n        }\n        let childDirectable = this.directs[childIndex];\n        if (childDirectable !== -1)\n        {\n            throw new Error('Cannot mark directable child as another directable junction.');\n        }\n        let prevDirectable = this.directs[juncIndex];\n        if (prevDirectable !== -1)\n        {\n            throw new Error('Cannot mark directable for junction already directable.');\n        }\n        this.directs[juncIndex] = childIndex;\n    }\n\n    unmarkDirectableJunction(juncIndex)\n    {\n        let prevDirectable = this.directs[juncIndex];\n        if (prevDirectable === -1)\n        {\n            throw new Error('Cannot unmark directable for junction already non-directable.');\n        }\n        this.directs[juncIndex] = -1;\n    }\n\n    isDirectableJunction(juncIndex)\n    {\n        return this.directs[juncIndex] !== -1;\n    }\n\n    getDirectableJunctionChild(juncIndex)\n    {\n        return this.directs[juncIndex];\n    }\n\n    redirectDirectableJunction(juncIndex, prevChildIndex, newChildIndex)\n    {\n        const map = this.junctionMap;\n        if (prevChildIndex === newChildIndex)\n        {\n            throw new Error('Cannot redirect directable junction to the same child.');\n        }\n        if (!this.isDirectableJunction(juncIndex))\n        {\n            throw new Error('Cannot redirect non-directable junction.');\n        }\n        if (this.isDirectableJunction(newChildIndex))\n        {\n            throw new Error('Cannot redirect directable junction to another directable junction.');\n        }\n        if (this.getDirectableJunctionChild(juncIndex) !== prevChildIndex)\n        {\n            throw new Error('Found mismatched child index for directable junction.');\n        }\n        if (!map.hasJunction(newChildIndex))\n        {\n            throw new Error('Cannot redirect junction to non-existant child.');\n        }\n        // NOTE: This does not destroy the previous directed junction.\n        this.directs[juncIndex] = newChildIndex;\n        if (!isJunctionConnectedTo(map, juncIndex, newChildIndex))\n        {\n            connectJunctions(map, juncIndex, newChildIndex);\n        }\n        if (!isJunctionConnectedTo(map, newChildIndex, juncIndex))\n        {\n            connectJunctions(map, newChildIndex, juncIndex);\n        }\n    }\n}\n\nexport function tryFindValidChildDirectionForDirectable(map, juncIndex, initialDirection, validChildCallback)\n{\n    let [x, y] = getJunctionCoordsFromIndex(map, juncIndex);\n    let direction = initialDirection;\n    for(let i = 0; i < DIRECTIONAL_ENCODING_BITS; ++i)\n    {\n        let [dx, dy] = getDirectionalVectorFromEncoding(direction);\n        let xx = x + dx;\n        let yy = y + dy;\n        if (!isJunctionWithinBounds(map, xx, yy))\n        {\n            continue;\n        }\n        let childIndex = getJunctionIndexFromCoords(map, xx, yy);\n        if (validChildCallback(childIndex))\n        {\n            return direction;\n        }\n        direction = rotateDirectionalEncoding(direction);\n    }\n    return DIRECTIONAL_ENCODING_NULL;\n}\n", "/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n * @typedef {import('../junction/Junction.js').JunctionIndex} JunctionIndex\n */\n\nimport { retainOnlyJunctionConnections } from '../junction/Junction.js';\n\nexport class Persistence\n{\n    /**\n     * @param {JunctionMap} junctionMap \n     */\n    constructor(junctionMap)\n    {\n        this.junctionMap = junctionMap;\n        /** @type {Record<string, Array<JunctionIndex>>} */\n        this.persists = {};\n    }\n\n    clear()\n    {\n        this.persists = {};\n    }\n\n    markPersistentJunction(juncIndex, dependentIndex = juncIndex)\n    {\n        this.markPersistentJunctionImpl(juncIndex, dependentIndex);\n        if (juncIndex !== dependentIndex)\n        {\n            this.markPersistentJunctionImpl(dependentIndex, juncIndex);\n        }\n    }\n\n    /** @private */\n    markPersistentJunctionImpl(juncIndex, dependentIndex)\n    {\n        let list = this.persists[juncIndex];\n        if (!list)\n        {\n            list = this.persists[juncIndex] = [];\n        }\n        let i = list.indexOf(dependentIndex);\n        if (i < 0)\n        {\n            list.push(dependentIndex);\n        }\n        else\n        {\n            throw new Error('Cannot mark persistence for junction already persistent.');\n        }\n    }\n\n    unmarkPersistentJunction(juncIndex, dependentIndex = juncIndex)\n    {\n        this.unmarkPersistentJunctionImpl(juncIndex, dependentIndex);\n        if (juncIndex !== dependentIndex)\n        {\n            this.unmarkPersistentJunctionImpl(dependentIndex, juncIndex);\n        }\n    }\n\n    /** @private */\n    unmarkPersistentJunctionImpl(juncIndex, dependentIndex)\n    {\n        let list = this.persists[juncIndex];\n        let i = list.indexOf(dependentIndex);\n        if (i >= 0)\n        {\n            list.splice(i, 1);\n        }\n        else\n        {\n            throw new Error('Cannot unmark persistence for junction already non-persistent.');\n        }\n    }\n\n    isPersistentJunction(juncIndex)\n    {\n        let list = this.persists[juncIndex];\n        if (list)\n        {\n            return list.length > 0;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    retainOnlyPersistentJunctionConnections(juncIndex)\n    {\n        const map = this.junctionMap;\n        let list = this.persists[juncIndex];\n        if (!list || list.length <= 0)\n        {\n            throw new Error('Cannot retain non-persistent junction.');\n        }\n        retainOnlyJunctionConnections(map, juncIndex, list);\n    }\n}\n", "/**\n * @typedef Eventable\n * @property {function} on\n * @property {function} off\n * @property {function} once\n * @property {function} emit\n */\n\n/**\n * @version 1.3.0\n * @description\n * # Changelog\n * ## 1.3.0\n * - Return results for emit()\n * ## 1.2.0\n * - Added named exports\n * - Added custom this context\n * - Added some needed explanations for the functions\n * ## 1.1.0\n * - Started versioning\n */\nconst EventableInstance = {\n    /**\n     * Registers an event handler to continually listen for the event.\n     * \n     * @param {string} event The name of the event to listen for.\n     * @param {function} callback The callback function to handle the event.\n     * @param {*} [handle = callback] The handle to refer to this registered callback.\n     * Used by off() to remove handlers. If none specified, it will use the callback\n     * itself as the handle. This must be unique.\n     * @return {Eventable} Self for method-chaining.\n     */\n    on(event, callback, handle = callback)\n    {\n        let callbacks;\n        if (!this.__events.has(event))\n        {\n            callbacks = new Map();\n            this.__events.set(event, callbacks);\n        }\n        else\n        {\n            callbacks = this.__events.get(event);\n        }\n\n        if (!callbacks.has(handle))\n        {\n            callbacks.set(handle, callback);\n        }\n        else\n        {\n            throw new Error(`Found callback for event '${event}' with the same handle '${handle}'.`);\n        }\n        return this;\n    },\n\n    /**\n     * Unregisters an event handler to stop listening for the event.\n     * \n     * @param {string} event The name of the event listened for.\n     * @param {*} handle The registered handle to refer to the registered\n     * callback. If no handle was provided when calling on(), the callback\n     * is used as the handle instead.\n     * @return {Eventable} Self for method-chaining.\n     */\n    off(event, handle)\n    {\n        if (this.__events.has(event))\n        {\n            const callbacks = this.__events.get(event);\n            if (callbacks.has(handle))\n            {\n                callbacks.delete(handle);\n            }\n            else\n            {\n                throw new Error(`Unable to find callback for event '${event}' with handle '${handle}'.`);\n            }\n        }\n        else\n        {\n            throw new Error(`Unable to find event '${event}'.`);\n        }\n        return this;\n    },\n    \n    /**\n     * Registers a one-off event handler to start listening for the next,\n     * and only the next, event.\n     * \n     * @param {string} event The name of the event to listen for.\n     * @param {function} callback The callback function to handle the event.\n     * @param {*} [handle = callback] The handle to refer to this registered callback.\n     * Used by off() to remove handlers. If none specified, it will use the callback\n     * itself as the handle. This must be unique.\n     * @return {Eventable} Self for method-chaining.\n     */\n    once(event, callback, handle = callback)\n    {\n        const func = (...args) => {\n            this.off(event, handle);\n            callback.apply(this.__context || this, args);\n        };\n        return this.on(event, func, handle);\n    },\n\n    /**\n     * Emits the event with the arguments passed on to the registered handlers.\n     * The context of the handlers, if none were initially bound, could be\n     * defined upon calling the Eventable's creation function. Otherwise, the\n     * handler is called with `this` context of the Eventable instance.\n     * \n     * @param {string} event The name of the event to emit.\n     * @param  {...any} args Any arguments to pass to registered handlers.\n     * @return {Array<any>} Array of any returned values of the callbacks.\n     */\n    emit(event, ...args)\n    {\n        if (this.__events.has(event))\n        {\n            let results = [];\n            const callbacks = Array.from(this.__events.get(event).values());\n            for(const callback of callbacks)\n            {\n                let result = callback.apply(this.__context || this, args);\n                if (result) results.push(result);\n            }\n            return results;\n        }\n        else\n        {\n            this.__events.set(event, new Map());\n            return [];\n        }\n    }\n};\n\n/**\n * Creates an eventable object.\n * \n * @param {Object} [context] The context used for the event handlers.\n * @return {Eventable} The created eventable object.\n */\nfunction create(context = undefined)\n{\n    const result = Object.create(EventableInstance);\n    result.__events = new Map();\n    result.__context = context;\n    return result;\n}\n\n/**\n * Assigns the passed-in object with eventable properties.\n * \n * @param {Object} dst The object to assign with eventable properties.\n * @param {Object} [context] The context used for the event handlers.\n * @return {Eventable} The resultant eventable object.\n */\nfunction assign(dst, context = undefined)\n{\n    const result = Object.assign(dst, EventableInstance);\n    result.__events = new Map();\n    result.__context = context;\n    return result;\n}\n\n/**\n * Mixins eventable properties into the passed-in class.\n * \n * @param {Class} targetClass The class to mixin eventable properties.\n * @param {Object} [context] The context used for the event handlers.\n * @return {Class<Eventable>} The resultant eventable-mixed-in class.\n */\nfunction mixin(targetClass, context = undefined)\n{\n    const targetPrototype = targetClass.prototype;\n    Object.assign(targetPrototype, EventableInstance);\n    targetPrototype.__events = new Map();\n    targetPrototype.__context = context;\n    return targetPrototype;\n}\n\nconst Eventable = {\n    create,\n    assign,\n    mixin,\n};\n\n// Log levels\nconst TRACE = 5;\nconst DEBUG = 4;\nconst INFO = 3;\nconst WARN = 2;\nconst ERROR = 1;\nconst OFF = 0;\n\nconst LOG_LEVEL_STYLES = {\n    [TRACE]: styledLogLevel('#7F8C8D'), // Gray\n    [DEBUG]: styledLogLevel('#2ECC71'), // Green\n    [INFO]: styledLogLevel('#4794C8'), // Blue\n    [WARN]: styledLogLevel('#F39C12'), // Yellow\n    [ERROR]: styledLogLevel('#C0392B'), // Red\n    [OFF]: [''],\n};\n\nfunction compareLogLevel(a, b)\n{\n    return a - b;\n}\n\nfunction styledLogLevel(color)\n{\n    return [\n        `background: ${color}`,\n        'border-radius: 0.5em',\n        'color: white',\n        'font-weight: bold',\n        'padding: 2px 0.5em',\n    ];\n}\n\n// Useful functions\nfunction noop() { /** Do nothing. */ }\n\nfunction getStyledMessage(message, styles)\n{\n    return [\n        `%c${message}`,\n        styles.join(';'),\n    ];\n}\n\nfunction getConsoleFunction(level)\n{\n    switch(level)\n    {\n        case TRACE:\n            return console.trace;\n        case DEBUG:\n            return console.log;\n        case INFO:\n            return console.log;\n        case WARN:\n            return console.warn;\n        case ERROR:\n            return console.error;\n        case OFF:\n            return noop;\n        default:\n            return console.log;\n    }\n}\n\nfunction prependMessageTags(out, name, domain, level)\n{\n    if (name)\n    {\n        out.unshift(`[${name}]`);\n    }\n\n    if (domain)\n    {\n        let tag = getStyledMessage(domain, LOG_LEVEL_STYLES[level]);\n        out.unshift(tag[0], tag[1]);\n    }\n\n    return out;\n}\n\nconst LEVEL = Symbol('level');\nconst DOMAIN = Symbol('domain');\nconst LOGGERS = { /** To be populated by logger instances. */ };\nlet DEFAULT_LEVEL = WARN;\nlet DEFAULT_DOMAIN = 'app';\nclass Logger\n{\n    static get TRACE() { return TRACE; }\n    static get DEBUG() { return DEBUG; }\n    static get INFO() { return INFO; }\n    static get WARN() { return WARN; }\n    static get ERROR() { return ERROR; }\n    static get OFF() { return OFF; }\n\n    /**\n     * Creates or gets the logger for the given unique name.\n     * @param {String} name \n     * @returns {Logger} The logger with the name.\n     */\n    static getLogger(name)\n    {\n        if (name in LOGGERS)\n        {\n            return LOGGERS[name];\n        }\n        else\n        {\n            return LOGGERS[name] = new Logger(name);\n        }\n    }\n\n    static useDefaultLevel(level)\n    {\n        DEFAULT_LEVEL = level;\n        return this;\n    }\n\n    static useDefaultDomain(domain)\n    {\n        DEFAULT_DOMAIN = domain;\n        return this;\n    }\n\n    constructor(name)\n    {\n        this.name = name;\n        this[LEVEL] = DEFAULT_LEVEL;\n        this[DOMAIN] = DEFAULT_DOMAIN;\n    }\n\n    setLevel(level)\n    {\n        this[LEVEL] = level;\n        return this;\n    }\n    \n    getLevel()\n    {\n        return this[LEVEL];\n    }\n\n    setDomain(domain)\n    {\n        this[DOMAIN] = domain;\n        return this;\n    }\n\n    getDomain()\n    {\n        return this[DOMAIN];\n    }\n\n    log(level, ...messages)\n    {\n        if (compareLogLevel(this[LEVEL], level) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], level);\n        getConsoleFunction(level)(...messages);\n    }\n\n    trace(...messages)\n    {\n        if (compareLogLevel(this[LEVEL], TRACE) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], TRACE);\n        getConsoleFunction(TRACE)(...messages);\n    }\n\n    debug(...messages)\n    {\n        if (compareLogLevel(this[LEVEL], DEBUG) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], DEBUG);\n        getConsoleFunction(DEBUG)(...messages);\n    }\n\n    info(...messages)\n    {\n        if (compareLogLevel(this[LEVEL], INFO) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], INFO);\n        getConsoleFunction(INFO)(...messages);\n    }\n\n    warn(...messages)\n    {\n        if (compareLogLevel(this[LEVEL], WARN) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], WARN);\n        getConsoleFunction(WARN)(...messages);\n    }\n\n    error(...messages)\n    {\n        if (compareLogLevel(this[LEVEL], ERROR) < 0) return this;\n        prependMessageTags(messages, this.name, this[DOMAIN], ERROR);\n        getConsoleFunction(ERROR)(...messages);\n    }\n}\n\n// Bresenham's Line Algorithm\nfunction bresenhamLine(fromX, fromY, toX, toY, callback)\n{\n    let fx = Math.floor(fromX);\n    let fy = Math.floor(fromY);\n    let tx = Math.floor(toX);\n    let ty = Math.floor(toY);\n\n    let dx = Math.abs(toX - fromX);\n    let sx = fromX < toX ? 1 : -1;\n    let dy = -Math.abs(toY - fromY);\n    let sy = fromY < toY ? 1 : -1;\n    let er = dx + dy;\n\n    let x = fx;\n    let y = fy;\n    let flag = callback(x, y);\n    if (typeof flag !== 'undefined') return flag;\n    \n    let maxLength = dx * dx + dy * dy;\n    let length = 0;\n    while(length < maxLength && (x !== tx || y !== ty))\n    {\n        // Make sure it doesn't go overboard.\n        ++length;\n\n        let er2 = er * 2;\n\n        if (er2 >= dy)\n        {\n            er += dy;\n            x += sx;\n        }\n\n        if (er2 <= dx)\n        {\n            er += dx;\n            y += sy;\n        }\n\n        flag = callback(x, y);\n        if (typeof flag !== 'undefined') return flag;\n    }\n}\n\nconst FILE_TYPE_PNG = 'png';\nconst FILE_TYPE_SVG = 'svg';\n\nfunction downloadText(filename, textData)\n{\n    downloadURL(filename, getTextDataURI(textData));\n}\n\nfunction downloadImageFromSVG(filename, filetype, svg, width, height)\n{\n    const blob = createBlobFromSVG(svg);\n    switch (filetype)\n    {\n        case FILE_TYPE_PNG:\n            {\n                const url = URL.createObjectURL(blob);\n\n                const canvas = document.createElement('canvas');\n                const ctx = canvas.getContext('2d');\n                const pixelRatio = window.devicePixelRatio || 1;\n                canvas.width = width * pixelRatio;\n                canvas.height = height * pixelRatio;\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n                ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n                const image = new Image();\n                image.onload = () => \n                {\n                    ctx.drawImage(image, 0, 0);\n                    URL.revokeObjectURL(url);\n\n                    const imageURI = canvas.toDataURL('image/' + filetype).replace('image/' + filetype, 'image/octet-stream');\n                    downloadURL(filename, imageURI);\n                };\n                image.src = url;\n            }\n            break;\n        case FILE_TYPE_SVG:\n            {\n                const reader = new FileReader();\n                reader.onload = () => \n                {\n                    downloadURL(filename, reader.result);\n                };\n                reader.readAsDataURL(blob);\n            }\n            break;\n        default:\n            throw new Error('Unknown file type \\'' + filetype + '\\'');\n    }\n}\n\nfunction downloadURL(filename, url)\n{\n    const element = document.createElement('a');\n    const headerIndex = url.indexOf(';');\n    url = url.substring(0, headerIndex + 1) + 'headers=Content-Disposition%3A%20attachment%3B%20filename=' + filename + ';' + url.substring(headerIndex + 1);\n    element.setAttribute('href', url);\n    element.setAttribute('download', filename);\n\n    element.style.display = 'none';\n    document.body.appendChild(element);\n\n    element.click();\n    document.body.removeChild(element);\n}\n\nfunction createBlobFromSVG(svg)\n{\n    const styledSVG = computeSVGStyles(svg);\n    const serializer = new XMLSerializer();\n    const svgString = serializer.serializeToString(styledSVG);\n    const blob = new Blob([svgString], { type: 'image/svg+xml' });\n    return blob;\n}\n\n// SOURCE: https://stackoverflow.com/questions/3975499/convert-svg-to-image-jpeg-png-etc-in-the-browser/44769098#44769098\nconst SVG_CONTAINERS = ['svg', 'g'];\nfunction computeSVGStyles(svg, dst = svg.cloneNode(true))\n{\n    let sourceChildren = svg.childNodes;\n    let children = dst.childNodes;\n\n    for (var index = 0; index < children.length; index++)\n    {\n        let child = children[index];\n        let tagName = child.tagName;\n        if (SVG_CONTAINERS.indexOf(tagName) != -1)\n        {\n            computeSVGStyles(sourceChildren[index], child);\n        }\n        else if (sourceChildren[index] instanceof Element)\n        {\n            const computedStyle = window.getComputedStyle(sourceChildren[index]);\n\n            let styleAttributes = [];\n            for(let styleName of Object.keys(computedStyle))\n            {\n                styleAttributes.push(`${styleName}:${computedStyle.getPropertyValue(styleName)};`);\n            }\n\n            child.setAttribute('style', styleAttributes.join(''));\n        }\n    }\n\n    return dst;\n}\n\nfunction getTextDataURI(data)\n{\n    return 'data:text/plain; charset=utf-8,' + encodeURIComponent(data);\n}\n\nasync function uploadFile(accept = [], multiple = false)\n{\n    return new Promise((resolve, reject) => {\n        const element = document.createElement('input');\n        element.addEventListener('change', (e) => {\n            if (multiple)\n            {\n                resolve(e.target.files);\n            }\n            else\n            {\n                resolve(e.target.files[0]);\n            }\n        });\n        element.type = 'file';\n        element.accept = accept.join(',');\n        element.style.display = 'none';\n        element.toggleAttribute('multiple', multiple);\n        document.body.appendChild(element);\n        element.click();\n        document.body.removeChild(element);\n    });\n}\n\nconst TOP_INDEX = 0;\n\n// NOTE: Uses a binary heap to sort.\nclass PriorityQueue\n{\n    constructor(comparator)\n    {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    get size() { return this._heap.length; }\n\n    clear()\n    {\n        this._heap.length = 0;\n    }\n\n    push(...values)\n    {\n        for (const value of values)\n        {\n            this._heap.push(value);\n            this._shiftUp();\n        }\n    }\n\n    pop()\n    {\n        const result = this.peek();\n        let bottom = bottomIndex(this);\n        if (bottom > TOP_INDEX)\n        {\n            this._swap(TOP_INDEX, bottom);\n        }\n        this._heap.pop();\n        this._shiftDown();\n        return result;\n    }\n\n    /** Replaces the top value with the new value. */\n    replace(value)\n    {\n        const result = this.peek();\n        this._heap[TOP_INDEX] = value;\n        this._shiftDown();\n        return result;\n    }\n\n    peek()\n    {\n        return this._heap[TOP_INDEX];\n    }\n\n    /** @private */\n    _compare(i, j)\n    {\n        return this._comparator(this._heap[i], this._heap[j]);\n    }\n\n    /** @private */\n    _swap(i, j)\n    {\n        let result = this._heap[i];\n        this._heap[i] = this._heap[j];\n        this._heap[j] = result;\n    }\n\n    /** @private */\n    _shiftUp()\n    {\n        let node = this._heap.length - 1;\n        let nodeParent;\n        while (node > TOP_INDEX && this._compare(node, nodeParent = parentIndex(node)))\n        {\n            this._swap(node, nodeParent);\n            node = nodeParent;\n        }\n    }\n\n    /** @private */\n    _shiftDown()\n    {\n        const length = this._heap.length;\n        let node = TOP_INDEX;\n        let nodeMax;\n\n        let nodeLeft = leftIndex(node);\n        let flagLeft = nodeLeft < length;\n        let nodeRight = rightIndex(node);\n        let flagRight = nodeRight < length;\n\n        while ((flagLeft && this._compare(nodeLeft, node))\n            || (flagRight && this._compare(nodeRight, node)))\n        {\n            nodeMax = (flagRight && this._compare(nodeRight, nodeLeft)) ? nodeRight : nodeLeft;\n            this._swap(node, nodeMax);\n            node = nodeMax;\n\n            nodeLeft = leftIndex(node);\n            flagLeft = nodeLeft < length;\n            nodeRight = rightIndex(node);\n            flagRight = nodeRight < length;\n        }\n    }\n\n    values()\n    {\n        return this._heap;\n    }\n\n    [Symbol.iterator]()\n    {\n        return this._heap[Symbol.iterator]();\n    }\n}\n\nfunction bottomIndex(queue)\n{\n    return queue._heap.length - 1;\n}\n\nfunction parentIndex(i)\n{\n    return ((i + 1) >>> 1) - 1;\n}\n\nfunction leftIndex(i)\n{\n    return (i << 1) + 1;\n}\n\nfunction rightIndex(i)\n{\n    return (i + 1) << 1;\n}\n\n/**\n * Generates a uuid v4.\n * \n * @param {number} a The placeholder (serves for recursion within function).\n * @returns {string} The universally unique id.\n */\nfunction uuid(a = undefined)\n{\n    // https://gist.github.com/jed/982883\n    return a\n        ? (a ^ Math.random() * 16 >> a / 4).toString(16)\n        : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);\n}\n\nfunction lerp(a, b, t)\n{\n    return a + (b - a) * t;\n}\n\nfunction clamp(value, min, max)\n{\n    return Math.min(max, Math.max(min, value));\n}\n\nfunction cycle(value, min, max)\n{\n    let range = max - min;\n    let result = (value - min) % range;\n    if (result < 0) result += range;\n    return result + min;\n}\n\nfunction withinRadius(fromX, fromY, toX, toY, radius)\n{\n    const dx = fromX - toX;\n    const dy = fromY - toY;\n    return dx * dx + dy * dy <= radius * radius;\n}\n\nfunction distance2(fromX, fromY, toX, toY)\n{\n    let dx = toX - fromX;\n    let dy = toY - fromY;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction direction2(fromX, fromY, toX, toY)\n{\n    let dx = toX - fromX;\n    let dy = toY - fromY;\n    return Math.atan2(dy, dx);\n}\n\nfunction lookAt2(radians, target, dt)\n{\n    let step = cycle(target - radians, -Math.PI, Math.PI);\n    return clamp(radians + step, radians - dt, radians + dt);\n}\n\nconst TO_RAD_FACTOR = Math.PI / 180;\nconst TO_DEG_FACTOR = 180 / Math.PI;\nfunction toRadians(degrees)\n{\n    return degrees * TO_RAD_FACTOR;\n}\n\nfunction toDegrees(radians)\n{\n    return radians * TO_DEG_FACTOR;\n}\n\n/**\n * @callback DependencyCallback\n * @param {Object} node The target node to get the dependencies for.\n * @returns {Array<Object>} A list of all dependencies for the given node.\n */\n\n/**\n * Sort an array topologically.\n * \n * @param {Array<Object>} nodes List of all nodes (as long as it includes the root node).\n * @param {DependencyCallback} dependencyCallback A callback to get the dependencies of a node.\n * @returns {Array<Object>} A sorted array of node objects where the dependent nodes are always listed before the dependees.\n */\nfunction topoSort(nodes, dependencyCallback)\n{\n    let dependencyEntries = [];\n    for(let node of nodes)\n    {\n        let outs = dependencyCallback(node);\n        if (Array.isArray(outs))\n        {\n            dependencyEntries.push([node, ...outs]);\n        }\n        else if (outs)\n        {\n            throw new Error('Dependency callback must return an array.');\n        }\n    }\n    return computeDependencyList(\n        getNodesFromDependencyEntries(dependencyEntries),\n        getEdgesFromDependencyEntries(dependencyEntries)\n    );\n}\n\nfunction getNodesFromDependencyEntries(dependencyEntries)\n{\n    let result = new Set();\n    for(let dependencyEntry of dependencyEntries)\n    {\n        for(let value of dependencyEntry)\n        {\n            result.add(value);\n        }\n    }\n    return Array.from(result);\n}\n\nfunction getEdgesFromDependencyEntries(dependencyEntries)\n{\n    let result = [];\n    for(let dependencyEntry of dependencyEntries)\n    {\n        let source = dependencyEntry[0];\n        for(let i = 1; i < dependencyEntry.length; ++i)\n        {\n            let dependency = dependencyEntry[i];\n            result.push([source, dependency]);\n        }\n    }\n    return result;\n}\n\nfunction computeDependencyList(nodes, edges, dst = [])\n{\n    // Compute edge outs (more efficient lookup)\n    let edgeOuts = new Map();\n    for(let edge of edges)\n    {\n        if (edge.length > 1)\n        {\n            let source = edge[0];\n            let dest = edge[1];\n            if (!edgeOuts.has(source)) edgeOuts.set(source, new Set());\n            if (!edgeOuts.has(dest)) edgeOuts.set(dest, new Set());\n            edgeOuts.get(source).add(dest);\n        }\n    }\n\n    let context = {\n        edgeMap: edgeOuts,\n        index: nodes.length,\n        visited: new Set(),\n        dst,\n    };\n\n    for(let node of nodes)\n    {\n        visit(context, node, new Set());\n    }\n\n    return dst;\n}\n\nfunction visit(context, node, prev)\n{\n    if (prev.has(node))\n    {\n        throw new Error(`Found cyclic dependency for '${node.name || node}'.`);\n    }\n    \n    if (context.visited.has(node)) return;\n    context.visited.add(node);\n\n    if (context.edgeMap.has(node))\n    {\n        let outs = context.edgeMap.get(node);\n        if (outs.size > 0)\n        {\n            prev.add(node);\n            for(let out of outs)\n            {\n                visit(context, out, prev);\n            }\n            prev.delete(node);\n        }\n    }\n\n    context.dst.push(node);\n}\n\n/**\n * @template T\n * @typedef NodeCache<T>\n * @property {Record<T, number>} fscore\n * @property {Record<T, number>} gscore\n * @property {Record<T, number>} hscore\n * @property {Record<T, T>} parents\n */\n\n/**\n * @template T\n * @param {T} startId The unique representation of the starting position. Must be deterministic.\n * @param {T} goalId The unique representation of the stopping position. Must be deterministic.\n * @param {(node: T) => Array<T>} neighborsCallback Get all reachable neighbors from the given node.\n * @param {(from: T, to: T) => number} heuristicCallback Get the heuristics score between the two nodes.\n * @returns {Array<T>} If the goal is not reachable from the start, it will return an empty array.\n */\nfunction astarSearch(startId, goalId, neighborsCallback, heuristicCallback)\n{\n    /** @type {NodeCache<T>} */\n    let cache = createCache();\n    cacheNode(cache, startId);\n    let opened = new Set();\n    let closed = new Set();\n    opened.add(startId);\n    while(opened.size > 0)\n    {\n        let minNodeId;\n        for(let openNodeId of opened)\n        {\n            if (minNodeId)\n            {\n                if (cache.fscore[openNodeId] < cache.fscore[minNodeId])\n                {\n                    minNodeId = openNodeId;\n                }\n            }\n            else\n            {\n                minNodeId = openNodeId;\n            }\n        }\n\n        let currentNodeId = minNodeId;\n        if (currentNodeId === goalId)\n        {\n            // Completed!\n            let result = [];\n            while(cache.parents[currentNodeId])\n            {\n                result.push(currentNodeId);\n                currentNodeId = cache.parents[currentNodeId];\n            }\n            result.push(currentNodeId);\n            return result.reverse();\n        }\n        else\n        {\n            // Not there yet...\n            closed.add(currentNodeId);\n            opened.delete(currentNodeId);\n            for(let neighborNodeId of neighborsCallback(currentNodeId))\n            {\n                if (closed.has(neighborNodeId)) continue;\n                let g = cache.gscore[currentNodeId] + 1;\n                let flag = false;\n                if (!opened.has(neighborNodeId))\n                {\n                    flag = true;\n                    cacheNode(cache, neighborNodeId);\n                    cache.hscore[neighborNodeId] = heuristicCallback(neighborNodeId, goalId);\n                    opened.add(neighborNodeId);\n                }\n                else if (g < cache.gscore[neighborNodeId])\n                {\n                    flag = true;\n                }\n                // Use the new g score if better\n                if (flag)\n                {\n                    cache.parents[neighborNodeId] = currentNodeId;\n                    cache.gscore[neighborNodeId] = g;\n                    cache.fscore[neighborNodeId] = g + cache.hscore[neighborNodeId];\n                }\n            }\n        }\n    }\n    return [];\n}\n\n/**\n * @template T\n * @returns {NodeCache<T>}\n */\nfunction createCache()\n{\n    return {\n        fscore: {},\n        gscore: {},\n        hscore: {},\n        parents: {},\n    };\n}\n\n/**\n * @template T\n * @param {NodeCache<T>} cache \n * @param {T} id \n * @param {number} f \n * @param {number} g \n * @param {number} h \n * @param {T} parent \n * @returns {T}\n */\nfunction cacheNode(cache, id, f = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, h = Number.NaN, parent = null)\n{\n    cache.fscore[id] = f;\n    cache.gscore[id] = g;\n    cache.hscore[id] = h;\n    cache.parents[id] = parent;\n    return id;\n}\n\nfunction fisherYatesShuffle(array)\n{\n    for(let i = array.length - 1; i > 0; --i)\n    {\n        let j = Math.floor(Math.random() * (i + 1));\n        let temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n}\n\nfunction bitCount(n)\n{\n    n = n - ((n >> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;\n}\n\nexport { Eventable, FILE_TYPE_PNG, FILE_TYPE_SVG, Logger, PriorityQueue, astarSearch, bitCount, bresenhamLine, clamp, cycle, direction2, distance2, downloadImageFromSVG, downloadText, downloadURL, fisherYatesShuffle, lerp, lookAt2, toDegrees, toRadians, topoSort, uploadFile, uuid, withinRadius };\n", "import { bresenhamLine } from '@milque/util';\n\nexport const CURSOR_ACTION = {\n    NONE: 0,\n    ACTIVATING: 1,\n    DEACTIVATING: 2,\n};\n\n/**\n * @param {number} screenX \n * @param {number} screenY \n * @param {0|1|2} action \n * @param {object} state \n * @param {(fromX, fromY, toX, toY) => void} connector \n * @param {(cellX, cellY) => void} disconnector \n * @param {number} cellSize \n * @param {number} dragMargin \n */\nexport function tryRoadInteraction(screenX, screenY, action, interactionState, connector, disconnector, cellSize, dragMargin)\n{\n    let cellxf = screenX / cellSize;\n    let cellyf = screenY / cellSize;\n    let cellx = Math.floor(cellxf);\n    let celly = Math.floor(cellyf);\n    switch(action)\n    {\n        case CURSOR_ACTION.ACTIVATING:\n            makeRoad(interactionState, cellx, celly, cellxf, cellyf, connector, dragMargin);\n            break;\n        case CURSOR_ACTION.DEACTIVATING:\n            breakRoad(interactionState, cellx, celly, disconnector);\n            break;\n        case CURSOR_ACTION.NONE:\n            interactionState.status = CURSOR_ACTION.NONE;\n            break;\n    }\n}\n\nfunction makeRoad(state, cellx, celly, cellxf, cellyf, connector, dragMargin)\n{\n    let { status, dragCellX, dragCellY } = state;\n    if (status !== CURSOR_ACTION.ACTIVATING)\n    {\n        state.status = CURSOR_ACTION.ACTIVATING;\n        state.dragCellX = dragCellX = cellx;\n        state.dragCellY = dragCellY = celly;\n    }\n    let prevCellX = dragCellX + 0.5;\n    let prevCellY = dragCellY + 0.5;\n    let nextCellX = cellxf;\n    let nextCellY = cellyf;\n    let dx = nextCellX - prevCellX;\n    let dy = nextCellY - prevCellY;\n    let dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist >= dragMargin)\n    {\n        prevCellX = dragCellX;\n        prevCellY = dragCellY;\n        nextCellX = cellx;\n        nextCellY = celly;\n        bresenhamLine(prevCellX, prevCellY, nextCellX, nextCellY, (x, y) => {\n            connector.call(undefined, prevCellX, prevCellY, x, y);\n            nextCellX = prevCellX = x;\n            nextCellY = prevCellY = y;\n        });\n        state.dragCellX = nextCellX;\n        state.dragCellY = nextCellY;\n    }\n}\n\nfunction breakRoad(state, cellx, celly, disconnector)\n{\n    let { status, dragCellX, dragCellY } = state;\n    if (status !== CURSOR_ACTION.DEACTIVATING)\n    {\n        state.status = CURSOR_ACTION.DEACTIVATING;\n        state.dragCellX = dragCellX = -1;\n        state.dragCellY = dragCellY = -1;\n    }\n    if (cellx !== dragCellX || celly !== dragCellY)\n    {\n        disconnector.call(undefined, cellx, celly);\n        state.dragCellX = cellx;\n        state.dragCellY = celly;\n    }\n}\n", "import { uuid } from '@milque/util';\nimport { getJunctionByIndex, getJunctionCoordsFromIndex, getJunctionLaneByIndex, isNullJunction } from '../junction/Junction.js';\n\nexport const NULL_JUNCTION_INDEX = -1;\nexport const NULL_SLOT_INDEX = -1;\n\nexport const NO_JUNCTION_INTENT = 0;\nexport const PASSING_JUNCTION_INTENT = 1;\nexport const PARKING_JUNCTION_INTENT = 2;\n\nexport const MAX_CART_SPEED = 4;\n\n/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n * @typedef {import('../junction/Junction.js').JunctionIndex} JunctionIndex\n */\n\nexport class TrafficSimulator\n{\n    /**\n     * @param {JunctionMap} junctionMap \n     */\n    constructor(junctionMap, planner)\n    {\n        this.junctionMap = junctionMap;\n        this.planner = planner;\n        /**\n         * @private\n         * @type {Record<string, TrafficAgent>}\n         */\n        this.agents = {};\n        /**\n         * @private\n         * @type {Record<string, Array<JunctionIndex>>}\n         */\n        this.paths = {};\n        /** @private */\n        this.ticks = 0;\n    }\n\n    spawnAgent(homeIndex)\n    {\n        const map = this.junctionMap;\n        if (!map.hasJunction(homeIndex))\n        {\n            throw new Error('Cannot spawn agent on non-existant junction as home.');\n        }\n        let id = uuid();\n        let agent = new TrafficAgent(id, homeIndex);\n        this.agents[id] = agent;\n        forceOnJunction(map, agent, homeIndex);\n        acquireParking(map, agent, homeIndex);\n        return agent;\n    }\n\n    getAgent(agentId)\n    {\n        return this.agents[agentId];\n    }\n\n    getAgents()\n    {\n        return Object.values(this.agents);\n    }\n\n    tick()\n    {\n        const map = this.junctionMap;\n        let currentTick = this.ticks++;\n        let agents = Object.values(this.agents);\n        for(let agent of agents)\n        {\n            if (agent.lastUpdatedTick < currentTick)\n            {\n                agent.lastUpdatedTick = currentTick;\n                // Passing releases at the start of each tick.\n                let passingIndex = agent.passing;\n                if (!isNullJunction(map, passingIndex))\n                {\n                    releasePassing(map, agent, passingIndex);\n                }\n                // Reset agent speeds\n                agent.speed = agent.maxSpeed;\n            }\n        }\n        this.moveAgents(agents);\n    }\n\n    /** @private */\n    moveAgents(agents)\n    {\n        const map = this.junctionMap;\n        let lookingForTargets = [];\n        for(let agent of agents)\n        {\n            let targetIndex = agent.target;\n            if (!isNullJunction(map, targetIndex))\n            {\n                // Already at the end!\n                if (agent.junction === targetIndex)\n                {\n                    agent.clearTarget();\n                    lookingForTargets.push(agent);\n                    continue;\n                }\n                // Move the agent forward.\n                let speed = agent.speed;\n                if (speed > 0)\n                {\n                    let remaining = moveAgentTowards(map, agent, targetIndex, agent.intent, speed);\n                    agent.speed = remaining;\n                    // Did it move?\n                    if (speed < remaining)\n                    {\n                        throw new Error('Agent gained speed after moving? How is that possible?');\n                    }\n                }\n                // Reached the end! What next?\n                if (agent.junction === targetIndex)\n                {\n                    agent.clearTarget();\n                    lookingForTargets.push(agent);\n                }\n            }\n        }\n        // Plan next target.\n        this.planner(lookingForTargets);\n        if (lookingForTargets.length > 0)\n        {\n            // Move them again.\n            this.moveAgents(lookingForTargets);\n        }\n    }\n}\n\nexport class TrafficAgent\n{\n    constructor(id, homeIndex)\n    {\n        this.id = id;\n        this.home = homeIndex;\n        this.junction = NULL_JUNCTION_INDEX;\n        // If outlet is defined, slot must be too.\n        this.outlet = NULL_JUNCTION_INDEX;\n        // If slot is defined, outlet must be too.\n        this.slot = NULL_SLOT_INDEX;\n\n        this.speed = 0;\n        this.maxSpeed = MAX_CART_SPEED;\n\n        // If parked, outlet and slot must be null.\n        this.parking = NULL_JUNCTION_INDEX;\n        this.passing = NULL_JUNCTION_INDEX;\n\n        this.target = NULL_JUNCTION_INDEX;\n        this.nextTarget = NULL_JUNCTION_INDEX;\n        this.intent = NO_JUNCTION_INTENT;\n\n        this.lastUpdatedTick = -1;\n    }\n\n    setTarget(outletIndex, nextIndex, intent)\n    {\n        this.target = outletIndex;\n        this.nextTarget = nextIndex;\n        this.intent = intent;\n    }\n\n    clearTarget()\n    {\n        this.target = NULL_JUNCTION_INDEX;\n        this.nextTarget = NULL_JUNCTION_INDEX;\n        this.intent = NO_JUNCTION_INTENT;\n    }\n}\n\n/**\n * @param {JunctionMap} map \n * @param {Agent} agent \n * @param {JunctionIndex} outletIndex \n * @param {number} speed \n * @returns {number} The remaining speed untravelled.\n */\nexport function moveAgentTowards(map, agent, outletIndex, intent, speed)\n{\n    let juncIndex = agent.junction;\n    let junc = map.getJunction(juncIndex);\n    if (!junc.hasOutlet(outletIndex))\n    {\n        throw new Error(`Missing outlet '${getJunctionCoordsFromIndex(map, outletIndex)}' at junction '${getJunctionCoordsFromIndex(map, juncIndex)}' to move cart towards.`);\n    }\n    let lane = junc.getLane(outletIndex);\n    if (isNullJunction(map, agent.outlet))\n    {\n        // Not on the way yet. Try to merge into a lane.\n        let furthest = getFurthestAvailableSlotInLane(map, lane, 0);\n        if (furthest > 0)\n        {\n            // Move the cart (it takes 1 step to move out of parking).\n            let nextSlot = Math.min(furthest, speed - 1);\n            enterLane(map, agent, juncIndex, outletIndex, nextSlot);\n            return speed - nextSlot;\n        }\n        else\n        {\n            // Blocked at destination but unable to get into it.\n            // Cannot move in as it is blocked.\n            return 0;\n        }\n    }\n    else if (agent.outlet !== outletIndex)\n    {\n        throw new Error('Agent is changing lanes!');\n    }\n    else\n    {\n        // Already on the way. Try to move forward.\n        let prevSlot = agent.slot;\n        let nextSlot = prevSlot + speed;\n        let furthest = getFurthestAvailableSlotInLane(map, lane, prevSlot + 1);\n        // There's no blockers and total movement will exit the lane\n        if (furthest >= lane.length && nextSlot >= lane.length && intent !== NO_JUNCTION_INTENT)\n        {\n            switch(intent)\n            {\n                case PASSING_JUNCTION_INTENT:\n                    if (isNullJunction(map, agent.nextTarget))\n                    {\n                        throw new Error('Agent must have next target if passing junction.');\n                    }\n                    else if (isJunctionPassable(map, outletIndex) && canJunctionLaneAcceptMore(map, outletIndex, agent.nextTarget))\n                    {\n                        // Move onto next junction's lane.\n                        acquirePassing(map, agent, outletIndex);\n                        forceOnJunction(map, agent, outletIndex);\n                        enterLane(map, agent, outletIndex, agent.nextTarget, 0);\n                        // Slow down based on junction resistance.\n                        let resistance = getJunctionResistance(map, outletIndex);\n                        return Math.max(0, nextSlot - lane.length - resistance);\n                    }\n                    else\n                    {\n                        // Move forward to blocker. Any remaining movement is ignored.\n                        nextSlot = Math.min(lane.length - 1, furthest, nextSlot);\n                        moveOnLane(map, agent, juncIndex, outletIndex, nextSlot);\n                        return 0;\n                    }\n                case PARKING_JUNCTION_INTENT:\n                    if (isJunctionParkable(map, outletIndex))\n                    {\n                        // Parking. Any remaining movement is ignored.\n                        forceOnJunction(map, agent, outletIndex);\n                        acquireParking(map, agent, outletIndex);\n                        return 0;\n                    }\n                    else\n                    {\n                        // Waiting to park. Move to end of lane.\n                        nextSlot = lane.length - 1;\n                        moveOnLane(map, agent, juncIndex, outletIndex, nextSlot);\n                        return 0;\n                    }\n            }\n        }\n        else\n        {\n            // There are blockers and will stay within lane. Move as far as possible.\n            nextSlot = Math.min(lane.length - 1, furthest, nextSlot);\n            moveOnLane(map, agent, juncIndex, outletIndex, nextSlot);\n            return 0;\n        }\n    }\n}\n\nexport function getJunctionResistance(map, juncIndex)\n{\n    let junc = getJunctionByIndex(map, juncIndex);\n    return Math.max(0, junc.getInlets().length - 2);\n}\n\nfunction canJunctionLaneAcceptMore(junctionMap, inletIndex, outletIndex)\n{\n    if (inletIndex < 0 || outletIndex < 0) throw new Error('Junction index must be non-negative.');\n    let lane = getJunctionLaneByIndex(junctionMap, inletIndex, outletIndex);\n    if (!lane) throw new Error(`Cannot find lane for given inlet '${getJunctionCoordsFromIndex(junctionMap, inletIndex)}' and outlet '${getJunctionCoordsFromIndex(junctionMap, outletIndex)}'.`);\n    let slot = getFurthestAvailableSlotInLane(junctionMap, lane, 0);\n    return slot >= 0;\n}\n\nfunction getFurthestAvailableSlotInLane(map, lane, initialSlot)\n{\n    if (initialSlot < 0) throw new Error('Slot must be non-negative.');\n    for(let i = initialSlot; i < lane.length; ++i)\n    {\n        if (lane.slots[i])\n        {\n            return i - 1;\n        }\n    }\n    return lane.length;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n */\nexport function isJunctionPassable(map, juncIndex)\n{\n    if (!map.hasJunction(juncIndex)) return false;\n    let junc = map.getJunction(juncIndex);\n    return junc.passing === null;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n */\nexport function acquirePassing(map, agent, juncIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot pass on non-existant junction.');\n    }\n    if (!isJunctionPassable(map, juncIndex))\n    {\n        throw new Error('Cannot pass on blocked junction.');\n    }\n    let junc = map.getJunction(juncIndex);\n    agent.passing = juncIndex;\n    junc.passing = agent.id;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n */\nexport function releasePassing(map, agent, juncIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot release pass on non-existant junction.');\n    }\n    if (agent.passing !== juncIndex)\n    {\n        throw new Error('Cannot release pass for agent not passing at junction.');\n    }\n    let junc = map.getJunction(juncIndex);\n    agent.passing = NULL_JUNCTION_INDEX;\n    junc.passing = null;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} juncIndex \n */\nexport function isJunctionParkable(map, juncIndex)\n{\n    if (!map.hasJunction(juncIndex)) return false;\n    let junc = map.getJunction(juncIndex);\n    return junc.parking < junc.parkingCapacity;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n */\nexport function acquireParking(map, agent, juncIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot park on non-existant junction.');\n    }\n    if (!isJunctionParkable(map, juncIndex))\n    {\n        throw new Error('Junction is already full for parking.');\n    }\n    let junc = map.getJunction(juncIndex);\n    agent.parking = juncIndex;\n    junc.parking += 1;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n */\nexport function releaseParking(map, agent, juncIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot release park on non-existant junction.');\n    }\n    if (agent.parking !== juncIndex)\n    {\n        throw new Error('Cannot release parking for agent not parked at junction.');\n    }\n    let junc = map.getJunction(juncIndex);\n    if (junc.parking <= 0)\n    {\n        throw new Error('Cannot release parking at junction with no agents.');\n    }\n    agent.parking = NULL_JUNCTION_INDEX;\n    junc.parking -= 1;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n * @param {JunctionIndex} outletIndex \n * @param {number} slotIndex \n */\nexport function enterLane(map, agent, juncIndex, outletIndex, slotIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot park on non-existant junction.');\n    }\n    if (agent.junction !== juncIndex)\n    {\n        throw new Error('Cannot enter lane with agent not on same junction.');\n    }\n    if (!isNullJunction(map, agent.outlet))\n    {\n        throw new Error('Cannot enter lane when agent already on another.');\n    }\n    let junc = map.getJunction(juncIndex);\n    let lane = junc.lanes[outletIndex];\n    agent.outlet = outletIndex;\n    agent.slot = slotIndex;\n    lane.slots[slotIndex] = agent.id;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n * @param {JunctionIndex} outletIndex \n * @param {number} slotIndex \n */\nexport function moveOnLane(map, agent, juncIndex, outletIndex, slotIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot park on non-existant junction.');\n    }\n    if (agent.junction !== juncIndex)\n    {\n        throw new Error('Cannot move on lane with agent not on same junction.');\n    }\n    if (agent.outlet !== outletIndex)\n    {\n        throw new Error('Cannot move on lane with agent not on same outlet.');\n    }\n    let junc = map.getJunction(juncIndex);\n    let lane = junc.lanes[outletIndex];\n    let prevSlot = agent.slot;\n    agent.slot = slotIndex;\n    lane.slots[prevSlot] = undefined;\n    lane.slots[slotIndex] = agent.id;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n * @param {JunctionIndex} outletIndex \n */\nexport function exitLane(map, agent, juncIndex, outletIndex)\n{\n    let junc = map.getJunction(juncIndex);\n    let lane = junc.lanes[outletIndex];\n    lane.slots[agent.slot] = undefined;\n    agent.outlet = NULL_JUNCTION_INDEX;\n    agent.slot = NULL_SLOT_INDEX;\n}\n\n/**\n * @param {JunctionMap} map \n * @param {TrafficAgent} agent \n * @param {JunctionIndex} juncIndex \n */\nexport function forceOnJunction(map, agent, juncIndex)\n{\n    if (!map.hasJunction(juncIndex))\n    {\n        throw new Error('Cannot force on non-existant junction.');\n    }\n    let agentIndex = agent.junction;\n    // Has previous location?\n    if (!isNullJunction(map, agentIndex))\n    {\n        // Get out of lane\n        let outletIndex = agent.outlet;\n        if (!isNullJunction(map, outletIndex))\n        {\n            exitLane(map, agent, agentIndex, outletIndex);\n        }\n        // Get out of parking\n        let parkingIndex = agent.parking;\n        if (!isNullJunction(map, parkingIndex))\n        {\n            releaseParking(map, agent, parkingIndex);\n        }\n    }\n    // TODO: This is in limbo on a junction. This should ALWAYS be followed by a forceOnLane(), park(), etc.\n    agent.junction = juncIndex;\n    agent.outlet = NULL_JUNCTION_INDEX;\n    agent.slot = NULL_SLOT_INDEX;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx \n * @param {JunctionMap} map \n * @param {TrafficSimulator} traffic \n */\nexport function drawAgents(ctx, map, traffic, cellSize)\n{\n    let agentRadius = cellSize / 8;\n    for(let agent of traffic.getAgents())\n    {\n        let [x, y] = getJunctionCoordsFromIndex(map, agent.junction);\n        ctx.fillStyle = 'red';\n        ctx.fillRect(\n            (x + 0.5) * cellSize - agentRadius,\n            (y + 0.5) * cellSize - agentRadius,\n            agentRadius * 2,\n            agentRadius * 2);\n        if (agent.target !== -1)\n        {\n            let [targetX, targetY] = getJunctionCoordsFromIndex(map, agent.target);\n            ctx.fillStyle = 'green';\n            ctx.fillRect(\n                (targetX + 0.5) * cellSize - agentRadius,\n                (targetY + 0.5) * cellSize - agentRadius,\n                agentRadius * 2,\n                agentRadius * 2);\n        }\n        if (agent.outlet !== -1)\n        {\n            let [outletX, outletY] = getJunctionCoordsFromIndex(map, agent.outlet);\n            ctx.strokeStyle = 'gold';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(\n                (outletX + 0.5) * cellSize - agentRadius,\n                (outletY + 0.5) * cellSize - agentRadius,\n                agentRadius * 2,\n                agentRadius * 2);\n        }\n    }\n}", "/**\n * @template T\n * @typedef NodeCache<T>\n * @property {Record<T, number>} fscore\n * @property {Record<T, number>} gscore\n * @property {Record<T, number>} hscore\n * @property {Record<T, T>} parents\n */\n\n/**\n * @template T\n * @param {T} startId The unique representation of the starting position. Must be deterministic.\n * @param {T} goalId The unique representation of the stopping position. Must be deterministic.\n * @param {(node: T) => Array<T>} neighborsCallback Get all reachable neighbors from the given node.\n * @param {(from: T, to: T) => number} heuristicCallback Get the heuristics score across the two nodes.\n * @param {(from: T, to: T) => number} weightsCallback Get the weight if travelling between the two nodes.\n * @returns {Array<T>} If the goal is not reachable from the start, it will return an empty array.\n */\nexport function astarSearch(startId, goalId, neighborsCallback, heuristicCallback, weightsCallback)\n{\n    /** @type {NodeCache<T>} */\n    let cache = createCache();\n    cacheNode(cache, startId);\n    let opened = new Set();\n    let closed = new Set();\n    opened.add(startId);\n    while(opened.size > 0)\n    {\n        let minNodeId;\n        for(let openNodeId of opened)\n        {\n            if (minNodeId)\n            {\n                if (cache.fscore[openNodeId] < cache.fscore[minNodeId])\n                {\n                    minNodeId = openNodeId;\n                }\n            }\n            else\n            {\n                minNodeId = openNodeId;\n            }\n        }\n\n        let currentNodeId = minNodeId;\n        if (currentNodeId === goalId)\n        {\n            // Completed!\n            let result = [];\n            while(cache.parents[currentNodeId])\n            {\n                result.push(currentNodeId);\n                currentNodeId = cache.parents[currentNodeId];\n            }\n            result.push(currentNodeId);\n            return result.reverse();\n        }\n        else\n        {\n            // Not there yet...\n            closed.add(currentNodeId);\n            opened.delete(currentNodeId);\n            for(let neighborNodeId of neighborsCallback(currentNodeId))\n            {\n                if (closed.has(neighborNodeId)) continue;\n                let weight = weightsCallback(currentNodeId, neighborNodeId);\n                if (!Number.isFinite(weight)) continue;\n                let g = cache.gscore[currentNodeId] + weight;\n                let flag = false;\n                if (!opened.has(neighborNodeId))\n                {\n                    flag = true;\n                    cacheNode(cache, neighborNodeId);\n                    cache.hscore[neighborNodeId] = heuristicCallback(neighborNodeId, goalId);\n                    opened.add(neighborNodeId);\n                }\n                else if (g < cache.gscore[neighborNodeId])\n                {\n                    flag = true;\n                }\n                // Use the new g score if better\n                if (flag)\n                {\n                    cache.parents[neighborNodeId] = currentNodeId;\n                    cache.gscore[neighborNodeId] = g;\n                    cache.fscore[neighborNodeId] = g + cache.hscore[neighborNodeId];\n                }\n            }\n        }\n    }\n    return [];\n}\n\n/**\n * @template T\n * @returns {NodeCache<T>}\n */\nfunction createCache()\n{\n    return {\n        fscore: {},\n        gscore: {},\n        hscore: {},\n        parents: {},\n    };\n}\n\n/**\n * @template T\n * @param {NodeCache<T>} cache \n * @param {T} id \n * @param {number} f \n * @param {number} g \n * @param {number} h \n * @param {T} parent \n * @returns {T}\n */\nfunction cacheNode(cache, id, f = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, h = Number.NaN, parent = null)\n{\n    cache.fscore[id] = f;\n    cache.gscore[id] = g;\n    cache.hscore[id] = h;\n    cache.parents[id] = parent;\n    return id;\n}\n", "import { uuid } from '@milque/util';\nimport { getJunctionCoordsFromIndex } from '../junction/Junction.js';\nimport { astarSearch } from '../util/astar.js';\n\n/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n */\n\nexport const END_OF_PATH = -1;\n\nexport class PathFinder\n{\n    /**\n     * @param {JunctionMap} junctionMap \n     */\n    constructor(junctionMap)\n    {\n        /** @private */\n        this.junctionMap = junctionMap;\n\n        /** @private */\n        this.paths = {};\n        /** @private */\n        this.used = new Uint8Array(junctionMap.length);\n        /** @private */\n        this.weighted = new Float32Array(junctionMap.length).fill(1);\n\n        /** @private */\n        this.neighbors = this.neighbors.bind(this);\n        /** @private */\n        this.heuristics = this.heuristics.bind(this);\n        /** @private */\n        this.weights = this.weights.bind(this);\n    }\n\n    acquirePath(fromIndex, toIndex)\n    {\n        if (!this.junctionMap.hasJunction(fromIndex) || !this.junctionMap.hasJunction(toIndex))\n        {\n            throw new Error('Cannot acquire path between non-existant junctions.');\n        }\n        let pathId = uuid();//`${fromIndex}:${toIndex}`;\n        let path;\n        if (pathId in this.paths)\n        {\n            path = this.paths[pathId];\n        }\n        else\n        {\n            path = astarSearch(fromIndex, toIndex, this.neighbors, this.heuristics, this.weights);\n            if (path.length <= 0) return null;\n            this.paths[pathId] = path;\n        }\n        for(let node of path)\n        {\n            let prev = this.used[node];\n            this.used[node] = prev + 1;\n        }\n        return pathId;\n    }\n\n    releasePath(pathId)\n    {\n        let path = this.paths[pathId];\n        if (!path)\n        {\n            throw new Error('Cannot release non-existant path.');\n        }\n        delete this.paths[pathId];\n        for(let node of path)\n        {\n            this.used[node] -= 1;\n        }\n    }\n\n    prunePath(pathId, pathIndex)\n    {\n        let path = this.paths[pathId];\n        if (!path)\n        {\n            throw new Error('Cannot prune non-existant path.');\n        }\n        for(let i = 0; i < pathIndex; ++i)\n        {\n            let node = path[i];\n            if (node !== END_OF_PATH)\n            {\n                this.used[node] -= 1;\n                path[i] = END_OF_PATH;\n            }\n        }\n    }\n\n    isJunctionUsedForAnyPath(juncIndex)\n    {\n        return this.used[juncIndex] > 0;\n    }\n\n    getPathById(pathId)\n    {\n        return this.paths[pathId];\n    }\n\n    getNextInPath(pathId, pathIndex)\n    {\n        let path = this.paths[pathId];\n        if (pathIndex <= 0)\n        {\n            return path[0];\n        }\n        else if (pathIndex >= path.length)\n        {\n            return END_OF_PATH;\n        }\n        else\n        {\n            return path[pathIndex];\n        }\n    }\n\n    setWeight(juncIndex, weight)\n    {\n        this.weighted[juncIndex] = weight;\n    }\n\n    resetWeight(juncIndex)\n    {\n        this.weighted[juncIndex] = 1;\n    }\n\n    getWeight(juncIndex)\n    {\n        return this.weighted[juncIndex];\n    }\n\n    /** @private */\n    neighbors(node)\n    {\n        return this.junctionMap.getJunction(node).getOutlets();\n    }\n\n    /** @private */\n    heuristics(from, to)\n    {\n        let [fromX, fromY] = getJunctionCoordsFromIndex(this.junctionMap, from);\n        let [toX, toY] = getJunctionCoordsFromIndex(this.junctionMap, to);\n        return Math.abs(toX - fromX) + Math.abs(toY - fromY);\n    }\n\n    /** @private */\n    weights(from, to)\n    {\n        return this.weighted[to];\n    }\n}\n", "export class Cargo\n{\n    constructor(mainColor, shadowColor)\n    {\n        this.color = {\n            main: mainColor,\n            shadow: shadowColor,\n        };\n    }\n}\n\nexport const CARGO = {\n    lime: new Cargo('lime', 'green'),\n    tomato: new Cargo('tomato', 'maroon'),\n    banana: new Cargo('yellow', 'gold'),\n    blueberry: new Cargo('aqua', 'royalblue'),\n    plum: new Cargo('plum', 'blueviolet'),\n};\nexport const CARGO_KEYS = Object.keys(CARGO);\n\nexport function randomCargo()\n{\n    return CARGO_KEYS[Math.floor(Math.random() * CARGO_KEYS.length)];\n}\n\nexport function getCargoMainColor(cargo)\n{\n    return CARGO[cargo].color.main;\n}\n\nexport function getCargoShadowColor(cargo)\n{\n    return CARGO[cargo].color.shadow;\n}\n\nexport function isCargoAcceptable(sourceCargo, targetCargo)\n{\n    return sourceCargo === targetCargo;\n}\n", "/** @typedef {import('./TrafficSimulator.js').TrafficSimulator} TrafficSimulator */\n\nimport { cycle, lerp, lookAt2 } from '@milque/util';\nimport { getCargoMainColor, getCargoShadowColor } from '../acreworld/Cargo.js';\nimport { getJunctionCoordsFromIndex, getJunctionIndexFromCoords, LANE_LENGTH } from '../junction/Junction.js';\n\nexport const NULL_JUNCTION_INDEX = -1;\nexport const NULL_SLOT_INDEX = -1;\n\nexport const FRAMES_PER_TICK = 30;\nexport const FRAMES_PER_HALF_TICK = FRAMES_PER_TICK / 2;\nexport const OFFSET_FRAMES = 5;\n\nexport class CartManager\n{\n    /**\n     * @param {TrafficSimulator} trafficSimulator \n     */\n    constructor(junctionMap, trafficSimulator)\n    {\n        this.junctionMap = junctionMap;\n        this.trafficSimulator = trafficSimulator;\n        /** @type {Record<string, Cart>} */\n        this.carts = {};\n    }\n\n    createCart(coordX, coordY, radians, cargo)\n    {\n        const map = this.junctionMap;\n        const traffic = this.trafficSimulator;\n        let homeIndex = getJunctionIndexFromCoords(map, coordX, coordY);\n        let agent = traffic.spawnAgent(homeIndex);\n        let cartId = agent.id;\n        let cart = new Cart(cartId, coordX + 0.5, coordY + 0.5, radians, cargo);\n        this.carts[cartId] = cart;\n        return cart;\n    }\n\n    getCartById(cartId)\n    {\n        return this.carts[cartId];\n    }\n\n    getCartByAgentId(agentId)\n    {\n        return this.carts[agentId];\n    }\n}\n\nexport class Cart\n{\n    constructor(id, coordX, coordY, radians, cargo)\n    {\n        this.id = id;\n\n        this.prevX = coordX;\n        this.prevY = coordY;\n        this.prevJunction = NULL_JUNCTION_INDEX;\n        this.prevOutlet = NULL_JUNCTION_INDEX;\n        this.prevSlot = NULL_SLOT_INDEX;\n\n        this.x = coordX;\n        this.y = coordY;\n        this.radians = radians;\n\n        this.cargo = cargo;\n    }\n\n    getAgentId()\n    {\n        return this.id;\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CartManager} cartManager\n * @param {number} cellSize\n */\nexport function drawCarts(ctx, cartManager, framesToTick, framesPerTick, cellSize)\n{\n    const traffic = cartManager.trafficSimulator;\n    const map = cartManager.junctionMap;\n\n    const dt = framesToTick / framesPerTick;\n    const LANE_SLOT_COUNT = LANE_LENGTH;\n    for(let cart of Object.values(cartManager.carts))\n    {\n        let agent = traffic.getAgent(cart.getAgentId());\n        let currentJunction = agent.junction;\n        let currentOutlet = agent.outlet;\n        let currentSlot = agent.slot;\n        let currX = cart.x;\n        let currY = cart.y;\n        let currRadians = cart.radians;\n        if (currentJunction !== -1 && currentOutlet !== -1)\n        {\n            if (framesToTick <= 0)\n            {\n                // Capture current state.\n                cart.prevX = cart.x;\n                cart.prevY = cart.y;\n            }\n            else if (framesToTick >= framesPerTick)\n            {\n                // Capture for next tick (this is the last frame)\n                cart.prevJunction = currentJunction;\n                cart.prevOutlet = currentOutlet;\n                cart.prevSlot = currentSlot;\n            }\n\n            let nextX, nextY;\n            // TODO: Although this is more accurate, it is less \"smooth\". The wrong way looks nicer.\n            let remainingPrevSlots = cart.prevSlot !== NULL_SLOT_INDEX\n                ? LANE_SLOT_COUNT - cart.prevSlot\n                : 0;\n            let remainingCurrentSlots = cart.currentSlot;\n            let totalRemainingSlots = remainingCurrentSlots + remainingPrevSlots;\n            if (dt < remainingPrevSlots / totalRemainingSlots)\n            {\n                // Travelling the remainder of the previous junction\n                [nextX, nextY] = getLanePosition(map, cart.prevJunction, cart.prevOutlet, 0, 1);\n            }\n            else\n            {\n                // Travelling the remainder of the current junction\n                [nextX, nextY] = getLanePosition(map, currentJunction, currentOutlet, 0, currentSlot / LANE_SLOT_COUNT);\n            }\n            let prevX = cart.prevX;\n            let prevY = cart.prevY;\n            let currX = lerp(prevX, nextX, dt);\n            let currY = lerp(prevY, nextY, dt);\n            let dx = nextX - prevX;\n            let dy = nextY - prevY;\n            let currRadians;\n            if (Math.abs(dx) <= Number.EPSILON && Math.abs(dy) <= Number.EPSILON)\n            {\n                currRadians = cart.radians;\n            }\n            else\n            {\n                let nextRadians = Math.atan2(dy, dx);\n                let prevRadians = cart.radians;\n                let diffRadians = cycle(nextRadians - prevRadians, -Math.PI, Math.PI);\n                currRadians = lookAt2(prevRadians, nextRadians, diffRadians / (Math.PI * 2));\n            }\n            cart.x = currX;\n            cart.y = currY;\n            cart.radians = currRadians;\n        }\n        let mainColor = getCargoMainColor(cart.cargo);\n        let shadowColor = getCargoShadowColor(cart.cargo);\n        drawCart(ctx, currX * cellSize, currY * cellSize, currRadians, mainColor, shadowColor, cellSize);\n    }\n}\n\nexport function drawCart(ctx, x, y, rotation, mainColor, shadowColor, cellSize)\n{\n    let width = cellSize * 0.2;\n    let height = cellSize * 0.3;\n    let halfWidth = width / 2;\n    let halfHeight = height / 2;\n    let padding = 2;\n    let hoodSize = height * 0.4;\n    let topSize = height * 0.2;\n    ctx.translate(x, y);\n    ctx.rotate(rotation + Math.PI / 2);\n    {\n        ctx.fillStyle = shadowColor;\n        ctx.fillRect(-halfWidth, -halfHeight, width, height);\n        ctx.fillStyle = mainColor;\n        ctx.fillRect(-halfWidth + padding, -halfHeight + hoodSize, width - padding * 2, hoodSize + topSize);\n        ctx.fillStyle = 'gold';\n        ctx.fillRect(-halfWidth + padding, -halfHeight, padding, padding);\n        ctx.fillRect(halfWidth - padding * 2, -halfHeight, padding, padding);\n    }\n    ctx.rotate(-rotation - Math.PI / 2);\n    ctx.translate(-x, -y);\n}\n\nconst HALF_PI = Math.PI * 0.5;\n\n/**\n * @param {JunctionMap} map \n * @param {JunctionIndex} inletIndex \n * @param {JunctionIndex} outletIndex \n * @param {number} progress \n */\nfunction getLanePosition(map, inletIndex, outletIndex, laneIndex, progress)\n{\n    let [inx, iny] = getJunctionCoordsFromIndex(map, inletIndex);\n    let [outx, outy] = getJunctionCoordsFromIndex(map, outletIndex);\n    let dx = outx - inx;\n    let dy = outy - iny;\n    let dr = Math.atan2(dy, dx);\n    let lx = Math.cos(dr + HALF_PI) * (0.15 + 0.2 * laneIndex);\n    let ly = Math.sin(dr + HALF_PI) * (0.15 + 0.2 * laneIndex);\n    return [\n        (inx + 0.5) + lx + dx * progress,\n        (iny + 0.5) + ly + dy * progress,\n    ];\n}\n ", "import { isCargoAcceptable } from '../acreworld/Cargo.js';\nimport { NULL_JUNCTION_INDEX } from './TrafficSimulator.js';\n\nconst CART_STATE = {\n    READY: 0,\n    SENDING: 1,\n    PROCESSING: 2,\n    RETURNING: 3,\n    RESTING: 4,\n};\n\n/**\n * @param {AcreWorld} world \n * @param {PathFinder} pathFinder \n * @param {number} fromIndex \n * @param {number} toIndex \n * @returns \n */\nexport function getPathToJunction(world, pathFinder, fromIndex, toIndex)\n{\n    return pathFinder.acquirePath(fromIndex, toIndex);\n}\n\n/**\n * @param {AcreWorld}\n * @param {JunctionMap} junctionMap \n * @param {Cart} cart \n */\nexport function findValidDestination(world, map, cart)\n{\n    if (!cart) throw new Error('Non-existant cart.');\n    let factories = Object.values(world.factory).filter(factory => isCargoAcceptable(factory.cargo, cart.cargo));\n    if (factories.length <= 0) return NULL_JUNCTION_INDEX;\n    let i = Math.floor(Math.random() * factories.length);\n    let factory = factories[i];\n    let parking = factory.parking;\n    if (parking.length <= 0) return NULL_JUNCTION_INDEX;\n    i = Math.floor(Math.random() * parking.length);\n    return parking[i];\n}\n", "/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n * @typedef {import('../junction/Junction.js').JunctionIndex} JunctionIndex\n * @typedef {import('../cartworld/PathFinder.js').PathFinder} PathFinder\n * @typedef {import('./Persistence.js').Persistence} Persistence\n */\n\nimport { getJunctionCoordsFromIndex, removeOnlyJunctionConnections } from '../junction/Junction.js';\n\nexport class Demolition\n{\n    /**\n     * @param {JunctionMap} junctionMap \n     * @param {PathFinder} pathFinder\n     * @param {Persistence} persistence\n     */\n    constructor(junctionMap, pathFinder, persistence)\n    {\n        /** @private */\n        this.junctionMap = junctionMap;\n        /** @private */\n        this.pathFinder = pathFinder;\n        /** @private */\n        this.persistence = persistence;\n\n        /** @private */\n        this.demolished = new Uint8Array(junctionMap.length);\n        /** @private */\n        this.lanes = {};\n    }\n\n    update()\n    {\n        let len = this.junctionMap.length;\n        for(let i = 0; i < len; ++i)\n        {\n            if (this.isJunctionMarkedForDemolition(i))\n            {\n                if (!this.junctionMap.hasJunction(i))\n                {\n                    throw new Error('Trying to demolish non-existant, but marked, junction.');\n                }\n                if (!this.pathFinder.isJunctionUsedForAnyPath(i))\n                {\n                    performDemolish(this.junctionMap, this.persistence, i, this.lanes[i]);\n                    this.unmarkForDemolition(i);\n                }\n            }\n        }\n    }\n\n    clear()\n    {\n        let len = this.junctionMap.length;\n        for(let i = 0; i < len; ++i)\n        {\n            if (this.isJunctionMarkedForDemolition(i))\n            {\n                this.unmarkForDemolition(i);\n            }\n        }\n    }\n\n    markForDemolition(juncIndex)\n    {\n        let junc = this.junctionMap.getJunction(juncIndex);\n        this.lanes[juncIndex] = junc.getOutlets();\n        this.demolished[juncIndex] = 1;\n        this.pathFinder.setWeight(juncIndex, Number.POSITIVE_INFINITY);\n    }\n\n    unmarkForDemolition(juncIndex)\n    {\n        this.demolished[juncIndex] = 0;\n        delete this.lanes[juncIndex];\n        this.pathFinder.resetWeight(juncIndex);\n    }\n\n    unmarkLaneForDemolition(juncIndex, outletIndex)\n    {\n        if (!this.isJunctionMarkedForDemolition(juncIndex)) return;\n        let lanes = this.lanes[juncIndex];\n        let i = lanes.indexOf(outletIndex);\n        if (i < 0) return;\n        lanes.splice(i, 1);\n    }\n\n    isJunctionMarkedForDemolition(juncIndex)\n    {\n        return this.demolished[juncIndex] > 0;\n    }\n\n    isLaneMarkedForDemolition(juncIndex, outletIndex)\n    {\n        return this.isJunctionMarkedForDemolition(juncIndex) && this.lanes[juncIndex].includes(outletIndex);\n    }\n}\n \nfunction performDemolish(map, persistence, juncIndex, outlets)\n{\n    if (persistence.isPersistentJunction(juncIndex))\n    {\n        let unpersistent = outlets.filter(outlet => !persistence.isPersistentJunction(outlet));\n        removeOnlyJunctionConnections(map, juncIndex, unpersistent);\n    }\n    else\n    {\n        removeOnlyJunctionConnections(map, juncIndex, outlets);\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx \n * @param {JunctionMap} map \n * @param {Demolition} demolition\n * @param {number} cellSize\n */\nexport function drawDemolition(ctx, map, demolition, cellSize)\n{\n    const juncSize = cellSize / 2;\n    const laneRadius = juncSize;\n    ctx.lineWidth = laneRadius;\n    ctx.lineCap = 'round';\n    ctx.strokeStyle = '#660000';\n    for(let y = 0; y < map.height; ++y)\n    {\n        for(let x = 0; x < map.width; ++x)\n        {\n            let i = x + y * map.width;\n            if (!map.hasJunction(i)) continue;\n            if (!demolition.isJunctionMarkedForDemolition(i)) continue;\n            let junc = map.getJunction(i);\n            let beginX = (x + 0.5) * cellSize;\n            let beginY = (y + 0.5) * cellSize;\n            for(let outlet of junc.outlets)\n            {\n                if (!demolition.isLaneMarkedForDemolition(i, outlet)) continue;\n                let [xx, yy] = getJunctionCoordsFromIndex(map, outlet);\n                let endX = (xx + 0.5) * cellSize;\n                let endY = (yy + 0.5) * cellSize;\n                ctx.beginPath();\n                ctx.moveTo(beginX, beginY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n        }\n    }\n}", "import { connectJunctions, getJunctionIndexFromCoords, getJunctionIndexFromJunction, isJunctionWithinBounds, putJunction } from '../junction/Junction.js';\nimport { getDirectionalVectorFromEncoding, isDirectionalEncoding } from '../util/Directional.js';\nimport { getCargoMainColor, getCargoShadowColor } from './Cargo.js';\n\n/** @typedef {import('./AcreWorld.js').AcreWorld} AcreWorld */\n\n/**\n * @param {AcreWorld} world \n * @param {number} juncX \n * @param {number} juncY \n * @param {number} outletDirection\n */\nexport function canPlaceHousing(world, juncX, juncY, outletDirection)\n{\n    const map = world.junctionMap;\n    if (!isJunctionWithinBounds(map, juncX, juncY)) return false;\n    let juncIndex = getJunctionIndexFromCoords(map, juncX, juncY);\n    if (map.hasJunction(juncIndex)) return false;\n    if (!isDirectionalEncoding(outletDirection)) return false;\n    let [dx, dy] = getDirectionalVectorFromEncoding(outletDirection);\n    let juncDX = juncX + dx;\n    let juncDY = juncY + dy;\n    let juncDIndex = getJunctionIndexFromCoords(map, juncDX, juncDY);\n    if (!isJunctionWithinBounds(map, juncDX, juncDY)) return false;\n    const solids = world.solids;\n    if (solids.isSolidJunction(juncDIndex)) return false;\n    return true;\n}\n\n/**\n * @param {AcreWorld} world \n * @param {number} juncX \n * @param {number} juncY \n * @param {number} outletDirection\n * @param {string} cargo\n */\nexport function placeHousing(world, juncX, juncY, outletDirection, cargo)\n{\n    const map = world.junctionMap;\n    let [dx, dy] = getDirectionalVectorFromEncoding(outletDirection);\n    let outletX = juncX + dx;\n    let outletY = juncY + dy;\n    if (!isJunctionWithinBounds(map, outletX, outletY))\n    {\n        throw new Error('Cannot place outlet outside of boundary.');\n    }\n    let juncIndex = getJunctionIndexFromCoords(map, juncX, juncY);\n    let offsetIndex = getJunctionIndexFromCoords(map, outletX, outletY);\n    putJunction(map, juncX, juncY, 2);\n    world.solids.markSolidJunction(juncIndex);\n    if (!map.hasJunction(offsetIndex))\n    {\n        putJunction(map, outletX, outletY, 0);\n    }\n    world.directable.markDirectableJunction(juncIndex, offsetIndex);\n    world.persistence.markPersistentJunction(juncIndex, offsetIndex);\n    connectJunctions(map, juncIndex, offsetIndex);\n    connectJunctions(map, offsetIndex, juncIndex);\n\n    let id = juncX + juncY * map.width;\n    let cartA = world.cartManager.createCart(juncX, juncY, Math.atan2(dy, dx), cargo);\n    let cartB = world.cartManager.createCart(juncX, juncY, Math.atan2(dy, dx), cargo);\n    world.housing[id] = {\n        coordX: juncX,\n        coordY: juncY,\n        junction: juncIndex,\n        cargo,\n        carts: [\n            cartA.id,\n            cartB.id,\n        ]\n    };\n}\n\nexport function isHousingAtJunction(world, juncX, juncY)\n{\n    let housingId = juncX + juncY * world.junctionMap.width;\n    return housingId in world.housing;\n}\n\nexport function isFactoryAtJunction(world, juncX, juncY)\n{\n    for(let factory of Object.values(world.factory))\n    {\n        if (juncX >= factory.coordX\n            && juncY >= factory.coordY\n            && juncX < factory.coordX + factory.width\n            && juncY < factory.coordY + factory.height) return true;\n    }\n}\n\n/**\n * @param {AcreWorld} world \n * @param {number} juncX \n * @param {number} juncY \n * @param {string} cargo\n */\nexport function placeFactory(world, juncX, juncY, cargo)\n{\n    const map = world.junctionMap;\n    if (!isJunctionWithinBounds(map, juncX, juncY)\n        || !isJunctionWithinBounds(map, juncX + 3, juncY + 3))\n    {\n        throw new Error('Cannot place factory out of bounds.');\n    }\n\n    let width = 2;\n    let height = 3;\n    for(let i = 0; i < width; ++i)\n    {\n        for(let j = 0; j < height; ++j)\n        {\n            let juncIndex = (juncX + i + 1) + (juncY + j) * map.width;\n            world.solids.markSolidJunction(juncIndex);\n        }\n    }\n\n    let indexA = getJunctionIndexFromCoords(map, juncX, juncY + 2);\n    if (!map.hasJunction(map, indexA))\n    {\n        putJunction(map, juncX, juncY + 2, 0);\n    }\n    else\n    {\n        map.getJunction(indexA);\n    }\n    // This is inside the solid, therefore always no junction.\n    let indexB = getJunctionIndexFromCoords(map, juncX + 1, juncY + 2);\n    putJunction(map, juncX + 1, juncY + 2, 4);\n    world.persistence.markPersistentJunction(indexA, indexB);\n    connectJunctions(map, indexA, indexB);\n    connectJunctions(map, indexB, indexA);\n    let id = juncX + juncY * map.width;\n    world.factory[id] = {\n        coordX: juncX,\n        coordY: juncY,\n        width,\n        height,\n        cargo,\n        entries: [\n            indexA,\n        ],\n        parking: [\n            indexB,\n        ]\n    };\n}\n \nexport function drawHousings(ctx, world, cellSize)\n{\n    for(let housing of Object.values(world.housing))\n    {\n        drawHousing(\n            ctx, housing.coordX, housing.coordY,\n            getCargoMainColor(housing.cargo),\n            getCargoShadowColor(housing.cargo),\n            cellSize);\n    }\n}\n\nfunction drawHousing(ctx, cellX, cellY, mainColor, shadowColor, cellSize)\n{\n    let size = cellSize * 0.8;\n    let margin = (cellSize * 0.2) / 2;\n    let x = cellX * cellSize + margin;\n    let y = cellY * cellSize + margin;\n    ctx.fillStyle = mainColor;\n    ctx.fillRect(x, y, size, size);\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(x, y + (size / 2), size, size / 2);\n}\n\nexport function drawFactories(ctx, world, cellSize)\n{\n    for(let factory of Object.values(world.factory))\n    {\n        let mainColor = getCargoMainColor(factory.cargo);\n        let shadowColor = getCargoShadowColor(factory.cargo);\n        drawFactory(ctx, factory.coordX, factory.coordY, mainColor, shadowColor, cellSize);\n    }\n}\n\nfunction drawFactory(ctx, cellX, cellY, mainColor, shadowColor, cellSize)\n{\n    let margin = cellSize * 0.1;\n    let x = cellX * cellSize + margin;\n    let y = cellY * cellSize + margin;\n    ctx.fillStyle = '#666666';\n    ctx.fillRect(x + cellSize, y, cellSize * 2 - margin * 2, cellSize * 3 - margin * 2);\n    let padding = cellSize * 0.1;\n    ctx.fillStyle = mainColor;\n    let xx = x + cellSize + padding;\n    let yy = y + padding;\n    let ww = cellSize * 2 - margin * 2 - padding * 2;\n    let hh = cellSize * 2 - margin * 2 - padding * 2;\n    ctx.fillRect(xx, yy, ww, hh);\n    ctx.fillStyle = shadowColor;\n    ctx.fillRect(xx, yy + hh / 2, ww, hh / 2);\n}\n", "/**\n * @typedef {import('../junction/Junction.js').JunctionMap} JunctionMap\n * @typedef {import('../junction/Junction.js').JunctionIndex} JunctionIndex\n */\n\nexport class Solids\n{\n    /**\n     * @param {JunctionMap} junctionMap \n     */\n    constructor(junctionMap)\n    {\n        this.junctionMap = junctionMap;\n        /** @type {Record<string, Array<JunctionIndex>>} */\n        this.solids = new Uint8Array(junctionMap.length);\n    }\n\n    clear()\n    {\n        this.solids = {};\n    }\n\n    markSolidJunction(juncIndex)\n    {\n        this.solids[juncIndex] = 1;\n    }\n\n    unmarkSolidJunction(juncIndex)\n    {\n        this.solids[juncIndex] = 0;\n    }\n\n    isSolidJunction(juncIndex)\n    {\n        return this.solids[juncIndex];\n    }\n}\n\nexport function drawSolids(ctx, world, map, cellSize, color = '#663366')\n{\n    for(let y = 0; y < map.height; ++y)\n    {\n        for(let x = 0; x < map.width; ++x)\n        {\n            let i = x + y * map.width;\n            if (world.solids.isSolidJunction(i))\n            {\n                ctx.fillStyle = color;\n                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);\n            }\n        }\n    }\n}\n", "import { CARGO_KEYS,  } from './Cargo.js';\n\nexport class ScoreKeeper\n{\n    constructor()\n    {\n        this.cargos = {};\n        for(let cargo of CARGO_KEYS)\n        {\n            this.cargos[cargo] = 0;\n        }\n    }\n\n    recordCargo(cargo, units)\n    {\n        let prev = this.cargos[cargo];\n        this.cargos[cargo] = prev + units;\n    }\n\n    getCargoCount(cargo)\n    {\n        return this.cargos[cargo];\n    }\n}\n", "import { randomSingleDirectionalEncoding } from '../util/Directional.js';\nimport { connectJunctions, drawJunctions, drawLanes, drawOutlets, getJunctionCoordsFromIndex, getJunctionIndexFromCoords, isJunctionConnectedTo, isJunctionWithinBounds, isNullJunction, JunctionMap, putJunction, randomOutletJunctionFromJunction } from '../junction/Junction.js';\nimport { drawGrid } from '../render2d.js';\nimport { Directable, tryFindValidChildDirectionForDirectable } from './Directable.js';\nimport { Persistence } from './Persistence.js';\nimport { CURSOR_ACTION, tryRoadInteraction } from './RoadMaker.js';\nimport { drawAgents, NULL_JUNCTION_INDEX, PARKING_JUNCTION_INTENT, PASSING_JUNCTION_INTENT, TrafficSimulator } from '../cartworld/TrafficSimulator.js';\nimport { PathFinder } from '../cartworld/PathFinder.js';\nimport { CartManager, drawCarts, FRAMES_PER_TICK } from '../cartworld/CartManager.js';\nimport { findValidDestination, getPathToJunction } from '../cartworld/Navigator.js';\nimport { Demolition, drawDemolition } from './Demolition.js';\nimport { canPlaceHousing, drawFactories, drawHousings, isHousingAtJunction, placeFactory, placeHousing } from './Housing.js';\nimport { drawSolids, Solids } from './Solids.js';\nimport { ScoreKeeper } from './ScoreKeeper.js';\nimport { CARGO_KEYS, getCargoMainColor } from './Cargo.js';\n\nexport const CELL_SIZE = 32;\nexport const DRAG_MARGIN = 0.9;\n\nexport class AcreWorld\n{\n    constructor(width, height)\n    {\n        this.cursor = {\n            screenX: 0,\n            screenY: 0,\n            dragCellX: 0,\n            dragCellY: 0,\n            status: 0,\n        };\n\n        this.debugMode = false;\n        this.framesToTick = 0;\n\n        this.spawnTicks = 0;\n        this.spawnCargoLevel = 0;\n        this.spawnFactoryChance = 0;\n\n        const map = new JunctionMap(width, height);\n        this.junctionMap = map;\n        this.trafficSimulator = new TrafficSimulator(map, (agents) => planTraffic(this, agents));\n        this.pathFinder = new PathFinder(map);\n        this.cartManager = new CartManager(map, this.trafficSimulator);\n        this.persistence = new Persistence(map);\n        this.directable = new Directable(map);\n        this.demolition = new Demolition(map, this.pathFinder, this.persistence);\n        this.solids = new Solids(map);\n\n        this.scoreKeeper = new ScoreKeeper();\n\n        this.housing = {};\n        this.factory = {};\n    }\n}\n\nexport function createWorld()\n{\n    let world = new AcreWorld(24, 16);\n    const map = world.junctionMap;\n    let x, y, result;\n    let cargo = CARGO_KEYS[world.spawnCargoLevel];\n    do {\n        [x, y] = randomJunctionCoords(map, 0, 0, 1, 1);\n        result = !tryPlaceFactory(world, x, y, cargo);\n    } while(result);\n    do {\n\n        [x, y] = randomJunctionCoords(map, 0, 0, 1, 1);\n        result = !tryPlaceHousing(world, x, y, cargo);\n    } while(result);\n    world.spawnTicks = 1000;\n    return world;\n}\n\n/**\n * @param {AcreWorld} world \n */\nexport function updateWorld(display, inputs, world)\n{\n    const cursor = world.cursor;\n    const map = world.junctionMap;\n\n    let screenX = inputs.getAxisValue('cursorX') * display.width;\n    let screenY = inputs.getAxisValue('cursorY') * display.height;\n    cursor.screenX = screenX;\n    cursor.screenY = screenY;\n\n    let action = inputs.isButtonDown('activate')\n        ? CURSOR_ACTION.ACTIVATING\n        : inputs.isButtonDown('deactivate')\n            ? CURSOR_ACTION.DEACTIVATING\n            : CURSOR_ACTION.NONE;\n    tryRoadInteraction(screenX, screenY, action, cursor, (fromX, fromY, toX, toY) => {\n        if (!isJunctionWithinBounds(map, fromX, fromY)) return;\n        if (!isJunctionWithinBounds(map, toX, toY)) return;\n        let [fromJuncX, fromJuncY] = getJunctionCoordsFromCell(world, fromX, fromY);\n        let fromJuncIndex = getJunctionIndexFromCoords(map, fromJuncX, fromJuncY);\n        let [toJuncX, toJuncY] = getJunctionCoordsFromCell(world, toX, toY);\n        let toJuncIndex = getJunctionIndexFromCoords(map, toJuncX, toJuncY);\n        if (fromJuncIndex === toJuncIndex) return;\n        if (tryPutJunction(world, map, fromJuncX, fromJuncY) && tryPutJunction(world, map, toJuncX, toJuncY))\n        {\n            tryConnectJunctions(world, map, fromJuncIndex, toJuncIndex);\n        }\n    }, (cellX, cellY) => {\n        let [juncX, juncY] = getJunctionCoordsFromCell(world, cellX, cellY);\n        if (!isJunctionWithinBounds(map, juncX, juncY)) return;\n        let juncIndex = getJunctionIndexFromCoords(map, juncX, juncY);\n        if (map.hasJunction(juncIndex))\n        {\n            world.demolition.markForDemolition(juncIndex);\n        }\n    }, CELL_SIZE, DRAG_MARGIN);\n\n    if (++world.framesToTick >= FRAMES_PER_TICK)\n    {\n        world.framesToTick = 0;\n        planTraffic(world, world.trafficSimulator.getAgents().filter(agent => agent.target === -1));\n        world.trafficSimulator.tick();\n    }\n\n    world.demolition.update();\n\n    if (--world.spawnTicks <= 0)\n    {\n        world.spawnTicks = 100 + Math.floor(1000 * Math.random());\n        doSpawnTick(world);\n    }\n}\n\n/**\n * \n * @param {AcreWorld} world \n */\nfunction doSpawnTick(world)\n{\n    let spawnableLastCargo = CARGO_KEYS[world.spawnCargoLevel];\n    let spawnableCargo;\n    if (world.scoreKeeper.getCargoCount(spawnableLastCargo) > 0 && Math.random() < 0.3)\n    {\n        // Try next level.\n        let index = Math.min(CARGO_KEYS.length - 1, world.spawnCargoLevel + 1);\n        world.spawnCargoLevel = index;\n        spawnableCargo = CARGO_KEYS[index];\n        world.spawnFactoryChance = 0.5;\n        world.spawnTicks = 100;\n    }\n    else\n    {\n        spawnableCargo = CARGO_KEYS[Math.min(world.spawnCargoLevel, Math.floor(Math.random() * CARGO_KEYS.length))];\n    }\n\n    let result;\n    if (Math.random() < world.spawnFactoryChance)\n    {\n        result = trySpawnFactory(world, spawnableCargo);\n        if (result)\n        {\n            world.spawnFactoryChance = 0;\n        }\n    }\n    else\n    {\n        result = trySpawnHousing(world, spawnableCargo);\n        if (result)\n        {\n            world.spawnFactoryChance += 0.05;\n        }\n    }\n}\n\nfunction trySpawnHousing(world, cargo)\n{\n    const map = world.junctionMap;\n    let x, y;\n    let result;\n    let attempts = 0;\n    do\n    {\n        [x, y] = randomJunctionCoords(map, 0, 0, 1, 1);\n        result = tryPlaceHousing(world, x, y, cargo);\n        ++attempts;\n    } while(!result && attempts < 10);\n    return result;\n}\n\nfunction trySpawnFactory(world, cargo)\n{\n    const map = world.junctionMap;\n    let x, y;\n    let result;\n    let attempts = 0;\n    do\n    {\n        [x, y] = randomJunctionCoords(map, 0, 0, 1, 1);\n        result = tryPlaceFactory(world, x, y, cargo);\n        ++attempts;\n    } while(!result && attempts < 10);\n    return result;\n}\n\n/**\n * @param {AcreWorld} world \n * @param {Array<TrafficAgent>} agents \n */\nfunction planTraffic(world, agents)\n{\n    const map = world.junctionMap;\n    for(let agent of agents)\n    {\n        switch('path')\n        {\n            case 'random':\n                {\n                    let target = typeof agent.savedTarget !== 'undefined'\n                        ? agent.savedTarget\n                        : randomOutletJunctionFromJunction(map, agent.junction);\n                    let nextTarget = randomOutletJunctionFromJunction(map, target);\n                    agent.savedTarget = nextTarget;\n                    let intent = PASSING_JUNCTION_INTENT;\n                    agent.setTarget(target, nextTarget, intent);\n                }\n                break;\n            case 'path':\n                {\n                    if (!agent.pathId)\n                    {\n                        let destination;\n                        if (agent.junction === agent.home)\n                        {\n                            let cart = world.cartManager.getCartByAgentId(agent.id);\n                            destination = findValidDestination(world, map, cart);\n                        }\n                        else\n                        {\n                            let pathId = agent.homePathId;\n                            let path = world.pathFinder.getPathById(pathId);\n                            agent.homePathId = null;\n                            agent.pathId = pathId;\n                            if (path === 2)\n                            {\n                                // One step path.\n                                agent.setTarget(path[1], NULL_JUNCTION_INDEX, PARKING_JUNCTION_INTENT);\n                            }\n                            else\n                            {\n                                // Path with multiple steps.\n                                agent.setTarget(path[1], path[2], PASSING_JUNCTION_INTENT);\n                            }\n                            break;\n                        }\n                        if (!isNullJunction(map, destination))\n                        {\n                            let pathId = getPathToJunction(world, world.pathFinder, agent.junction, destination);\n                            let path = world.pathFinder.getPathById(pathId);\n                            if (!path || path.length < 2)\n                            {\n                                // No path.\n                                break;\n                            }\n                            let homePathId = getPathToJunction(world, world.pathFinder, destination, agent.home);\n                            let homePath = world.pathFinder.getPathById(homePathId);\n                            if (!homePath || homePath.length < 2)\n                            {\n                                // No return path.\n                                break;\n                            }\n                            agent.pathId = pathId;\n                            agent.homePathId = homePathId;\n                            if (path === 2)\n                            {\n                                // One step path.\n                                agent.setTarget(path[1], NULL_JUNCTION_INDEX, PARKING_JUNCTION_INTENT);\n                            }\n                            else\n                            {\n                                // Path with multiple steps.\n                                agent.setTarget(path[1], path[2], PASSING_JUNCTION_INTENT);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Already on a path.\n                        let pathId = agent.pathId;\n                        let path = world.pathFinder.getPathById(pathId);\n                        let i = path.indexOf(agent.junction);\n                        if (i >= 0)\n                        {\n                            if (i < path.length - 2)\n                            {\n                                agent.setTarget(path[i + 1], path[i + 2], PASSING_JUNCTION_INTENT);\n                                world.pathFinder.prunePath(pathId, i);\n                            }\n                            else if (i < path.length - 1)\n                            {\n                                agent.setTarget(path[i + 1], NULL_JUNCTION_INDEX, PARKING_JUNCTION_INTENT);\n                                world.pathFinder.prunePath(pathId, i);\n                            }\n                            else\n                            {\n                                // Got to the end!\n                                if (agent.junction !== agent.home)\n                                {\n                                    // Got to the factory!\n                                    let cart = world.cartManager.getCartByAgentId(agent.id);\n                                    world.scoreKeeper.recordCargo(cart.cargo, 1);\n                                }\n                                agent.pathId = null;\n                                agent.clearTarget();\n                                world.pathFinder.releasePath(pathId);\n                            }\n                        }\n                        else\n                        {\n                            // Lost? Stop moving.\n                            agent.pathId = null;\n                            agent.clearTarget();\n                            world.pathFinder.releasePath(pathId);\n                        }\n                    }\n                }\n                break;\n        }\n    }\n}\n\n/**\n * @param {AcreWorld} world \n * @param {number} juncX \n * @param {number} juncY \n * @returns {boolean}\n */\nexport function tryPlaceHousing(world, juncX, juncY, cargo)\n{\n    const map = world.junctionMap;\n    const directable = world.directable;\n    const solids = world.solids;\n    if (!isJunctionWithinBounds(map, juncX - 1, juncY - 1)) return false;\n    if (!isJunctionWithinBounds(map, juncX + 1, juncY + 1)) return false;\n    // Cannot have any solids near it (except other housings)\n    for(let i = -1; i <= 1; ++i)\n    {\n        for(let j = -1; j <= 1; ++j)\n        {\n            let jx = juncX + i;\n            let jy = juncY + j;\n            let ji = getJunctionIndexFromCoords(map, jx, jy);\n            if (solids.isSolidJunction(ji) && !isHousingAtJunction(world, jx, jy))\n            {\n                return false;\n            }\n        }\n    }\n    let juncIndex = getJunctionIndexFromCoords(map, juncX, juncY);\n    let direction = tryFindValidChildDirectionForDirectable(\n        map, juncIndex, randomSingleDirectionalEncoding(),\n        (juncIndex) => !directable.isDirectableJunction(juncIndex) && !solids.isSolidJunction(juncIndex));\n    if (!canPlaceHousing(world, juncX, juncY, direction)) return false;\n    placeHousing(world, juncX, juncY, direction, cargo);\n    return true;\n}\n\nexport function placeRoad(world, fromX, fromY, toX, toY)\n{\n    const map = world.junctionMap;\n    let fromIndex = getJunctionIndexFromCoords(map, fromX, fromY);\n    let toIndex = getJunctionIndexFromCoords(map, toX, toY);\n    if (!isJunctionConnectedTo(map, fromIndex, toIndex))\n    {\n        connectJunctions(map, fromIndex, toIndex);\n    }\n    if (!isJunctionConnectedTo(map, toIndex, fromIndex))\n    {\n        connectJunctions(map, toIndex, fromIndex);\n    }\n}\n\nexport function tryPlaceFactory(world, juncX, juncY, cargo)\n{\n    const map = world.junctionMap;\n    const solids = world.solids;\n    if (!isJunctionWithinBounds(map, juncX - 1, juncY - 1)) return false;\n    if (!isJunctionWithinBounds(map, juncX + 4, juncY + 5)) return false;\n    for(let i = -1; i <= 4; ++i)\n    {\n        for(let j = -1; j <= 5; ++j)\n        {\n            let k = (juncX + i) + (juncY + j) * map.width;\n            if (solids.isSolidJunction(k))\n            {\n                return false;\n            }\n        }\n    }\n    for(let i = 1; i < 3; ++i)\n    {\n        for(let j = 0; j < 3; ++j)\n        {\n            let k = (juncX + i) + (juncY + j) * map.width;\n            if (map.hasJunction(k))\n            {\n                return false;\n            }\n        }\n    }\n    placeFactory(world, juncX, juncY, cargo);\n    return true;\n}\n\nexport function getJunctionCoordsFromCell(acreWorld, cellX, cellY)\n{\n    return [\n        cellX,\n        cellY,\n    ];\n}\n\nexport function randomJunctionCoords(map, offsetX = 0, offsetY = 0, marginX = 0, marginY = 0)\n{\n    let w = map.width - offsetX - marginX * 2;\n    let h = map.height - offsetY - marginY * 2;\n    let x = Math.floor(Math.random() * w) + offsetX + marginX;\n    let y = Math.floor(Math.random() * h) + offsetY + marginY;\n    return [x, y];\n}\n\nfunction tryPutJunction(world, map, juncX, juncY)\n{\n    let index = getJunctionIndexFromCoords(map, juncX, juncY);\n    if (world.directable.isDirectableJunction(index)) return true;\n    if (world.solids.isSolidJunction(index)) return false;\n    if (!map.hasJunction(index))\n    {\n        putJunction(map, juncX, juncY, 0);\n    }\n    return true;\n}\n\n/**\n * \n * @param {AcreWorld} world \n * @param {JunctionMap} map \n * @param {JunctionIndex} fromJuncIndex \n * @param {JunctionIndex} toJuncIndex \n * @returns \n */\nfunction tryConnectJunctions(world, map, fromJuncIndex, toJuncIndex)\n{\n    if (fromJuncIndex === toJuncIndex) return false;\n    let fromDirectable = world.directable.isDirectableJunction(fromJuncIndex);\n    let toDirectable = world.directable.isDirectableJunction(toJuncIndex);\n    if (fromDirectable)\n    {\n        return tryDirectJunction(world, map, fromJuncIndex, toJuncIndex);\n    }\n    else if (toDirectable)\n    {\n        return tryDirectJunction(world, map, toJuncIndex, fromJuncIndex);\n    }\n    \n    if (!isJunctionConnectedTo(map, fromJuncIndex, toJuncIndex))\n    {\n        connectJunctions(map, fromJuncIndex, toJuncIndex);\n    }\n    if (!isJunctionConnectedTo(map, toJuncIndex, fromJuncIndex))\n    {\n        connectJunctions(map, toJuncIndex, fromJuncIndex);\n    }\n    world.demolition.unmarkLaneForDemolition(fromJuncIndex, toJuncIndex);\n    world.demolition.unmarkLaneForDemolition(toJuncIndex, fromJuncIndex);\n    return true;\n}\n\n/**\n * \n * @param {AcreWorld} world \n * @param {*} map \n * @param {*} directableIndex \n * @param {*} directedIndex \n */\nfunction tryDirectJunction(world, map, directableIndex, directedIndex)\n{\n    let prevDirectedIndex = world.directable.getDirectableJunctionChild(directableIndex);\n    if (directedIndex === prevDirectedIndex) return true;\n    if (world.directable.isDirectableJunction(directedIndex)) return false;\n    if (!world.directable.isDirectableJunction(directableIndex)) return false;\n    if (world.solids.isSolidJunction(directedIndex)) return false;\n    if (!map.hasJunction(directedIndex))\n    {\n        let [juncX, juncY] = getJunctionCoordsFromIndex(map, directedIndex);\n        putJunction(map, juncX, juncY, 0);\n    }\n    world.demolition.markForDemolition(prevDirectedIndex);\n    world.directable.redirectDirectableJunction(directableIndex, prevDirectedIndex, directedIndex);\n    world.persistence.unmarkPersistentJunction(directableIndex, prevDirectedIndex);\n    world.persistence.markPersistentJunction(directableIndex, directedIndex);\n    return true;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {AcreWorld} world \n */\nexport function drawWorld(ctx, world)\n{\n    const map = world.junctionMap;\n    const cartManager = world.cartManager;\n    if (world.cursor.status !== CURSOR_ACTION.NONE)\n    {\n        const mapWidth = map.width;\n        const mapHeight = map.height;\n        ctx.lineWidth = 1;\n        drawGrid(ctx, mapWidth, mapHeight, CELL_SIZE);\n    }\n    drawSolids(ctx, world, map, CELL_SIZE);\n    drawOutlets(ctx, map, CELL_SIZE);\n    drawDemolition(ctx, map, world.demolition, CELL_SIZE);\n    drawCarts(ctx, cartManager, world.framesToTick, FRAMES_PER_TICK, CELL_SIZE);\n    drawHousings(ctx, world, CELL_SIZE);\n    drawFactories(ctx, world, CELL_SIZE);\n    if (world.debugMode)\n    {\n        drawJunctions(ctx, map, CELL_SIZE);\n        drawLanes(ctx, map, CELL_SIZE);\n        drawAgents(ctx, map, world.trafficSimulator, CELL_SIZE);\n    }\n    if (world.cursor.status !== CURSOR_ACTION.NONE)\n    {\n        ctx.lineWidth = 2;\n        drawCursor(ctx, world.cursor.screenX, world.cursor.screenY, CELL_SIZE, '#333333');\n    }\n    let dom = new DOMMatrix();\n    ctx.setTransform(dom);\n    drawTimer(ctx, world);\n    ctx.setTransform(dom.translate(0, 20));\n    drawScore(ctx, world.scoreKeeper);\n    ctx.setTransform(dom);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {number} screenX\n * @param {number} screenY\n * @param {number} cellSize\n */\nfunction drawCursor(ctx, screenX, screenY, cellSize, color = '#FFFFFF')\n{\n    let x = Math.floor(screenX / cellSize) * cellSize;\n    let y = Math.floor(screenY / cellSize) * cellSize;\n    ctx.strokeStyle = color;\n    ctx.strokeRect(x, y, cellSize, cellSize);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {ScoreKeeper} scoreKeeper \n */\nfunction drawScore(ctx, scoreKeeper)\n{\n    ctx.font = '16px monospace';\n    ctx.lineWidth = 1;\n    ctx.textBaseline = 'top';\n    let i = 0;\n    for(let cargo of CARGO_KEYS)\n    {\n        let count = scoreKeeper.getCargoCount(cargo);\n        if (count > 0)\n        {\n            let mainColor = getCargoMainColor(cargo);\n            ctx.fillStyle = mainColor;\n            ctx.fillText(`\u2588 ${count}`, 0, i * 20);\n            i += 1;\n        }\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {AcreWorld} world \n */\nfunction drawTimer(ctx, world)\n{\n    ctx.font = '16px monospace';\n    ctx.lineWidth = 1;\n    ctx.textBaseline = 'top';\n    ctx.fillStyle = 'white';\n    ctx.fillText(`% ${world.spawnTicks}`, 0, 0);\n}", "import * as AcreWorld from './AcreWorld.js';\n\n/**\n * @typedef {import('@milque/display').DisplayPort} DisplayPort\n * @typedef {import('@milque/input').InputContext} InputContext\n * @typedef {import('@milque/asset').AssetPack} AssetPack\n */\n\n/**\n * @param {DisplayPort} display \n * @param {InputContext} inputs \n * @param {AssetPack} assets \n */\nexport async function main(display, inputs, assets)\n{\n    inputs.bindAxis('cursorX', 'Mouse', 'PosX');\n    inputs.bindAxis('cursorY', 'Mouse', 'PosY');\n    inputs.bindButton('activate', 'Mouse', 'Button0');\n    inputs.bindButton('deactivate', 'Mouse', 'Button2');\n    const ctx = display.getContext('2d');\n\n    let world = AcreWorld.createWorld();\n    display.addEventListener('frame', e => {\n        const { now } = e.detail;\n        inputs.poll(now);\n        AcreWorld.updateWorld(display, inputs, world);\n        \n        ctx.fillStyle = 'black';\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        AcreWorld.drawWorld(ctx, world);\n    });\n}\n", "import '@milque/display';\nimport '@milque/input';\nimport '@milque/asset';\nimport './error.js';\n\nimport * as AcreWorld from './acreworld/main.js';\n\n/**\n * @typedef {import('@milque/asset').AssetPack} AssetPack\n * @typedef {import('@milque/display').DisplayPort} DisplayPort\n * @typedef {import('@milque/input').InputContext} InputContext\n */\n\nwindow.addEventListener('DOMContentLoaded', main);\nasync function main()\n{\n    /** @type {DisplayPort} */\n    const display = document.querySelector('#display');\n    /** @type {InputContext} */\n    const inputs = document.querySelector('#inputs').getContext('axisbutton');\n    /** @type {AssetPack} */\n    const assets = document.querySelector('#assets');\n    let promise = new Promise((resolve, reject) => {\n        assets.addEventListener('load', resolve);\n        assets.addEventListener('error', reject);\n    });\n    assets.src = 'res.pack';\n    await promise;\n    \n    await AcreWorld.main(display, inputs, assets);\n}\n"],
  "mappings": "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",
  "names": []
}
