{"version":3,"file":"milque-asset.cjs.js","sources":["../src/GlobExp.js","../src/AssetStore.js","../src/AssetRef.js","../src/loaders/BMFontLoader.js","../src/AssetManager.js","../src/loaders/AtlasLoader.js","../src/loaders/AudioBufferLoader.js","../src/loaders/ImageLoader.js","../src/loaders/OBJLoader.js","../src/loaders/TextLoader.js","../src/AssetHelper.js"],"sourcesContent":["import { makeRe } from 'picomatch';\n\nexport class GlobExp {\n    /**\n     * @param {string|GlobExp} pattern \n     */\n    constructor(pattern) {\n        let source;\n        if (typeof pattern === 'object' && pattern instanceof GlobExp) {\n            source = pattern.source;\n        } else {\n            source = String(pattern);\n        }\n        this.source = source;\n\n        /** @private */\n        this._re = makeRe(source);\n    }\n\n    /**\n     * @param {string} string \n     * @returns {boolean}\n     */\n    test(string) {\n        return this._re.test(string);\n    }\n}\n","import { GlobExp } from './GlobExp.js';\n\n/**\n * @typedef AssetStore\n * @property {Record<string, object>} store\n * @property {Record<string, Loading>} loadings\n * @property {Array<Fallback>} defaults\n */\n\n/**\n * @template T\n * @template {object} S\n * @callback AssetLoader\n * @param {string|ArrayBuffer} src\n * @param {S} [opts]\n * @returns {Promise<T>}\n */\n\nconst FILE_URI_PREFIX_PATTERN = /^([_\\w\\d]+)\\:\\/\\//;\n\n/**\n * Load asset using a loader with the given src.\n * - If loading to transform a cached asset, the cached uri must start with `res://` (or equivalent).\n * - If loading to transform cached raw buffers from an asset pack, use `raw://`.\n * - Otherwise, it will call `fetch()` on src.\n * \n * @template T, S\n * @param {AssetStore} assets\n * @param {string} uri \n * @param {string} src\n * @param {AssetLoader<T, S>} loader\n * @param {S} opts\n * @param {number} timeout\n * @returns {Promise<T>}\n */\n export async function loadInStore(assets, uri, src, loader, opts, timeout) {\n    const { loadings } = assets;\n    \n    let loading;\n    if (uri in loadings) {\n        loading = loadings[uri];\n    } else {\n        loading = new Loading(timeout);\n        loadings[uri] = loading;\n    }\n\n    const attempt = Loading.nextAttempt(loading);\n\n    /** @type {Array<Promise<T>>} */\n    let promises = [loading.promise];\n    if (FILE_URI_PREFIX_PATTERN.test(src)) {\n        // Loading from cached file\n        promises.push(getLoadedInStore(assets, src, timeout)\n            .then(cached => loader(cached, opts))\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    } else {\n        // Fetching from network\n        promises.push(fetch(src)\n            .then(response => response.arrayBuffer())\n            .then(arr => loader(arr))\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    }\n    return await Promise.race(promises);\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {T} value\n * @returns {T}\n */\nexport function cacheInStore(assets, uri, value) {\n    const { store, loadings } = assets;\n    store[uri] = value;\n    // Send asset to awaiting loaders...\n    if (uri in loadings) {\n        loadings[uri].resolve(value);\n        delete loadings[uri];\n    }\n    return value;\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n * @param {T} value\n * @returns {T}\n */\nexport function cacheDefaultInStore(assets, glob, value) {\n    const { defaults } = assets;\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const uri = `__default://[${defaults.length}]`;\n    cacheInStore(assets, uri, value);\n    defaults.push(new Fallback(glob, uri));\n    return value;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n */\nexport function unloadInStore(assets, uri) {\n    const { store, loadings } = assets;\n    if (uri in loadings) {\n        loadings[uri].reject(new Error('Stop loading to delete asset.'));\n        delete loadings[uri];\n    }\n    if (uri in store) {\n        delete store[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n */\nexport function clearInStore(assets, glob) {\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const { store, loadings } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        if (glob.test(uri)) {\n            loading.reject(new Error(`Stop loading to clear assets matching ${glob}`));\n            delete loadings[uri];\n        }\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        if (glob.test(uri)) {\n            delete store[uri];\n        }\n    }\n}\n\n/**\n * @param {AssetStore} assets \n */\nexport function resetStore(assets) {\n    const { store, loadings, defaults } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        delete store[uri];\n    }\n    // Clear defaults\n    defaults.length = 0;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {Promise<object>}\n */\nexport function getLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {AssetStore} assets \n * @param {string} uri \n */\nexport function cancelLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {number} timeout\n * @returns {Promise<object>}\n */\nexport async function getLoadedInStore(assets, uri, timeout) {\n    const { store, loadings } = assets;\n    if (uri in store) {\n        return store[uri];\n    } else if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        let loading = new Loading(timeout);\n        loadings[uri] = loading;\n        return loading.promise;\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {object}\n */\nexport function getDefaultInStore(assets, uri) {\n    const { defaults } = assets;\n    for (let def of defaults) {\n        if (def.glob.test(uri)) {\n            return getCurrentInStore(assets, def.uri);\n        }\n    }\n    return null;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {object}\n */\nexport function getCurrentInStore(assets, uri) {\n    return assets.store[uri];\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function hasInStore(assets, uri) {\n    return Boolean(assets.store[uri]);\n}\n\n/**\n * @param {AssetStore} assets\n * @returns {Array<string>}\n */\nexport function keysInStore(assets) {\n    return Object.keys(assets.store);\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetCachedInStore(assets, uri) {\n    return uri in assets.store;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetLoadingInStore(assets, uri) {\n    return uri in assets.loadings;\n}\n\nclass Fallback {\n    /**\n     * @param {GlobExp} glob \n     * @param {string} uri \n     */\n    constructor(glob, uri) {\n        this.glob = glob;\n        this.uri = uri;\n    }\n}\n\nclass Loading {\n\n    /**\n     * @param {Loading} loading\n     */\n    static nextAttempt(loading) {\n        return ++loading._promiseHandle;\n    }\n\n    /**\n     * @param {Loading} loading \n     * @param {number} attempt\n     */\n    static isCurrentAttempt(loading, attempt) {\n        return loading._promiseHandle === attempt;\n    }\n\n    constructor(timeout) {\n        /** @private */\n        this._promiseHandle = 0;\n        /** @private */\n        this._resolve = null;\n        /** @private */\n        this._reject = null;\n        /** @private */\n        this._reason = null;\n        /** @private */\n        this._value = null;\n        /** @private */\n        this._timeoutHandle =\n            Number.isFinite(timeout) && timeout > 0\n                ? setTimeout(() => {\n                    this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n                }, timeout)\n                : null;\n        /** @private */\n        this._promise = new Promise((resolve, reject) => {\n            if (this._value) {\n                resolve(this._value);\n            } else {\n                this._resolve = resolve;\n            }\n            if (this._reason) {\n                reject(this._reason);\n            } else {\n                this._reject = reject;\n            }\n        });\n    }\n\n    get promise() {\n        return this._promise;\n    }\n\n    resolve(value) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._resolve) {\n            this._resolve(value);\n        } else {\n            this._value = value;\n        }\n    }\n\n    reject(reason) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._reject) {\n            this._reject(reason);\n        } else {\n            this._reason = reason;\n        }\n    }\n}\n","import { AssetManager } from './AssetManager';\n\nconst DEFAULT_TIMEOUT = 5000;\n\n/** @template T, S */\nexport class AssetRef {\n\n    /**\n     * @param {string} uri \n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} [opts] \n     * @param {string} [filepath]\n     * @param {T|AssetRef<T>} [initial]\n     */\n    constructor(uri, loader, opts = undefined, filepath = uri, initial = null) {\n        this.uri = uri;\n        this.loader = loader;\n        this.opts = opts;\n\n        /** @private */\n        this.initial = initial;\n        /** @private */\n        this.filepath = filepath;\n\n        /** @type {AssetManager} */\n        this.source = null;\n        /** @type {T} */\n        this.current = null;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {T} value \n     */\n    cache(assetManager, value) {\n        assetManager.cache(this.uri, value);\n        this.source = assetManager;\n        this.current = value;\n        return this;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @returns {T}\n     */\n    get(assetManager) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            if (this.initial && this.initial instanceof AssetRef) {\n                result = this.initial.get(assetManager);\n            } else {\n                result = this.initial;\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout]\n     */\n    async load(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            result = await assetManager.load(this.uri, this.filepath, this.loader, this.opts, timeout);\n            if (!result) {\n                if (this.initial && this.initial instanceof AssetRef) {\n                    let initial = this.initial;\n                    result = await assetManager.load(initial.uri, initial.filepath, initial.loader, initial.opts, timeout);\n                } else {\n                    result = this.initial;\n                }\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout] \n     */\n    async reload(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result = await assetManager.reload(this.uri, this.filepath, this.loader, this.opts, timeout);\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n}\n","/**\n * @typedef BMFontChar\n * @property {number} id The character id.\n * @property {number} x The left position of the character image in the texture.\n * @property {number} y The top position of the character image in the texture.\n * @property {number} width The width of the character image in the texture.\n * @property {number} height The height of the character image in the texture.\n * @property {number} xoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} yoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} xadvance How much the current position should be advanced\n *                             after drawing the character.\n * @property {number} page The texture page where the character image is found.\n * @property {number} chnl The texture channel where the character image is\n *                         found (1 = blue, 2 = green, 4 = red, 8 = alpha,\n *                         15 = all channels).\n *\n * @typedef BMFontKerning\n * @property {number} first The first character id.\n * @property {number} second The second character id.\n * @property {number} amount How much the x position should be adjusted when\n *                           drawing the second character immediately following\n *                           the first.\n *\n * @typedef BMFontData\n * @property {object} info              This tag holds information on how the\n *                                      font was generated.\n * @property {string} info.face         This is the name of the true type font.\n * @property {number} info.size         The size of the true type font.\n * @property {number} info.bold         The font is bold.\n * @property {number} info.italic\t    The font is italic.\n * @property {string} info.charset\t    The name of the OEM charset used (when\n *                                      not unicode).\n * @property {number} info.unicode\t    Set to 1 if it is the unicode charset.\n * @property {number} info.stretchH\t    The font height stretch in percentage.\n *                                      100% means no stretch.\n * @property {number} info.smooth\t    Set to 1 if smoothing was turned on.\n * @property {number} info.aa\t        The supersampling level used. 1 means no\n *                                      supersampling was used.\n * @property {number} info.padding\t    The padding for each character\n *                                      (up, right, down, left).\n * @property {number} info.spacing\t    The spacing for each character\n *                                      (horizontal, vertical).\n * @property {number} info.outline\t    The outline thickness for the characters.\n * @property {object} common            This tag holds information common to all\n *                                      characters.\n * @property {number} common.lineHeight This is the distance in pixels between\n *                                      each line of text.\n * @property {number} common.base\t    The number of pixels from the absolute\n *                                      top of the line to the base of the characters.\n * @property {number} common.scaleW\t    The width of the texture, normally used\n *                                      to scale the x pos of the character image.\n * @property {number} common.scaleH\t    The height of the texture, normally used\n *                                      to scale the y pos of the character image.\n * @property {number} common.pages\t    The number of texture pages included in\n *                                      the font.\n * @property {number} common.packed\t    Set to 1 if the monochrome characters\n *                                      have been packed into each of the texture\n *                                      channels. In this case alphaChnl describes\n *                                      what is stored in each channel.\n * @property {number} common.alphaChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.redChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.greenChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.blueChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {object} page              This tag gives the name of a texture\n *                                      file. There is one for each page in the font.\n * @property {number} page.id\t        The page id.\n * @property {number} page.file\t        The texture file name.\n * @property {Array<BMFontChar>} chars  This tag describes characters in the font.\n *                                      There is one for each included character\n *                                      in the font.\n * @property {Array<BMFontKerning>} kernings The kerning information is used to adjust\n *                                           the distance between certain characters,\n *                                           e.g. some characters should be placed\n *                                           closer to each other than others.\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<BMFontData>}\n */\nexport async function BMFontLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return BMFontLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\nconst TAG_PATTERN = /(.+?)\\s+(.*)/;\nconst LINE_PATTERN = /(.+)=(.+)/;\n\n/**\n * @param {string} string\n * @returns {BMFontData}\n */\nfunction parse(string) {\n  let lines = string.split('\\n');\n  let info = {};\n  let common = {};\n  let page = {};\n  let chars = [];\n  let kernings = [];\n  for (let line of lines) {\n    let array = TAG_PATTERN.exec(line);\n    if (!array) {\n      continue;\n    }\n    let [_, tag, props] = array;\n    switch (tag) {\n      case 'info':\n        parseBMLine(info, props);\n        break;\n      case 'common':\n        parseBMLine(common, props);\n        break;\n      case 'page':\n        parseBMLine(page, props);\n        break;\n      case 'chars':\n        // This only has count info. Ignore it.\n        break;\n      case 'char':\n        let char = {};\n        parseBMLine(char, props);\n        if ('id' in char) {\n          chars.push(char);\n        }\n        break;\n      case 'kerning':\n        let kerning = {};\n        parseBMLine(kerning, props);\n        if ('first' in kerning) {\n          kernings.push(kerning);\n        }\n        break;\n      default:\n      // Unknown tag.\n    }\n  }\n  let data = /** @type {BMFontData} */ ({\n    info,\n    common,\n    page,\n    chars,\n    kernings,\n  });\n  return data;\n}\n\nfunction parseBMLine(out, line) {\n  let props = line.split(/\\s+/);\n  for (let prop of props) {\n    let array = LINE_PATTERN.exec(prop);\n    if (!array) {\n      continue;\n    }\n    let [_, key, value] = array;\n    let result = JSON.parse(`[${value}]`);\n    if (result.length === 1) {\n      out[key] = result[0];\n    } else {\n      out[key] = result;\n    }\n  }\n}\n","import { cacheDefaultInStore, cacheInStore, clearInStore, getCurrentInStore, getDefaultInStore, getLoadedInStore, getLoadingInStore, hasInStore, isAssetCachedInStore, isAssetLoadingInStore, keysInStore, loadInStore, resetStore, unloadInStore } from './AssetStore.js';\nimport { GlobExp } from './GlobExp.js';\n\nexport class AssetManager {\n\n    /**\n     * @param {AssetManager} [parent] \n     */\n    constructor(parent = null) {\n        this.parent = parent;\n        /** @private */\n        this.store = {};\n        /** @private */\n        this.loadings = {};\n        /** @private */\n        this.defaults = [];\n    }\n\n    /**\n     * @param {string} uri \n     * @returns {object}\n     */\n    get(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        }\n        let def = getDefaultInStore(assets, uri);\n        if (def) {\n            return def;\n        }\n        return null;\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout \n     * @returns {Promise<T>}\n     */\n    async resolve(uri, filepath, loader, opts, timeout) {\n        return this.get(uri) || await this.load(uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T\n     * @param {string|GlobExp} uriGlob \n     * @param {T} value \n     * @returns {T}\n     */\n    fallback(uriGlob, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheDefaultInStore(assets, uriGlob, value);\n    }\n\n    /**\n     * @template T\n     * @param {string} uri \n     * @param {T} value \n     * @returns {T}\n     */\n    cache(uri, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheInStore(assets, uri, value);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async load(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        } else if (isAssetLoadingInStore(assets, uri)) {\n            return await getLoadedInStore(assets, uri, timeout);\n        }\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async reload(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    unload(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        unloadInStore(assets, uri);\n    }\n\n    /**\n     * @param {string|GlobExp} uriGlob \n     */\n    clear(uriGlob) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        clearInStore(assets, uriGlob);\n    }\n\n    /**\n     * @param {string} uri\n     */\n    current(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return getCurrentInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    exists(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return hasInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    loading(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetLoadingInStore(assets, uri)) {\n            return getLoadingInStore(assets, uri);\n        } else {\n            return null;\n        }\n    }\n\n    keys() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return keysInStore(assets);\n    }\n\n    reset() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        resetStore(assets);\n    }\n}\n","/**\n * @typedef {Record<string, AtlasSpriteData>} Atlas\n * \n * @typedef AtlasSpriteData\n * @property {number} u\n * @property {number} v\n * @property {number} w\n * @property {number} h\n * @property {number} frames\n * @property {number} cols\n * @property {number} rows\n * @property {string} name\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @param {{ onprogress: (value: number, loaded: number, total: number) => void }} opts\n * @returns {Promise<Atlas>}\n */\nexport async function AtlasLoader(src, opts = { onprogress: undefined }) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AtlasLoader(arrayBuffer, opts);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error('Cannot load from source - must be an array buffer or fetchable url.');\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  const string = new TextDecoder().decode(arrayBuffer);\n  /** @type {Atlas} */\n  let result = {};\n  let lines = string.split('\\n');\n  let progressTotal = lines.length;\n  let progressLoaded = 0;\n  if (opts.onprogress) {\n    opts.onprogress(0, 0, progressTotal);\n  }\n  for (let line of lines) {\n    ++progressLoaded;\n    line = line.trim();\n    if (line.length <= 0) continue;\n    if (line.startsWith('#')) continue;\n    if (line.startsWith('//')) continue;\n\n    let args = [];\n    let i = 0;\n    let j = line.indexOf(' ');\n    while (j >= 0) {\n      args.push(line.substring(i, j));\n      i = j + 1;\n      j = line.indexOf(' ', i);\n    }\n    args.push(line.substring(i));\n\n    let name = args[0];\n    let u = Number.parseInt(args[1]);\n    let v = Number.parseInt(args[2]);\n    let w = Number.parseInt(args[3]);\n    let h = Number.parseInt(args[4]);\n    let frames =\n      args.length >= 6\n        ? Number.parseInt(args[5]) // User-defined\n        : 1; // Default 1 frame\n    let cols =\n      args.length >= 7\n        ? Number.parseInt(args[6]) // User-defined\n        : frames; // Default same as frame count\n    let rows =\n      args.length >= 8\n        ? Number.parseInt(args[7]) // User-defined\n        : frames > cols // If more frames than cols...\n        ? Math.ceil(frames / cols) // ...then expect more rows\n        : 1; // Otherwise, default single row\n\n    result[name] = {\n      u,\n      v,\n      w,\n      h,\n      frames,\n      cols,\n      rows,\n      name,\n    };\n\n    if (opts.onprogress) {\n      opts.onprogress(progressLoaded / progressTotal, progressLoaded, progressTotal);\n    }\n  }\n  if (opts.onprogress) {\n    opts.onprogress(1, progressLoaded, progressLoaded);\n  }\n  return result;\n}\n","/**\n * @param {ArrayBuffer|Uint8Array|string} src\n * @param {object} opts\n * @param {AudioContext} opts.audioContext\n * @returns {Promise<AudioBuffer>}\n */\nexport async function AudioBufferLoader(src, opts) {\n  const { audioContext } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AudioBufferLoader(arrayBuffer, { audioContext });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  let audioArrayBuffer = new ArrayBuffer(arrayBuffer.byteLength);\n  new Uint8Array(audioArrayBuffer).set(arrayBuffer);\n  let audioBuffer = await audioContext.decodeAudioData(audioArrayBuffer);\n  return audioBuffer;\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @param {object} [opts]\n * @param {string} [opts.imageType]\n * @returns {Promise<HTMLImageElement>}\n */\nexport async function ImageLoader(src, opts = undefined) {\n  let { imageType = undefined } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    if (typeof imageType === 'undefined') {\n      let i = src.lastIndexOf('.');\n      if (i < 0) {\n        throw new Error('Cannot load from url - unknown image type.');\n      } else {\n        imageType = 'image/' + src.slice(i + 1);\n      }\n    }\n    return ImageLoader(arrayBuffer, { ...opts, imageType });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  if (typeof imageType === 'undefined') {\n    imageType = 'image/png';\n  }\n  let blob = new Blob([arrayBuffer], { type: imageType });\n  let imageUrl = URL.createObjectURL(blob);\n  let image = new Image();\n  return new Promise((resolve, reject) => {\n    image.addEventListener('load', () => {\n      resolve(image);\n    });\n    image.addEventListener('error', (e) => {\n      reject(e);\n    });\n    image.src = imageUrl;\n  });\n}\n","/**\n * @typedef MeshData\n * @property {Float32Array} positions\n * @property {Float32Array} texcoords\n * @property {Float32Array} normals\n * @property {Uint16Array} indices\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<MeshData>}\n */\nexport async function OBJLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return OBJLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\n/**\n * @param {string} string\n * @returns {MeshData}\n */\nfunction parse(string) {\n  const vertexList = [];\n  const texcoordList = [];\n  const normalList = [];\n\n  const vertexIndices = [];\n  const texcoordIndices = [];\n  const normalIndices = [];\n\n  // # comments\n  const commentPattern = /^#.*/g;\n  // v float float float\n  const vertexPattern = /v\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vn float float float\n  const normalPattern = /vn\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vt float float float\n  const texcoordPattern = /vt\\s+(\\S+)\\s+(\\S+)/g;\n  // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n  const facePattern =\n    /f\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))(\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*)))?/g;\n  // f float float float\n  const faceVertexPattern = /f\\s+([^/\\s]+)\\s+([^/\\s]+)\\s+([^/\\s]+)/g;\n\n  let quad = false;\n  let result = null;\n  let x, y, z, w;\n\n  // Remove all comments\n  string = string.replace(commentPattern, '');\n\n  // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = vertexPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    vertexList.push(x);\n    vertexList.push(y);\n    vertexList.push(z);\n  }\n\n  // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = normalPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    normalList.push(x);\n    normalList.push(y);\n    normalList.push(z);\n  }\n\n  // [\"vt 1.0 2.0\", \"1.0\", \"2.0\"]\n  while ((result = texcoordPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    texcoordList.push(x);\n    texcoordList.push(y);\n  }\n\n  // [\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1\", \"1\", \"1\", \"1\", \"2/2/2\", \"2\", \"2\", \"2\", \"3/3/3\", \"3\", \"3\", \"3\", \"4/4/4\", \"4\", \"4\", \"4\"]\n  while ((result = facePattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    if (Number.isNaN(x)) x = 1;\n    y = Number.parseInt(result[6]);\n    if (Number.isNaN(y)) y = 1;\n    z = Number.parseInt(result[10]);\n    if (Number.isNaN(z)) z = 1;\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // Normal indices\n    x = Number.parseInt(result[4]);\n    if (Number.isNaN(x)) {\n      // No UVs.\n      x = Number.parseInt(result[3]);\n      y = Number.parseInt(result[7]);\n      z = Number.parseInt(result[11]);\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n    } else {\n      // Maybe UVs.\n      y = Number.parseInt(result[8]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[12]);\n      if (Number.isNaN(z)) z = 1;\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      // UV indices\n      x = Number.parseInt(result[3]);\n      if (Number.isNaN(x)) x = 1;\n      y = Number.parseInt(result[7]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[11]);\n      if (Number.isNaN(z)) z = 1;\n      texcoordIndices.push(x);\n      texcoordIndices.push(y);\n      texcoordIndices.push(z);\n    }\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[15]);\n      if (Number.isNaN(w)) w = 1;\n      vertexIndices.push(w);\n\n      // Normal indices\n      w = Number.parseInt(result[17]);\n      if (Number.isNaN(w)) {\n        // No UVs.\n        w = Number.parseInt(result[16]);\n        normalIndices.push(w);\n        texcoordIndices.push(1);\n      } else {\n        // Maybe UVs.\n        normalIndices.push(w);\n\n        w = Number.parseInt(result[16]);\n        texcoordIndices.push(w);\n      }\n\n      quad = true;\n    }\n  }\n\n  // [\"f 1 2 3 4\", \"1\", \"2\", \"3\", \"4\"]\n  while ((result = faceVertexPattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    y = Number.parseInt(result[6]);\n    z = Number.parseInt(result[10]);\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // UV indices\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n\n    // Normal indices\n    normalIndices.push(1);\n    normalIndices.push(1);\n    normalIndices.push(1);\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[14]);\n      vertexIndices.push(w);\n\n      // UV indices\n      texcoordIndices.push(1);\n      // Normal indices\n      normalIndices.push(1);\n\n      quad = true;\n    }\n  }\n\n  let index, size;\n\n  size = vertexIndices.length;\n  const positions = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = vertexIndices[i] - 1;\n    positions[i * 3 + 0] = vertexList[index * 3 + 0];\n    positions[i * 3 + 1] = vertexList[index * 3 + 1];\n    positions[i * 3 + 2] = vertexList[index * 3 + 2];\n  }\n\n  size = texcoordIndices.length;\n  const texcoords = new Float32Array(size * 2);\n  for (let i = 0; i < size; ++i) {\n    index = texcoordIndices[i] - 1;\n    texcoords[i * 2 + 0] = texcoordList[index * 2 + 0];\n    texcoords[i * 2 + 1] = texcoordList[index * 2 + 1];\n  }\n\n  size = normalIndices.length;\n  const normals = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = normalIndices[i] - 1;\n    normals[i * 3 + 0] = normalList[index * 3 + 0];\n    normals[i * 3 + 1] = normalList[index * 3 + 1];\n    normals[i * 3 + 2] = normalList[index * 3 + 2];\n  }\n\n  // Must be either unsigned short or unsigned byte.\n  size = vertexIndices.length;\n  const indices = new Uint16Array(size);\n  for (let i = 0; i < size; ++i) {\n    indices[i] = i;\n  }\n\n  if (quad) {\n    console.warn('WebGL does not support quad faces, only triangles.');\n  }\n\n  return {\n    positions,\n    texcoords,\n    normals,\n    indices,\n  };\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<string>}\n */\nexport async function TextLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return TextLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return new TextDecoder().decode(arrayBuffer);\n}\n","import { unzip } from 'fflate';\n\nimport { cacheInStore } from './AssetStore.js';\nimport { AssetManager } from './AssetManager.js';\nimport { AssetRef } from './AssetRef.js';\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {string} url\n * @param {(src: Uint8Array, path: string) => void} callback\n */\nexport async function loadAssetPack(url, callback) {\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    callback(buf, path);\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {AssetManager} assets\n * @param {string} url\n * @param {(src: Uint8Array, uri: string, path: string) => void} [callback]\n */\nexport async function cacheAssetPackAsRaw(assets, url, callback = undefined) {\n    const assetStore = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (assets));\n    let rootPath = 'raw://';\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    // Remove the zip directory name\n                    let i = path.indexOf('/');\n                    if (i >= 0) {\n                        path = path.substring(i + 1);\n                    }\n                    // Put the raw file in cache\n                    let uri = rootPath + path;\n                    cacheInStore(assetStore, uri, buf);\n                    if (callback) {\n                        callback(buf, uri, path);\n                    }\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * This is the same as calling `await AssetRef.load()` for each ref.\n * \n * @param {AssetManager} assets\n * @param {Array<AssetRef<?, ?>>} refs \n * @param {number} [timeout] \n */\nexport async function preloadAssetRefs(assets, refs, timeout = 5000) {\n    let promises = [];\n    for (let ref of refs) {\n        promises.push(ref.load(assets, timeout));\n    }\n    await Promise.allSettled(promises);\n}\n"],"names":["GlobExp","constructor","pattern","source","String","this","_re","makeRe","test","string","FILE_URI_PREFIX_PATTERN","async","loadInStore","assets","uri","src","loader","opts","timeout","loadings","loading","Loading","attempt","nextAttempt","promises","promise","push","getLoadedInStore","then","cached","value","isCurrentAttempt","cacheInStore","undefined","fetch","response","arrayBuffer","arr","Promise","race","store","resolve","getCurrentInStore","isAssetCachedInStore","isAssetLoadingInStore","Fallback","glob","static","_promiseHandle","_resolve","_reject","_reason","_value","_timeoutHandle","Number","isFinite","setTimeout","reject","_promise","clearTimeout","reason","AssetRef","filepath","initial","current","cache","assetManager","get","result","exists","load","reload","TAG_PATTERN","LINE_PATTERN","parseBMLine","out","line","props","split","prop","array","exec","_","key","JSON","parse","length","parent","defaults","def","getDefaultInStore","fallback","uriGlob","cacheDefaultInStore","unload","Error","unloadInStore","clear","Object","entries","keys","clearInStore","Boolean","hasInStore","getLoadingInStore","keysInStore","reset","resetStore","AtlasLoader","onprogress","ArrayBuffer","isView","lines","TextDecoder","decode","progressTotal","progressLoaded","trim","startsWith","args","i","j","indexOf","substring","name","u","parseInt","v","w","h","frames","cols","rows","Math","ceil","AudioBufferLoader","audioContext","audioArrayBuffer","byteLength","Uint8Array","set","decodeAudioData","BMFontLoader","info","common","page","chars","kernings","tag","char","kerning","ImageLoader","imageType","lastIndexOf","slice","blob","Blob","type","imageUrl","URL","createObjectURL","image","Image","addEventListener","e","OBJLoader","vertexList","texcoordList","normalList","vertexIndices","texcoordIndices","normalIndices","commentPattern","vertexPattern","normalPattern","texcoordPattern","facePattern","faceVertexPattern","x","y","z","index","size","quad","replace","parseFloat","isNaN","positions","Float32Array","texcoords","normals","indices","Uint16Array","console","warn","TextLoader","url","callback","assetStore","unzip","err","data","path","buf","replaceAll","refs","ref","allSettled"],"mappings":"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"}