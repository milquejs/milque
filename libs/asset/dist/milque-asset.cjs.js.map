{"version":3,"file":"milque-asset.cjs.js","sources":["../src/GlobExp.js","../src/AssetStore.js","../src/AssetManager.js","../src/AssetRef.js"],"sourcesContent":["import { makeRe } from 'picomatch';\n\nexport class GlobExp {\n    /**\n     * @param {string|GlobExp} pattern \n     */\n    constructor(pattern) {\n        let source;\n        if (typeof pattern === 'object' && pattern instanceof GlobExp) {\n            source = pattern.source;\n        } else {\n            source = String(pattern);\n        }\n        this.source = source;\n\n        /** @private */\n        this._re = makeRe(source);\n    }\n\n    /**\n     * @param {string} string \n     * @returns {boolean}\n     */\n    test(string) {\n        return this._re.test(string);\n    }\n}\n","import { GlobExp } from './GlobExp.js';\n\n/**\n * @typedef AssetStore\n * @property {Record<string, object>} cache\n * @property {Record<string, Loading>} loadings\n * @property {Array<Fallback>} defaults\n */\n\nconst FILE_URI_PREFIX_PATTERN = /^([_\\w\\d]+)\\:\\/\\//;\nconst DEFAULT_TIMEOUT = 5_000;\n\n/**\n * Load asset using a loader with the given src.\n * - If loading to transform a cached asset, the cached uri must start with `res://` (or equivalent).\n * - If loading to transform cached raw buffers from an asset pack, use `raw://`.\n * - Otherwise, it will call `fetch()` on src.\n * \n * @template T\n * @param {AssetStore} store\n * @param {string} uri \n * @param {string} src\n * @param {(src: string|ArrayBuffer) => Promise<T>} loader\n * @param {number} [timeout]\n * @returns {Promise<T>}\n */\n export async function loadInStore(store, uri, src, loader, timeout = DEFAULT_TIMEOUT) {\n    const { cache: globalCache, loadings } = store;\n    if (uri in globalCache) {\n        return globalCache[uri];\n    }\n\n    let loading;\n    if (uri in loadings) {\n        loading = loadings[uri];\n        if (loading.active) {\n            return loadings[uri].promise;\n        }\n    } else {\n        loading = new Loading(timeout);\n        loadings[uri] = loading;\n    }\n\n    /** @type {Array<Promise<T>>} */\n    let promises = [loading.promise];\n    if (FILE_URI_PREFIX_PATTERN.test(src)) {\n        // Loading from cached file\n        promises.push(getLoadedInStore(store, src, timeout)\n            .then(cached => loader(cached))\n            .then(value => cacheInStore(store, uri, value)));\n    } else {\n        // Fetching from network\n        promises.push(fetch(src)\n            .then(response => response.arrayBuffer())\n            .then(arr => loader(arr))\n            .then(value => cacheInStore(store, uri, value)));\n    }\n    return await Promise.race(promises);\n}\n\n/**\n * @template T\n * @param {AssetStore} store\n * @param {string} uri\n * @param {T} asset\n * @returns {T}\n */\nexport function cacheInStore(store, uri, asset) {\n    const { cache, loadings } = store;\n    cache[uri] = asset;\n    // Send asset to awaiting loaders...\n    if (uri in loadings) {\n        loadings[uri].resolve(asset);\n        delete loadings[uri];\n    }\n    return asset;\n}\n\n/**\n * @template T\n * @param {AssetStore} store\n * @param {string|GlobExp} glob\n * @param {T} asset\n * @returns {T}\n */\nexport function cacheDefaultInStore(store, glob, asset) {\n    const { defaults } = store;\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const uri = `__default://[${defaults.length}]`;\n    cacheInStore(store, uri, asset);\n    defaults.push(new Fallback(glob, uri));\n    return asset;\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri\n */\nexport function unloadInStore(store, uri) {\n    const { cache, loadings } = store;\n    if (uri in loadings) {\n        loadings[uri].reject(new Error('Stop loading to delete asset.'));\n        delete loadings[uri];\n    }\n    if (uri in cache) {\n        delete cache[uri];\n    }\n}\n\n/**\n * @param {AssetStore} store\n * @param {string|GlobExp} [glob]\n * @param {object} [opts] \n * @param {boolean} [opts.preserveDefault]\n */\nexport function clearInStore(store, glob = undefined, opts = { preserveDefault: false }) {\n    const { preserveDefault } = opts;\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const { cache, loadings, defaults } = store;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        if (!glob || glob.test(uri)) {\n            loading.reject(new Error('Stop loading to clear all assets.'));\n            delete loadings[uri];\n        }\n    }\n    // Clear cache\n    for (let uri of Object.keys(cache)) {\n        if (!glob || glob.test(uri)) {\n            delete cache[uri];\n        }\n    }\n    // Clear defaults\n    if (!preserveDefault) {\n        defaults.length = 0;\n    }\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri\n * @param {number} [timeout]\n * @returns {Promise<object>}\n */\nexport async function getLoadedInStore(store, uri, timeout = DEFAULT_TIMEOUT) {\n    const { cache, loadings } = store;\n    if (uri in cache) {\n        return cache[uri];\n    } else if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        let loading = new Loading(timeout);\n        loadings[uri] = loading;\n        return loading.promise;\n    }\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri \n * @returns {object}\n */\nexport function getDefaultInStore(store, uri) {\n    const { defaults } = store;\n    for (let def of defaults) {\n        if (def.glob.test(uri)) {\n            return getCurrentInStore(store, def.uri);\n        }\n    }\n    return null;\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri\n * @returns {object}\n */\nexport function getCurrentInStore(store, uri) {\n    return store.cache[uri];\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri \n * @returns {boolean}\n */\nexport function hasInStore(store, uri) {\n    return Boolean(store.cache[uri]);\n}\n\n/**\n * @param {AssetStore} store\n * @returns {Array<string>}\n */\nexport function keysInStore(store) {\n    return Object.keys(store.cache);\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetCachedInStore(store, uri) {\n    return uri in store.cache;\n}\n\n/**\n * @param {AssetStore} store\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetLoadingInStore(store, uri) {\n    return uri in store.loadings;\n}\n\nclass Fallback {\n    /**\n     * @param {GlobExp} glob \n     * @param {string} uri \n     */\n    constructor(glob, uri) {\n        this.glob = glob;\n        this.uri = uri;\n    }\n}\n\nclass Loading {\n    constructor(timeout) {\n        this.active = false;\n\n        /** @private */\n        this._resolve = null;\n        /** @private */\n        this._reject = null;\n        /** @private */\n        this._reason = null;\n        /** @private */\n        this._value = null;\n        /** @private */\n        this._timeoutHandle =\n            Number.isFinite(timeout) && timeout > 0\n                ? setTimeout(() => {\n                    this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n                }, timeout)\n                : null;\n        /** @private */\n        this._promise = new Promise((resolve, reject) => {\n            if (this._value) {\n                resolve(this._value);\n            } else {\n                this._resolve = resolve;\n            }\n            if (this._reason) {\n                reject(this._reason);\n            } else {\n                this._reject = reject;\n            }\n        });\n    }\n\n    get promise() {\n        return this._promise;\n    }\n\n    resolve(value) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._resolve) {\n            this._resolve(value);\n        } else {\n            this._value = value;\n        }\n    }\n\n    reject(reason) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._reject) {\n            this._reject(reason);\n        } else {\n            this._reason = reason;\n        }\n    }\n}\n","import { unzip } from 'fflate';\nimport { AssetRef } from './AssetRef.js';\nimport { cacheInStore, keysInStore, getCurrentInStore } from './AssetStore.js';\n\nconst DEFAULT_TIMEOUT = 5_000;\n/** @type {import('./AssetStore.js').AssetStore} */\nconst GLOBAL = {\n    cache: {},\n    loadings: {},\n    defaults: [],\n};\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {string} url\n * @param {(src: Uint8Array, uri: string, path: string) => void} [callback]\n */\nexport async function loadAssetPackAsRaw(url, callback = undefined) {\n    let rootPath = 'raw://';\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    // Remove the zip directory name\n                    let i = path.indexOf('/');\n                    if (i >= 0) {\n                        path = path.substring(i + 1);\n                    }\n                    // Put the raw file in cache\n                    let uri = rootPath + path;\n                    cacheInStore(GLOBAL, uri, buf);\n                    if (callback) {\n                        callback(buf, uri, path);\n                    }\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {string} url\n * @param {(src: Uint8Array, path: string) => void} callback\n */\n export async function loadAssetPack(url, callback) {\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    callback(buf, path);\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * This is the same as calling `await AssetRef.load()` for each ref.\n * \n * @param {Array<AssetRef>} refs \n * @param {number} [timeout] \n */\nexport async function loadAssetRefs(refs, timeout = DEFAULT_TIMEOUT) {\n    let promises = [];\n    for (let ref of refs) {\n        promises.push(ref.preload(GLOBAL, timeout));\n    }\n    await Promise.allSettled(promises);\n}\n\n/**\n * @template T\n * @param {string} uri\n * @param {T} asset\n * @returns {T}\n */\nexport function cache(uri, asset) {\n    return cacheInStore(GLOBAL, uri, asset);\n}\n\n/**\n * @returns {Array<string>}\n */\nexport function keys() {\n    return keysInStore(GLOBAL);\n}\n\n/**\n * @param {string} uri\n * @returns {object}\n */\nexport function current(uri) {\n    return getCurrentInStore(GLOBAL, uri);\n}\n\n/**\n * @param {string} uri\n * @returns {object}\n */\nexport function get(uri) {\n    return current(uri);\n}\n","import { cacheInStore, getCurrentInStore, getDefaultInStore, getLoadedInStore, loadInStore, unloadInStore } from './AssetStore.js';\n\n/** @typedef {import('./AssetStore.js').AssetStore} AssetStore */\n\n/**\n * @template T\n */\nexport class AssetRef {\n    /**\n     * @param {string} uri \n     * @param {string} src \n     * @param {(src: Uint8Array) => Promise<T>} loader \n     */\n    constructor(uri, src, loader) {\n        this.uri = uri;\n        /** @protected */\n        this.source = src;\n        /** @protected */\n        this.loader = loader;\n        /** @protected */\n        this.store = null;\n    }\n\n    /** @returns {T} */\n    get current() {\n        return getCurrentInStore(this.store, this.uri);\n    }\n\n    /** @param {T} value */\n    set current(value) {\n        cacheInStore(this.store, this.uri, value);\n    }\n\n    /** @returns {T} */\n    get default() {\n        return getDefaultInStore(this.store, this.uri);\n    }\n\n    /** @returns {Promise<T>} */\n    get loaded() {\n        return getLoadedInStore(this.store, this.uri);\n    }\n\n    /**\n     * @param {AssetStore} store\n     * @param {number} [timeout] The time to wait until error for loader.\n     * @param {T} [cached] If defined, will cache this value instead of fetch and loading from source.\n     * @returns {Promise<AssetRef<T>>}\n     */\n    async preload(store, timeout = undefined, cached = undefined) {\n        this.store = store;\n        if (typeof cached !== 'undefined') {\n            cacheInStore(store, this.uri, cached);\n        } else {\n            await loadInStore(this.store, this.uri, this.source, this.loader, timeout);\n        }\n        return this;\n    }\n\n    /**\n     * @returns {Promise<AssetRef<T>>}\n     */\n    async unload() {\n        unloadInStore(this.store, this.uri);\n        this.store = null;\n        return this;\n    }\n}\n"],"names":["GlobExp","constructor","pattern","source","String","this","_re","makeRe","test","string","FILE_URI_PREFIX_PATTERN","DEFAULT_TIMEOUT","cacheInStore","store","uri","asset","cache","loadings","resolve","async","getLoadedInStore","timeout","promise","loading","Loading","getCurrentInStore","active","_resolve","_reject","_reason","_value","_timeoutHandle","Number","isFinite","setTimeout","reject","_promise","Promise","value","clearTimeout","reason","GLOBAL","defaults","current","Object","keys","url","callback","response","fetch","arrayBuffer","unzip","Uint8Array","err","data","path","buf","entries","replaceAll","i","indexOf","substring","refs","promises","ref","push","preload","allSettled","src","loader","default","def","glob","getDefaultInStore","loaded","cached","globalCache","then","arr","race","loadInStore","Error","unloadInStore"],"mappings":"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"}