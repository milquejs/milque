{"version":3,"file":"milque-asset.umd.js","sources":["../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js","../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js","../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js","../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js","../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js","../../../common/temp/node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js","../src/GlobExp.js","../../../common/temp/node_modules/.pnpm/fflate@0.7.4/node_modules/fflate/esm/browser.js","../src/AssetStore.js","../src/AssetRef.js","../src/loaders/BMFontLoader.js","../src/AssetManager.js","../src/loaders/AtlasLoader.js","../src/loaders/AudioBufferLoader.js","../src/loaders/ImageLoader.js","../src/loaders/OBJLoader.js","../src/loaders/TextLoader.js","../src/AssetHelper.js"],"sourcesContent":["'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","import { makeRe } from 'picomatch';\n\nexport class GlobExp {\n    /**\n     * @param {string|GlobExp} pattern \n     */\n    constructor(pattern) {\n        let source;\n        if (typeof pattern === 'object' && pattern instanceof GlobExp) {\n            source = pattern.source;\n        } else {\n            source = String(pattern);\n        }\n        this.source = source;\n\n        /** @private */\n        this._re = makeRe(source);\n    }\n\n    /**\n     * @param {string} string \n     * @returns {boolean}\n     */\n    test(string) {\n        return this._re.test(string);\n    }\n}\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && st.f && !st.l))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos >> 3] = lst;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if (d[1] & 32)\n        err(6, 'invalid zlib data: preset dictionaries not supported');\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                err(6, 'invalid gzip data');\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            err(8);\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this_1.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this_1.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this_1.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this_1.ondata(err, dat, final);\n                    _this_1.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_3 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    if (sc < 320000) {\n                        try {\n                            cbl(null, inflateSync(infl, new u8(su)));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import { GlobExp } from './GlobExp.js';\n\n/**\n * @typedef AssetStore\n * @property {Record<string, object>} store\n * @property {Record<string, Loading>} loadings\n * @property {Array<Fallback>} defaults\n */\n\n/**\n * @template T\n * @template {object} S\n * @callback AssetLoader\n * @param {string|ArrayBuffer} src\n * @param {S} [opts]\n * @returns {Promise<T>}\n */\n\nconst FILE_URI_PREFIX_PATTERN = /^([_\\w\\d]+)\\:\\/\\//;\n\n/**\n * Load asset using a loader with the given src.\n * - If loading to transform a cached asset, the cached uri must start with `res://` (or equivalent).\n * - If loading to transform cached raw buffers from an asset pack, use `raw://`.\n * - Otherwise, it will call `fetch()` on src.\n * \n * @template T, S\n * @param {AssetStore} assets\n * @param {string} uri \n * @param {string} src\n * @param {AssetLoader<T, S>} loader\n * @param {S} opts\n * @param {number} timeout\n * @returns {Promise<T>}\n */\n export async function loadInStore(assets, uri, src, loader, opts, timeout) {\n    const { loadings } = assets;\n    \n    let loading;\n    if (uri in loadings) {\n        loading = loadings[uri];\n    } else {\n        loading = new Loading(timeout);\n        loadings[uri] = loading;\n    }\n\n    const attempt = Loading.nextAttempt(loading);\n\n    /** @type {Array<Promise<T>>} */\n    let promises = [loading.promise];\n    if (FILE_URI_PREFIX_PATTERN.test(src)) {\n        // Loading from cached file\n        promises.push(getLoadedInStore(assets, src, timeout)\n            .then(cached => loader(cached, opts))\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    } else {\n        // Just load it\n        promises.push(loader(src)\n            .then(value => Loading.isCurrentAttempt(loading, attempt)\n                ? cacheInStore(assets, uri, value)\n                : undefined));\n    }\n    return await Promise.race(promises);\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {T} value\n * @returns {T}\n */\nexport function cacheInStore(assets, uri, value) {\n    const { store, loadings } = assets;\n    store[uri] = value;\n    // Send asset to awaiting loaders...\n    if (uri in loadings) {\n        loadings[uri].resolve(value);\n        delete loadings[uri];\n    }\n    return value;\n}\n\n/**\n * @template T\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n * @param {T} value\n * @returns {T}\n */\nexport function cacheDefaultInStore(assets, glob, value) {\n    const { defaults } = assets;\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const uri = `__default://[${defaults.length}]`;\n    cacheInStore(assets, uri, value);\n    defaults.push(new Fallback(glob, uri));\n    return value;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n */\nexport function unloadInStore(assets, uri) {\n    const { store, loadings } = assets;\n    if (uri in loadings) {\n        loadings[uri].reject(new Error('Stop loading to delete asset.'));\n        delete loadings[uri];\n    }\n    if (uri in store) {\n        delete store[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string|GlobExp} glob\n */\nexport function clearInStore(assets, glob) {\n    if (typeof glob === 'string') {\n        glob = new GlobExp(glob);\n    }\n    const { store, loadings } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        if (glob.test(uri)) {\n            loading.reject(new Error(`Stop loading to clear assets matching ${glob}`));\n            delete loadings[uri];\n        }\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        if (glob.test(uri)) {\n            delete store[uri];\n        }\n    }\n}\n\n/**\n * @param {AssetStore} assets \n */\nexport function resetStore(assets) {\n    const { store, loadings, defaults } = assets;\n    // Clear loadings\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n    // Clear cache\n    for (let uri of Object.keys(store)) {\n        delete store[uri];\n    }\n    // Clear defaults\n    defaults.length = 0;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {Promise<object>}\n */\nexport function getLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {AssetStore} assets \n * @param {string} uri \n */\nexport function cancelLoadingInStore(assets, uri) {\n    const { loadings } = assets;\n    for (let [uri, loading] of Object.entries(loadings)) {\n        loading.reject(new Error(`Stop loading to clear all assets.`));\n        delete loadings[uri];\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @param {number} timeout\n * @returns {Promise<object>}\n */\nexport async function getLoadedInStore(assets, uri, timeout) {\n    const { store, loadings } = assets;\n    if (uri in store) {\n        return store[uri];\n    } else if (uri in loadings) {\n        return loadings[uri].promise;\n    } else {\n        let loading = new Loading(timeout);\n        loadings[uri] = loading;\n        return loading.promise;\n    }\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {object}\n */\nexport function getDefaultInStore(assets, uri) {\n    const { defaults } = assets;\n    for (let def of defaults) {\n        if (def.glob.test(uri)) {\n            return getCurrentInStore(assets, def.uri);\n        }\n    }\n    return null;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri\n * @returns {object}\n */\nexport function getCurrentInStore(assets, uri) {\n    return assets.store[uri];\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function hasInStore(assets, uri) {\n    return Boolean(assets.store[uri]);\n}\n\n/**\n * @param {AssetStore} assets\n * @returns {Array<string>}\n */\nexport function keysInStore(assets) {\n    return Object.keys(assets.store);\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetCachedInStore(assets, uri) {\n    return uri in assets.store;\n}\n\n/**\n * @param {AssetStore} assets\n * @param {string} uri \n * @returns {boolean}\n */\nexport function isAssetLoadingInStore(assets, uri) {\n    return uri in assets.loadings;\n}\n\nclass Fallback {\n    /**\n     * @param {GlobExp} glob \n     * @param {string} uri \n     */\n    constructor(glob, uri) {\n        this.glob = glob;\n        this.uri = uri;\n    }\n}\n\nclass Loading {\n\n    /**\n     * @param {Loading} loading\n     */\n    static nextAttempt(loading) {\n        return ++loading._promiseHandle;\n    }\n\n    /**\n     * @param {Loading} loading \n     * @param {number} attempt\n     */\n    static isCurrentAttempt(loading, attempt) {\n        return loading._promiseHandle === attempt;\n    }\n\n    constructor(timeout) {\n        /** @private */\n        this._promiseHandle = 0;\n        /** @private */\n        this._resolve = null;\n        /** @private */\n        this._reject = null;\n        /** @private */\n        this._reason = null;\n        /** @private */\n        this._value = null;\n        /** @private */\n        this._timeoutHandle =\n            Number.isFinite(timeout) && timeout > 0\n                ? setTimeout(() => {\n                    this.reject(`Asset loading exceeded timeout of ${timeout} ms.`);\n                }, timeout)\n                : null;\n        /** @private */\n        this._promise = new Promise((resolve, reject) => {\n            if (this._value) {\n                resolve(this._value);\n            } else {\n                this._resolve = resolve;\n            }\n            if (this._reason) {\n                reject(this._reason);\n            } else {\n                this._reject = reject;\n            }\n        });\n    }\n\n    get promise() {\n        return this._promise;\n    }\n\n    resolve(value) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._resolve) {\n            this._resolve(value);\n        } else {\n            this._value = value;\n        }\n    }\n\n    reject(reason) {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n            this._timeoutHandle = null;\n        }\n        if (this._reject) {\n            this._reject(reason);\n        } else {\n            this._reason = reason;\n        }\n    }\n}\n","import { AssetManager } from './AssetManager';\n\nconst DEFAULT_TIMEOUT = 5000;\n\n/** @template T, S */\nexport class AssetRef {\n\n    /**\n     * @param {string} uri \n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} [opts] \n     * @param {string} [filepath]\n     * @param {T|AssetRef<T>} [initial]\n     */\n    constructor(uri, loader, opts = undefined, filepath = uri, initial = null) {\n        this.uri = uri;\n        this.loader = loader;\n        this.opts = opts;\n\n        /** @private */\n        this.initial = initial;\n        /** @private */\n        this.filepath = filepath;\n\n        /** @type {AssetManager} */\n        this.source = null;\n        /** @type {T} */\n        this.current = null;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {T} value \n     */\n    cache(assetManager, value) {\n        assetManager.cache(this.uri, value);\n        this.source = assetManager;\n        this.current = value;\n        return this;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @returns {T}\n     */\n    get(assetManager) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            if (this.initial && this.initial instanceof AssetRef) {\n                result = this.initial.get(assetManager);\n            } else {\n                result = this.initial;\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout]\n     */\n    async load(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result;\n        if (!assetManager.exists(this.uri)) {\n            result = await assetManager.load(this.uri, this.filepath, this.loader, this.opts, timeout);\n            if (!result) {\n                if (this.initial && this.initial instanceof AssetRef) {\n                    let initial = this.initial;\n                    result = await assetManager.load(initial.uri, initial.filepath, initial.loader, initial.opts, timeout);\n                } else {\n                    result = this.initial;\n                }\n            }\n        } else {\n            result = assetManager.current(this.uri);\n        }\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n\n    /**\n     * @param {AssetManager} assetManager \n     * @param {number} [timeout] \n     */\n    async reload(assetManager, timeout = DEFAULT_TIMEOUT) {\n        let result = await assetManager.reload(this.uri, this.filepath, this.loader, this.opts, timeout);\n        this.source = assetManager;\n        this.current = result;\n        return result;\n    }\n}\n","/**\n * @typedef BMFontChar\n * @property {number} id The character id.\n * @property {number} x The left position of the character image in the texture.\n * @property {number} y The top position of the character image in the texture.\n * @property {number} width The width of the character image in the texture.\n * @property {number} height The height of the character image in the texture.\n * @property {number} xoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} yoffset How much the current position should be offset when\n *                            copying the image from the texture to the screen.\n * @property {number} xadvance How much the current position should be advanced\n *                             after drawing the character.\n * @property {number} page The texture page where the character image is found.\n * @property {number} chnl The texture channel where the character image is\n *                         found (1 = blue, 2 = green, 4 = red, 8 = alpha,\n *                         15 = all channels).\n *\n * @typedef BMFontKerning\n * @property {number} first The first character id.\n * @property {number} second The second character id.\n * @property {number} amount How much the x position should be adjusted when\n *                           drawing the second character immediately following\n *                           the first.\n *\n * @typedef BMFontData\n * @property {object} info              This tag holds information on how the\n *                                      font was generated.\n * @property {string} info.face         This is the name of the true type font.\n * @property {number} info.size         The size of the true type font.\n * @property {number} info.bold         The font is bold.\n * @property {number} info.italic\t    The font is italic.\n * @property {string} info.charset\t    The name of the OEM charset used (when\n *                                      not unicode).\n * @property {number} info.unicode\t    Set to 1 if it is the unicode charset.\n * @property {number} info.stretchH\t    The font height stretch in percentage.\n *                                      100% means no stretch.\n * @property {number} info.smooth\t    Set to 1 if smoothing was turned on.\n * @property {number} info.aa\t        The supersampling level used. 1 means no\n *                                      supersampling was used.\n * @property {number} info.padding\t    The padding for each character\n *                                      (up, right, down, left).\n * @property {number} info.spacing\t    The spacing for each character\n *                                      (horizontal, vertical).\n * @property {number} info.outline\t    The outline thickness for the characters.\n * @property {object} common            This tag holds information common to all\n *                                      characters.\n * @property {number} common.lineHeight This is the distance in pixels between\n *                                      each line of text.\n * @property {number} common.base\t    The number of pixels from the absolute\n *                                      top of the line to the base of the characters.\n * @property {number} common.scaleW\t    The width of the texture, normally used\n *                                      to scale the x pos of the character image.\n * @property {number} common.scaleH\t    The height of the texture, normally used\n *                                      to scale the y pos of the character image.\n * @property {number} common.pages\t    The number of texture pages included in\n *                                      the font.\n * @property {number} common.packed\t    Set to 1 if the monochrome characters\n *                                      have been packed into each of the texture\n *                                      channels. In this case alphaChnl describes\n *                                      what is stored in each channel.\n * @property {number} common.alphaChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.redChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.greenChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {number} common.blueChnl\tSet to 0 if the channel holds the glyph data,\n *                                      1 if it holds the outline,\n *                                      2 if it holds the glyph and the outline,\n *                                      3 if its set to zero, and 4 if its set to one.\n * @property {object} page              This tag gives the name of a texture\n *                                      file. There is one for each page in the font.\n * @property {number} page.id\t        The page id.\n * @property {number} page.file\t        The texture file name.\n * @property {Array<BMFontChar>} chars  This tag describes characters in the font.\n *                                      There is one for each included character\n *                                      in the font.\n * @property {Array<BMFontKerning>} kernings The kerning information is used to adjust\n *                                           the distance between certain characters,\n *                                           e.g. some characters should be placed\n *                                           closer to each other than others.\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<BMFontData>}\n */\nexport async function BMFontLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return BMFontLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\nconst TAG_PATTERN = /(.+?)\\s+(.*)/;\nconst LINE_PATTERN = /(.+)=(.+)/;\n\n/**\n * @param {string} string\n * @returns {BMFontData}\n */\nfunction parse(string) {\n  let lines = string.split('\\n');\n  let info = {};\n  let common = {};\n  let page = {};\n  let chars = [];\n  let kernings = [];\n  for (let line of lines) {\n    let array = TAG_PATTERN.exec(line);\n    if (!array) {\n      continue;\n    }\n    let [_, tag, props] = array;\n    switch (tag) {\n      case 'info':\n        parseBMLine(info, props);\n        break;\n      case 'common':\n        parseBMLine(common, props);\n        break;\n      case 'page':\n        parseBMLine(page, props);\n        break;\n      case 'chars':\n        // This only has count info. Ignore it.\n        break;\n      case 'char':\n        let char = {};\n        parseBMLine(char, props);\n        if ('id' in char) {\n          chars.push(char);\n        }\n        break;\n      case 'kerning':\n        let kerning = {};\n        parseBMLine(kerning, props);\n        if ('first' in kerning) {\n          kernings.push(kerning);\n        }\n        break;\n      default:\n      // Unknown tag.\n    }\n  }\n  let data = /** @type {BMFontData} */ ({\n    info,\n    common,\n    page,\n    chars,\n    kernings,\n  });\n  return data;\n}\n\nfunction parseBMLine(out, line) {\n  let props = line.split(/\\s+/);\n  for (let prop of props) {\n    let array = LINE_PATTERN.exec(prop);\n    if (!array) {\n      continue;\n    }\n    let [_, key, value] = array;\n    let result = JSON.parse(`[${value}]`);\n    if (result.length === 1) {\n      out[key] = result[0];\n    } else {\n      out[key] = result;\n    }\n  }\n}\n","import { cacheDefaultInStore, cacheInStore, clearInStore, getCurrentInStore, getDefaultInStore, getLoadedInStore, getLoadingInStore, hasInStore, isAssetCachedInStore, isAssetLoadingInStore, keysInStore, loadInStore, resetStore, unloadInStore } from './AssetStore.js';\nimport { GlobExp } from './GlobExp.js';\n\nexport class AssetManager {\n\n    /**\n     * @param {AssetManager} [parent] \n     */\n    constructor(parent = null) {\n        this.parent = parent;\n        /** @private */\n        this.store = {};\n        /** @private */\n        this.loadings = {};\n        /** @private */\n        this.defaults = [];\n    }\n\n    /**\n     * @param {string} uri \n     * @returns {any}\n     */\n    get(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        }\n        let def = getDefaultInStore(assets, uri);\n        if (def) {\n            return def;\n        }\n        return null;\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout \n     * @returns {Promise<T>}\n     */\n    async resolve(uri, filepath, loader, opts, timeout) {\n        return this.get(uri) || await this.load(uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T\n     * @param {string|GlobExp} uriGlob \n     * @param {T} value \n     * @returns {T}\n     */\n    fallback(uriGlob, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheDefaultInStore(assets, uriGlob, value);\n    }\n\n    /**\n     * @template T\n     * @param {string} uri \n     * @param {T} value \n     * @returns {T}\n     */\n    cache(uri, value) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return cacheInStore(assets, uri, value);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async load(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetCachedInStore(assets, uri)) {\n            return getCurrentInStore(assets, uri);\n        } else if (isAssetLoadingInStore(assets, uri)) {\n            return await getLoadedInStore(assets, uri, timeout);\n        }\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @template T, S\n     * @param {string} uri \n     * @param {string} filepath\n     * @param {import('./AssetStore').AssetLoader<T, S>} loader \n     * @param {S} opts \n     * @param {number} timeout\n     * @returns {Promise<T>}\n     */\n    async reload(uri, filepath, loader, opts, timeout) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return await loadInStore(assets, uri, filepath, loader, opts, timeout);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    unload(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        unloadInStore(assets, uri);\n    }\n\n    /**\n     * @param {string|GlobExp} uriGlob \n     */\n    clear(uriGlob) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        clearInStore(assets, uriGlob);\n    }\n\n    /**\n     * @param {string} uri\n     */\n    current(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return getCurrentInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    exists(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return hasInStore(assets, uri);\n    }\n\n    /**\n     * @param {string} uri \n     */\n    loading(uri) {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        if (isAssetLoadingInStore(assets, uri)) {\n            return getLoadingInStore(assets, uri);\n        } else {\n            return null;\n        }\n    }\n\n    keys() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        return keysInStore(assets);\n    }\n\n    reset() {\n        const assets = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (this));\n        resetStore(assets);\n    }\n}\n","/**\n * @typedef {Record<string, AtlasSpriteData>} Atlas\n * \n * @typedef AtlasSpriteData\n * @property {number} u\n * @property {number} v\n * @property {number} w\n * @property {number} h\n * @property {number} frames\n * @property {number} cols\n * @property {number} rows\n * @property {string} name\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @param {{ onprogress: (value: number, loaded: number, total: number) => void }} opts\n * @returns {Promise<Atlas>}\n */\nexport async function AtlasLoader(src, opts = { onprogress: undefined }) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AtlasLoader(arrayBuffer, opts);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error('Cannot load from source - must be an array buffer or fetchable url.');\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  const string = new TextDecoder().decode(arrayBuffer);\n  /** @type {Atlas} */\n  let result = {};\n  let lines = string.split('\\n');\n  let progressTotal = lines.length;\n  let progressLoaded = 0;\n  if (opts.onprogress) {\n    opts.onprogress(0, 0, progressTotal);\n  }\n  for (let line of lines) {\n    ++progressLoaded;\n    line = line.trim();\n    if (line.length <= 0) continue;\n    if (line.startsWith('#')) continue;\n    if (line.startsWith('//')) continue;\n\n    let args = [];\n    let i = 0;\n    let j = line.indexOf(' ');\n    while (j >= 0) {\n      args.push(line.substring(i, j));\n      i = j + 1;\n      j = line.indexOf(' ', i);\n    }\n    args.push(line.substring(i));\n\n    let name = args[0];\n    let u = Number.parseInt(args[1]);\n    let v = Number.parseInt(args[2]);\n    let w = Number.parseInt(args[3]);\n    let h = Number.parseInt(args[4]);\n    let frames =\n      args.length >= 6\n        ? Number.parseInt(args[5]) // User-defined\n        : 1; // Default 1 frame\n    let cols =\n      args.length >= 7\n        ? Number.parseInt(args[6]) // User-defined\n        : frames; // Default same as frame count\n    let rows =\n      args.length >= 8\n        ? Number.parseInt(args[7]) // User-defined\n        : frames > cols // If more frames than cols...\n        ? Math.ceil(frames / cols) // ...then expect more rows\n        : 1; // Otherwise, default single row\n\n    result[name] = {\n      u,\n      v,\n      w,\n      h,\n      frames,\n      cols,\n      rows,\n      name,\n    };\n\n    if (opts.onprogress) {\n      opts.onprogress(progressLoaded / progressTotal, progressLoaded, progressTotal);\n    }\n  }\n  if (opts.onprogress) {\n    opts.onprogress(1, progressLoaded, progressLoaded);\n  }\n  return result;\n}\n","/**\n * @param {ArrayBuffer|Uint8Array|string} src\n * @param {object} opts\n * @param {AudioContext} opts.audioContext\n * @returns {Promise<AudioBuffer>}\n */\nexport async function AudioBufferLoader(src, opts) {\n  const { audioContext } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return AudioBufferLoader(arrayBuffer, { audioContext });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  let audioArrayBuffer = new ArrayBuffer(arrayBuffer.byteLength);\n  new Uint8Array(audioArrayBuffer).set(arrayBuffer);\n  let audioBuffer = await audioContext.decodeAudioData(audioArrayBuffer);\n  return audioBuffer;\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @param {object} [opts]\n * @param {string} [opts.imageType]\n * @returns {Promise<HTMLImageElement>}\n */\nexport async function ImageLoader(src, opts = undefined) {\n  let { imageType = undefined } = opts || {};\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    if (typeof imageType === 'undefined') {\n      let i = src.lastIndexOf('.');\n      if (i < 0) {\n        throw new Error('Cannot load from url - unknown image type.');\n      } else {\n        imageType = 'image/' + src.slice(i + 1);\n      }\n    }\n    return ImageLoader(arrayBuffer, { ...opts, imageType });\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  if (typeof imageType === 'undefined') {\n    imageType = 'image/png';\n  }\n  let blob = new Blob([arrayBuffer], { type: imageType });\n  let imageUrl = URL.createObjectURL(blob);\n  let image = new Image();\n  return new Promise((resolve, reject) => {\n    image.addEventListener('load', () => {\n      resolve(image);\n    });\n    image.addEventListener('error', (e) => {\n      reject(e);\n    });\n    image.src = imageUrl;\n  });\n}\n","/**\n * @typedef MeshData\n * @property {Float32Array} positions\n * @property {Float32Array} texcoords\n * @property {Float32Array} normals\n * @property {Uint16Array} indices\n */\n\n/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<MeshData>}\n */\nexport async function OBJLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return OBJLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return parse(new TextDecoder().decode(arrayBuffer));\n}\n\n/**\n * @param {string} string\n * @returns {MeshData}\n */\nfunction parse(string) {\n  const vertexList = [];\n  const texcoordList = [];\n  const normalList = [];\n\n  const vertexIndices = [];\n  const texcoordIndices = [];\n  const normalIndices = [];\n\n  // # comments\n  const commentPattern = /^#.*/g;\n  // v float float float\n  const vertexPattern = /v\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vn float float float\n  const normalPattern = /vn\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/g;\n  // vt float float float\n  const texcoordPattern = /vt\\s+(\\S+)\\s+(\\S+)/g;\n  // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n  const facePattern =\n    /f\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*))(\\s+(([^/\\s]*)\\/([^/\\s]*)\\/?([^/\\s]*)))?/g;\n  // f float float float\n  const faceVertexPattern = /f\\s+([^/\\s]+)\\s+([^/\\s]+)\\s+([^/\\s]+)/g;\n\n  let quad = false;\n  let result = null;\n  let x, y, z, w;\n\n  // Remove all comments\n  string = string.replace(commentPattern, '');\n\n  // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = vertexPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    vertexList.push(x);\n    vertexList.push(y);\n    vertexList.push(z);\n  }\n\n  // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n  while ((result = normalPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    z = Number.parseFloat(result[3]);\n    normalList.push(x);\n    normalList.push(y);\n    normalList.push(z);\n  }\n\n  // [\"vt 1.0 2.0\", \"1.0\", \"2.0\"]\n  while ((result = texcoordPattern.exec(string)) != null) {\n    x = Number.parseFloat(result[1]);\n    y = Number.parseFloat(result[2]);\n    texcoordList.push(x);\n    texcoordList.push(y);\n  }\n\n  // [\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1\", \"1\", \"1\", \"1\", \"2/2/2\", \"2\", \"2\", \"2\", \"3/3/3\", \"3\", \"3\", \"3\", \"4/4/4\", \"4\", \"4\", \"4\"]\n  while ((result = facePattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    if (Number.isNaN(x)) x = 1;\n    y = Number.parseInt(result[6]);\n    if (Number.isNaN(y)) y = 1;\n    z = Number.parseInt(result[10]);\n    if (Number.isNaN(z)) z = 1;\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // Normal indices\n    x = Number.parseInt(result[4]);\n    if (Number.isNaN(x)) {\n      // No UVs.\n      x = Number.parseInt(result[3]);\n      y = Number.parseInt(result[7]);\n      z = Number.parseInt(result[11]);\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n      texcoordIndices.push(1);\n    } else {\n      // Maybe UVs.\n      y = Number.parseInt(result[8]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[12]);\n      if (Number.isNaN(z)) z = 1;\n      normalIndices.push(x);\n      normalIndices.push(y);\n      normalIndices.push(z);\n\n      // UV indices\n      x = Number.parseInt(result[3]);\n      if (Number.isNaN(x)) x = 1;\n      y = Number.parseInt(result[7]);\n      if (Number.isNaN(y)) y = 1;\n      z = Number.parseInt(result[11]);\n      if (Number.isNaN(z)) z = 1;\n      texcoordIndices.push(x);\n      texcoordIndices.push(y);\n      texcoordIndices.push(z);\n    }\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[15]);\n      if (Number.isNaN(w)) w = 1;\n      vertexIndices.push(w);\n\n      // Normal indices\n      w = Number.parseInt(result[17]);\n      if (Number.isNaN(w)) {\n        // No UVs.\n        w = Number.parseInt(result[16]);\n        normalIndices.push(w);\n        texcoordIndices.push(1);\n      } else {\n        // Maybe UVs.\n        normalIndices.push(w);\n\n        w = Number.parseInt(result[16]);\n        texcoordIndices.push(w);\n      }\n\n      quad = true;\n    }\n  }\n\n  // [\"f 1 2 3 4\", \"1\", \"2\", \"3\", \"4\"]\n  while ((result = faceVertexPattern.exec(string)) != null) {\n    // Vertex indices\n    x = Number.parseInt(result[2]);\n    y = Number.parseInt(result[6]);\n    z = Number.parseInt(result[10]);\n    vertexIndices.push(x);\n    vertexIndices.push(y);\n    vertexIndices.push(z);\n\n    // UV indices\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n    texcoordIndices.push(1);\n\n    // Normal indices\n    normalIndices.push(1);\n    normalIndices.push(1);\n    normalIndices.push(1);\n\n    // Quad face\n    if (typeof result[13] !== 'undefined') {\n      // Vertex indices\n      w = Number.parseInt(result[14]);\n      vertexIndices.push(w);\n\n      // UV indices\n      texcoordIndices.push(1);\n      // Normal indices\n      normalIndices.push(1);\n\n      quad = true;\n    }\n  }\n\n  let index, size;\n\n  size = vertexIndices.length;\n  const positions = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = vertexIndices[i] - 1;\n    positions[i * 3 + 0] = vertexList[index * 3 + 0];\n    positions[i * 3 + 1] = vertexList[index * 3 + 1];\n    positions[i * 3 + 2] = vertexList[index * 3 + 2];\n  }\n\n  size = texcoordIndices.length;\n  const texcoords = new Float32Array(size * 2);\n  for (let i = 0; i < size; ++i) {\n    index = texcoordIndices[i] - 1;\n    texcoords[i * 2 + 0] = texcoordList[index * 2 + 0];\n    texcoords[i * 2 + 1] = texcoordList[index * 2 + 1];\n  }\n\n  size = normalIndices.length;\n  const normals = new Float32Array(size * 3);\n  for (let i = 0; i < size; ++i) {\n    index = normalIndices[i] - 1;\n    normals[i * 3 + 0] = normalList[index * 3 + 0];\n    normals[i * 3 + 1] = normalList[index * 3 + 1];\n    normals[i * 3 + 2] = normalList[index * 3 + 2];\n  }\n\n  // Must be either unsigned short or unsigned byte.\n  size = vertexIndices.length;\n  const indices = new Uint16Array(size);\n  for (let i = 0; i < size; ++i) {\n    indices[i] = i;\n  }\n\n  if (quad) {\n    console.warn('WebGL does not support quad faces, only triangles.');\n  }\n\n  return {\n    positions,\n    texcoords,\n    normals,\n    indices,\n  };\n}\n","/**\n * @param {string|ArrayBuffer} src\n * @returns {Promise<string>}\n */\nexport async function TextLoader(src) {\n  if (typeof src === 'string') {\n    const response = await fetch(src);\n    const arrayBuffer = await response.arrayBuffer();\n    return TextLoader(arrayBuffer);\n  } else if (!(src instanceof ArrayBuffer || ArrayBuffer.isView(src))) {\n    throw new Error(\n      'Cannot load from source - must be ' + 'an array buffer or fetchable url'\n    );\n  }\n  /** @type {ArrayBuffer} */\n  const arrayBuffer = src;\n  return new TextDecoder().decode(arrayBuffer);\n}\n","import { unzip } from 'fflate';\n\nimport { cacheInStore } from './AssetStore.js';\nimport { AssetManager } from './AssetManager.js';\nimport { AssetRef } from './AssetRef.js';\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {string} url\n * @param {(src: Uint8Array, path: string) => void} callback\n */\nexport async function loadAssetPack(url, callback) {\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    callback(buf, path);\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * Fetch asset pack from url and cache raw file content under `raw://`.\n * \n * @param {AssetManager} assets\n * @param {string} url\n * @param {(src: Uint8Array, uri: string, path: string) => void} [callback]\n */\nexport async function cacheAssetPackAsRaw(assets, url, callback = undefined) {\n    const assetStore = /** @type {import('./AssetStore').AssetStore} */ (/** @type {unknown} */ (assets));\n    let rootPath = 'raw://';\n    let response = await fetch(url);\n    let arrayBuffer = await response.arrayBuffer();\n    await new Promise((resolve, reject) => {\n        unzip(new Uint8Array(arrayBuffer), (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                for (let [path, buf] of Object.entries(data)) {\n                    // Standardize WIN paths\n                    path = path.replaceAll('\\\\', '/');\n                    // Remove the zip directory name\n                    let i = path.indexOf('/');\n                    if (i >= 0) {\n                        path = path.substring(i + 1);\n                    }\n                    // Put the raw file in cache\n                    let uri = rootPath + path;\n                    cacheInStore(assetStore, uri, buf);\n                    if (callback) {\n                        callback(buf, uri, path);\n                    }\n                }\n                resolve();\n            }\n        });\n    });\n}\n\n/**\n * This is the same as calling `await AssetRef.load()` for each ref.\n * \n * @param {AssetManager} assets\n * @param {Array<AssetRef<?, ?>>} refs \n * @param {number} [timeout] \n */\nexport async function preloadAssetRefs(assets, refs, timeout = 5000) {\n    let promises = [];\n    for (let ref of refs) {\n        promises.push(ref.load(assets, timeout));\n    }\n    await Promise.allSettled(promises);\n}\n"],"names":["path","require$$0","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","SLASH_LITERAL","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","POSIX_CHARS","PLUS_LITERAL","QMARK_LITERAL","ONE_CHAR","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","WINDOWS_CHARS","constants","MAX_LENGTH","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_GRAVE_ACCENT","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","SEP","sep","extglobChars","chars","type","open","close","globChars","win32","process","platform","require$$1","exports","isObject","val","Array","isArray","hasRegexChars","str","test","isRegexChar","length","escapeRegex","replace","toPosixSlashes","removeBackslashes","match","supportsLookbehinds","segs","version","slice","split","map","Number","isWindows","options","windows","escapeLast","input","char","lastIdx","idx","lastIndexOf","removePrefix","state","output","startsWith","prefix","wrapOutput","contains","negated","utils","isPathSeparator","code","depth","token","isPrefix","isGlobstar","Infinity","scan_1","opts","scanToEnd","parts","slashes","tokens","prev","index","start","lastIndex","isBrace","isBracket","isGlob","isExtglob","braceEscaped","backslashes","negatedExtglob","finished","braces","value","eos","advance","charCodeAt","next","noext","nonegate","noparen","push","base","glob","unescape","maxDepth","prevIndex","n","i","expandRange","args","sort","join","RegExp","ex","v","syntaxError","parse","TypeError","max","maxLength","Math","min","len","SyntaxError","bos","prepend","capture","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noextglob","consumed","backtrack","brackets","parens","quotes","extglobs","stack","peek","remaining","consume","num","append","negate","count","increment","decrement","pop","tok","extglob","inner","extglobOpen","conditions","extglobClose","rest","extglobStar","includes","expression","fastpaths","m","esc","first","repeat","exec","posix","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","unshift","comma","out","toks","t","Error","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","suffix","slashDot","create","source","scan","require$$3","require$$4","picomatch","returnState","fns","arrayMatcher","isMatch","isState","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","result","onIgnore","format","matchBase","basename","Boolean","patterns","pattern","p","returnOutput","toRegex","parsed","flags","nocase","err","debug","picomatch_1","module","GlobExp","constructor","String","this","_re","string","ch2","u8","Uint8Array","u16","Uint16Array","u32","Uint32Array","fleb","fdeb","clim","freb","eb","b","r","j","_a","fl","revfl","fd","rev","x","hMap","cd","mb","s","l","co","le","rvb","sv","r_1","flt","fdt","flrm","fdrm","a","bits","d","o","bits16","shft","slc","e","BYTES_PER_ELEMENT","set","subarray","ec","ind","msg","nt","captureStackTrace","inflt","dat","buf","st","sl","f","noBuf","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","lpos","sym","add","dsym","et","wcln","fn","fnStr","td","toString","ks","k","st_1","prototype","spInd","ch","wrkr","init","id","cb","td_1","mrg","transfer","w","Worker","URL","createObjectURL","Blob","onmessage","data","ed","$e$","postMessage","wk","buffer","cbfs","bInflt","inflateSync","pbf","gu8","size","cbify","terminate","b2","b4","b8","TextDecoder","decode","stream","dutf8","fromCharCode","slzh","zh","z","fnl","latin1","apply","strFromU8","es","bs","z64e","sc","su","off","mt","queueMicrotask","setTimeout","unzip","term","tAll","files","cbd","lft","ze","fltr","filter","_loop_3","c_1","no","cbl","name","originalSize","compression","infl","ev","inflate","FILE_URI_PREFIX_PATTERN","async","loadInStore","assets","uri","src","loader","timeout","loadings","loading","Loading","attempt","nextAttempt","promises","promise","getLoadedInStore","then","cached","isCurrentAttempt","cacheInStore","undefined","Promise","race","store","resolve","getCurrentInStore","isAssetCachedInStore","isAssetLoadingInStore","Fallback","static","_promiseHandle","_resolve","_reject","_reason","_value","_timeoutHandle","isFinite","reject","_promise","clearTimeout","reason","AssetRef","filepath","initial","current","cache","assetManager","get","exists","load","reload","TAG_PATTERN","LINE_PATTERN","parseBMLine","line","props","prop","array","_","key","JSON","parent","defaults","def","getDefaultInStore","fallback","uriGlob","cacheDefaultInStore","unload","unloadInStore","clear","Object","entries","keys","clearInStore","hasInStore","getLoadingInStore","keysInStore","reset","resetStore","AtlasLoader","onprogress","response","fetch","arrayBuffer","ArrayBuffer","isView","lines","progressTotal","progressLoaded","trim","substring","u","parseInt","h","frames","cols","rows","ceil","AudioBufferLoader","audioContext","audioArrayBuffer","byteLength","decodeAudioData","BMFontLoader","info","common","page","kernings","tag","kerning","ImageLoader","imageType","blob","imageUrl","image","Image","addEventListener","OBJLoader","vertexList","texcoordList","normalList","vertexIndices","texcoordIndices","normalIndices","commentPattern","vertexPattern","normalPattern","texcoordPattern","facePattern","faceVertexPattern","y","quad","parseFloat","isNaN","positions","Float32Array","texcoords","normals","indices","console","warn","TextLoader","url","callback","assetStore","replaceAll","refs","ref","allSettled"],"mappings":"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"}