"use strict";var t=require("gl-matrix");const e=t.vec3.fromValues(0,1,0);class n{constructor(t,e){this.projectionMatrix=t,this.viewMatrix=e}resize(t,e){return this}}const i=Math.PI/3;const s=Math.PI/180;const r=100;function a(t){return t.roots}function o(t,e){return t.parents[e]}function l(t,e,n){t.parents[e]=n}function c(t,e){if(e in t.children)return t.children[e];{let n=[];return t.children[e]=n,n}}function h(t,e,n){n?(c(t,n).push(e),l(t,e,n)):(a(t).push(e),l(t,e,0))}function u(t,e,n){if(n){let i=c(t,n),s=i.indexOf(e);i.splice(s,1)}else{let n=a(t),i=n.indexOf(e);n.splice(i,1)}l(t,e,0)}function m(t,e,n,i,s){if(n>=r)return;let a=i(e,t);if(!1===a)return;let o=c(t,e),l=s?s(o,e,t):o;for(let e of l)m(t,e,n+1,i,s);"function"==typeof a&&a(e,t)}function p(t,e){delete e.parents[t],delete e.children[t]}var f=Object.freeze({__proto__:null,add:function(t,e,n=0){h(t,e,n)},clone:function(t){return{roots:t.roots.slice(),parents:{...t.parents},children:Object.fromEntries(Object.entries(t.children).map((([t,e])=>[t,e.slice()])))}},create:function(){return{roots:[],parents:{},children:{}}},getChildren:c,getParent:o,getRoots:a,has:function(t,e){return e in t.parents},parent:function(t,e,n){u(t,e,o(t,e)),h(t,e,n)},prune:function(t,e){if(!(e in t.parents))throw new Error("Cannot delete non-existant scene node for scene graph.");u(t,e,o(t,e)),m(t,e,0,p)},replace:function(t,e,n){let i=o(t,e),s=c(t,e).slice();if(u(t,e,i),function(t,e){e in t&&(t.children[e].length=0,delete t.children[e])}(t,e),n){let e=o(t,n),r=c(t,n);u(this,n,e),r.push(...s),h(this,n,i)}else if(i){c(t,i).push(...s)}else a(t).push(...s);for(let e of s)l(t,e,i)},walk:function(t,e,n){const{from:i,childFilter:s}=n||{};let r;r=i?Array.isArray(i)?i:[i]:a(t),s&&(r=s(r,0,this));for(let n of r)m(t,n,0,e,s)}});class d{constructor(){this.cachedResults={},this.keyQueryMapping={},this.onEntityComponentChanged=this.onEntityComponentChanged.bind(this)}onEntityComponentChanged(t,e,n,i,s){for(let r of Object.values(this.keyQueryMapping)){let a=this.cachedResults[r.key];if(s){let t=a.indexOf(e);t>=0&&a.splice(t,1)}else if(n){if(r.hasSelector(y(n))){let t=a.indexOf(e);t>=0&&a.splice(t,1)}else if(r.hasSelector(n)&&this.test(t,e,r.selectors)){a.indexOf(e)<0&&a.push(e)}}else if(i)if(r.hasSelector(y(i))&&this.test(t,e,r.selectors)){a.indexOf(e)<0&&a.push(e)}else if(r.hasSelector(i)&&this.test(t,e,r.selectors)){let t=a.indexOf(e);t>=0&&a.splice(t,1)}}}test(t,e,n){for(let i of n)if(g(i)){const n=i.value;if(t.exists(e,n))return!1}else{const n=i;if(!t.exists(e,n))return!1}return!0}hydrate(t,e,n){if(n.length<=0)return t.length=0,t;let i=e.entityIds();for(let s of i)this.test(e,s,n)&&t.push(s);return t}findAll(t,e){const n=e.key;let i;return n in this.keyQueryMapping?i=this.cachedResults[n]:(i=[],this.keyQueryMapping[n]=e,this.cachedResults[n]=i,this.hydrate(i,t,e.selectors)),i}count(t,e){return this.findAll(t,e).length}clear(t){const e=t.key;e in this.keyQueryMapping&&(delete this.keyQueryMapping[e],delete this.cachedResults[e])}reset(){this.keyQueryMapping={},this.cachedResults={}}}function y(t){return{type:"not",name:t.name,value:t}}function g(t){return"type"in t&&"not"===t.type}class v{constructor(...t){if(t.length<=0)throw new Error("Must have at least 1 selector for query.");this.selectors=t,this.key=function(t){return t.map((t=>g(t)?`!${t.name}`:t.name)).sort().join("&")}(t)}hasSelector(t){return g(t)?this.selectors.findIndex((e=>g(e)&&e.name===t.name))>=0:this.selectors.findIndex((e=>e.name===t.name))>=0}count(t){return t.queries.count(t,this)}*findEntityIds(t){const e=t.queries;for(let n of e.findAll(t,this))yield n}*findComponents(t,e){if(this.selectors.indexOf(e)<0)throw new Error(`Cannot find component for class '${e.name}' not in query.`);const n=t.queries;for(let i of n.findAll(t,this))yield t.get(i,e)}}function b(t,e,n,i){for(let[s,r]of Object.entries(i))g(r)?t[s]=null:t[s]=e.get(n,r);return t}class O{constructor(t){this.name=t}dispatch(t,e){t.dispatch(this,e)}dispatchImmediately(t,e){t.dispatchImmediately(this,e)}on(t,e,n){return t.addEventListener(this,n,{priority:e}),this}off(t,e){return t.removeEventListener(this,e),this}once(t,e,n){let i=e=>(this.off(t,i),n(e));return this.on(t,e,i)}*poll(t,e){e=Math.min(e,t.count(this));for(let n=0;n<e;++n)yield t.poll(this)}retain(t,e){t.retain(this,e)}*pollAndRetain(t,e){this.retain(t,e);for(let n of this.poll(t,e))yield n}}function x(t,e){return t.priority-e.priority}exports.AnimationFrameLoop=class{constructor(t,e){const{animationFrameHandler:n=window}=e||{};this.handle=0,this.detail={prevTime:-1,currentTime:-1,deltaTime:0},this.animationFrameHandler=n,this.callback=t,this.next=this.next.bind(this),this.start=this.start.bind(this),this.cancel=this.cancel.bind(this)}get running(){return 0!==this.handle}next(t=performance.now()){this.handle=this.animationFrameHandler.requestAnimationFrame(this.next);let e=this.detail;e.prevTime=e.currentTime,e.currentTime=t,e.deltaTime=e.currentTime-e.prevTime,this.callback(this)}start(){return this.handle=this.animationFrameHandler.requestAnimationFrame(this.next),this}cancel(){return this.animationFrameHandler.cancelAnimationFrame(this.handle),this}},exports.Archetype=class extends v{constructor(t){super(...Object.values(t)),this.components=t}create(t){let e=t.create(),n={};for(let[i,s]of Object.entries(this.components)){let r=t.attach(e,s);n[i]=r}return n}destroy(t,e){for(let n of Object.values(this.components))t.detach(e,n)}find(t,e){return null===e?{}:b({},t,e,this.components)}findAny(t){let e=t.queries.findAll(t,this);return e.length<=0?{}:b({},t,e[Math.floor(Math.random()*e.length)],this.components)}*findAll(t){let e={},n=t.queries.findAll(t,this);for(let i of n)yield b(e,t,i,this.components)}},exports.AsyncTopic=class extends O{constructor(t){super(t)}async dispatch(t,e){throw new Error("Not yet implemented")}async dispatchImmediately(t,e){await t.dispatchImmediatelyAndWait(this,e)}on(t,e,n){return super.on(t,e,n)}off(t,e){return super.off(t,e)}once(t,e,n){return super.once(t,e,n)}},exports.Camera=n,exports.ComponentClass=class{constructor(t,e=(()=>null),n=(()=>{})){this.name=t,this.new=e,this.delete=n}},exports.EntityManager=class{constructor(){this.components={},this.nameClassMapping={},this.nextAvailableEntityId=1,this.queue=[],this.listeners=[],this.queries=new d}entityComponentChangedCallback(t,e,n,i){this.queries.onEntityComponentChanged(this,t,e,n,i);for(let s of this.listeners)s(this,t,e,n,i)}addEventListener(t,e){"change"===t&&this.listeners.push(e)}removeEventListener(t,e){if("change"===t){let t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}}flush(){for(;this.queue.length>0;){let[t,...e]=this.queue.shift();switch(t){case"attach":{let[t,n,i]=e;this.attachImmediately(t,n,i)}break;case"detach":{let[t,n]=e;this.detachImmediately(t,n)}break;case"clear":{let[t]=e;this.clearImmediately(t)}}}}create(){let t=this.nextAvailableEntityId++;return this.entityComponentChangedCallback(t,null,null,!1),t}destroy(t){const e=this.components;for(const n of Object.keys(e)){const i=e[n];t in i&&(delete i[t],this.entityComponentChangedCallback(t,null,this.nameClassMapping[n],!1))}this.entityComponentChangedCallback(t,null,null,!0)}exists(t,...e){if(e.length>0){for(const n of e){if(!(t in this.mapOf(n)))return!1}return!0}for(let e of Object.values(this.components))if(t in e)return!0;return!1}attach(t,e,n){return void 0===n&&(n=e.new()),this.queue.push(["attach",t,e,n]),n}attachImmediately(t,e,n){return void 0===n&&(n=e.new()),this.mapOf(e)[t]=n,this.entityComponentChangedCallback(t,e,null,!1),n}detach(t,e){this.queue.push(["detach",t,e])}detachImmediately(t,e){let n=this.mapOf(e),i=n[t];delete n[t],e.delete(i),this.entityComponentChangedCallback(t,null,e,!1)}clear(t){this.queue.push(["clear",t])}clearImmediately(t){const e=t.name,n=this.components,i=n[e];let s=Object.keys(i).map(Number),r=Object.values(i);n[e]={},this.nameClassMapping[e]=t;for(let e of r)t.delete(e);for(let e of s)this.entityComponentChangedCallback(e,null,t,!1)}get(t,e){return this.mapOf(e)[t]||null}count(t){return Object.keys(this.mapOf(t)).length}keysOf(t){return Object.keys(this.mapOf(t)).map(Number)}valuesOf(t){return Object.values(this.mapOf(t))}mapOf(t){const e=t.name,n=this.components;if(e in n)return n[e];{let i={};return n[e]=i,this.nameClassMapping[e]=t,i}}entityIds(){let t=new Set;for(let e of Object.values(this.components))for(let n of Object.keys(e))t.add(Number(n));return t}componentClasses(){return Object.values(this.nameClassMapping)}reset(){const t=this.components;let e=new Set;for(const n of Object.keys(t)){const i=this.nameClassMapping[n],s=t[n];for(let t of Object.keys(s))e.add(Number(t));this.clearImmediately(i)}for(let t of e)this.entityComponentChangedCallback(t,null,null,!0);e.clear(),this.queries.reset(),this.components={},this.nextAvailableEntityId=1,this.queue.length=0,this.listeners.length=0}},exports.FirstPersonCameraController=class{constructor(e={locky:!1}){this.locky=e.locky,this.position=t.vec3.create(),this.forward=t.vec3.fromValues(0,0,-1),this.right=t.vec3.fromValues(1,0,0),this.up=t.vec3.fromValues(0,1,0),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.pitch=0,this.yaw=-90}look(t,e,n=1){return n*=1e3,this.pitch=Math.min(89.9,Math.max(-89.9,this.pitch+e*n)),this.yaw=(this.yaw+t*n)%360,this}move(t,e=0,n=0,i=1){return this.forwardAmount+=t*i,this.rightAmount+=e*i,this.upAmount+=n*i,this}apply(e){let{position:n,forward:i,right:r,up:a,forwardAmount:o,rightAmount:l,upAmount:c,pitch:h,yaw:u}=this,m=u*s,p=h*s,f=Math.cos(m),d=Math.cos(p),y=Math.sin(m),g=f*d,v=Math.sin(p),b=y*d;t.vec3.normalize(i,t.vec3.set(i,g,this.locky?0:v,b)),t.vec3.normalize(r,t.vec3.cross(r,i,a));let O=t.vec3.create();t.vec3.scale(O,i,o),t.vec3.add(n,n,O),t.vec3.scale(O,r,l),t.vec3.add(n,n,O),t.vec3.scale(O,a,c),t.vec3.add(n,n,O),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.locky&&t.vec3.set(i,g,v,b);let x=t.vec3.add(O,n,i);return t.mat4.lookAt(e,n,x,a),e}},exports.Not=y,exports.OrthographicCamera=class extends n{constructor(e,n,i,s,r=-1e3,a=1e3){super(t.mat4.create(),t.mat4.create()),this.orthoBounds={left:void 0===e?void 0:Number(e),top:void 0===n?void 0:Number(n),right:void 0===i?void 0:Number(i),bottom:void 0===s?void 0:Number(s)},this.clippingPlane={near:Number(r),far:Number(a)}}resize(e,n){const{near:i,far:s}=this.clippingPlane,{left:r,top:a,right:o,bottom:l}=this.orthoBounds;let c=this.projectionMatrix,h=void 0!==r;if(void 0!==e)if(h){const h=e/n;t.mat4.ortho(c,r*h,o*h,l,a,i,s)}else t.mat4.ortho(c,0,e,n,0,i,s);else h?t.mat4.ortho(c,r,o,l,a,i,s):t.mat4.ortho(c,-1,1,1,-1,-1,1);return this}},exports.PerspectiveCamera=class extends n{constructor(e=i,n=.1,s=1e3){super(t.mat4.create(),t.mat4.create()),this.fieldOfView=Number(e),this.clippingPlane={near:Number(n),far:Number(s)}}resize(e,n){const i=void 0===e?1:e/n,{near:s,far:r}=this.clippingPlane;return t.mat4.perspective(this.projectionMatrix,this.fieldOfView,i,s,r),this}},exports.Query=v,exports.QueryManager=d,exports.SceneGraph=f,exports.Topic=O,exports.TopicManager=class{constructor(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}addEventListener(t,e,n){const{priority:i=0}=n;let s=this.callbacksOf(t);s.push({callback:e,priority:i}),s.sort(x)}removeEventListener(t,e){let n=this.callbacksOf(t),i=n.findIndex((t=>t.callback===e));i>=0&&n.splice(i,1)}countEventListeners(t){return this.callbacksOf(t).length}dispatch(t,e){this.incomingOf(t).push(e)}dispatchImmediately(t,e){let n=this.callbacksOf(t);for(let{callback:t}of n){if(!0===t(e))return}this.outgoingOf(t).push(e)}async dispatchImmediatelyAndWait(t,e){let n=this.callbacksOf(t);for(let{callback:t}of n){if(!0===await t(e))return}this.outgoingOf(t).push(e)}count(t){return this.outgoingOf(t).length}poll(t){let e=this.outgoingOf(t);return e.length<=0?null:e.shift()}retain(t,e){const n=t.name;let i=Math.max(e,this.maxRetains[n]||0);this.maxRetains[n]=i}flush(t=100){for(const e of Object.keys(this.cachedIn)){const n=this.nameTopicMapping[e],i=this.cachedIn[e],s=this.cachedOut[e],r=this.maxRetains[e]||0;r<s.length&&s.splice(0,s.length-r);let a=Math.min(t,i.length);for(let t=0;t<a;++t){let t=i.shift();this.dispatchImmediately(n,t)}}}getPendingRetainCount(t){return this.maxRetains[t.name]||0}getPendingFlushCount(t){return this.incomingOf(t).length}reset(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}incomingOf(t){const e=t.name;if(e in this.cachedIn)return this.cachedIn[e];{let n=[];return this.cachedIn[e]=n,this.cachedOut[e]=[],this.nameTopicMapping[e]=t,n}}outgoingOf(t){const e=t.name;if(e in this.cachedOut)return this.cachedOut[e];{let n=[];return this.cachedIn[e]=[],this.cachedOut[e]=n,this.nameTopicMapping[e]=t,n}}callbacksOf(t){const e=t.name;if(e in this.callbacks)return this.callbacks[e];{let t=[];return this.callbacks[e]=t,t}}},exports.isSelectorNot=g,exports.lookAt=function(n,i,s,r=0,a=1){let o=t.vec3.create(),l=t.quat.create();t.mat4.getTranslation(o,n),t.mat4.getRotation(l,n);let c=t.vec3.fromValues(i,s,r);t.mat4.lookAt(n,o,c,e);let h=t.quat.create();t.mat4.getRotation(h,n),t.quat.slerp(l,l,h,a),t.mat4.fromRotationTranslation(n,l,o)},exports.panTo=function(e,n,i,s=0,r=1){let a=t.vec3.create();t.mat4.getTranslation(a,e);let o=t.vec3.fromValues((n-a[0])*r,(i-a[1])*r,(s-a[2])*r);t.mat4.translate(e,e,o)},exports.screenToWorldRay=function(e,n,i,s,r,a=!1){let o=t.vec4.fromValues(n,i,-1,1),l=t.mat4.create();return t.mat4.invert(l,s),t.vec4.transformMat4(o,o,l),o[2]=-1,o[3]=0,t.mat4.invert(l,r),t.vec4.transformMat4(o,o,l),e[0]=o[0],e[1]=o[1],e[2]=o[2],a&&t.vec3.normalize(e,e),e};
//# sourceMappingURL=milque-scene.cjs.js.map
