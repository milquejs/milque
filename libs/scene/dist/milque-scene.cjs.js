"use strict";var t=require("gl-matrix");const e=t.vec3.fromValues(0,1,0);class n{constructor(t,e){this.projectionMatrix=t,this.viewMatrix=e}resize(t,e){return this}}const s=Math.PI/3;const i=Math.PI/180;const r=100;function o(t,e,n){t?(n.nodes[t].children.push(e),n.nodes[e].parent=t):(n.roots.push(e),n.nodes[e].parent=0)}function a(t,e,n){if(t){let s=n.nodes[t].children,i=s.indexOf(e);s.splice(i,1),n.nodes[e].parentNode=0}else{let t=n.roots,s=t.indexOf(e);t.splice(s,1),n.nodes[e].parentNode=0}}function l(t,e,n,s,i){if(n>=r)return;let o=s(e,t);if(!1===o)return;let a=t.nodes[e],c=i?i(a.children,e,t):a.children;for(let e of c)l(t,e,n+1,s,i);"function"==typeof o&&o(e,t)}function c(t,e){delete e.nodes[t]}class h{constructor(){this.cachedResults={},this.keyQueryMapping={},this.onEntityComponentChanged=this.onEntityComponentChanged.bind(this)}onEntityComponentChanged(t,e,n,s,i){for(let r of Object.values(this.keyQueryMapping)){let o=this.cachedResults[r.key];if(i){let t=o.indexOf(e);t>=0&&o.splice(t,1)}else if(n){if(r.hasSelector(u(n))){let t=o.indexOf(e);t>=0&&o.splice(t,1)}else if(r.hasSelector(n)&&r.test(t,e)){o.indexOf(e)<0&&o.push(e)}}else if(s)if(r.hasSelector(u(s))&&r.test(t,e)){o.indexOf(e)<0&&o.push(e)}else if(r.hasSelector(s)&&r.test(t,e)){let t=o.indexOf(e);t>=0&&o.splice(t,1)}}}findAny(t,e){let n=this.findAll(t,e);return n.length<=0?null:n[Math.floor(Math.random()*n.length)]}findAll(t,e){const n=e.key;let s;return n in this.keyQueryMapping?s=this.cachedResults[n]:(s=[],this.keyQueryMapping[n]=e,this.cachedResults[n]=s,e.hydrate(t,s)),s}count(t,e){return this.findAll(t,e).length}clear(t){const e=t.key;e in this.keyQueryMapping&&(delete this.keyQueryMapping[e],delete this.cachedResults[e])}reset(){this.keyQueryMapping={},this.cachedResults={}}}function u(t){return{type:"not",name:t.name,value:t}}function d(t){return"type"in t&&"not"===t.type}function f(t,e,n,s){t[0]=n;let i=1;for(let r of s)d(r)?t[i]=null:t[i]=e.get(n,r),++i;return t}class m{constructor(t){this.name=t}dispatch(t,e){t.dispatch(this,e)}dispatchImmediately(t,e){t.dispatchImmediately(this,e)}async dispatchImmediatelyAndWait(t,e){await t.dispatchImmediatelyAndWait(this,e)}on(t,e,n){return t.addEventListener(this,n,{priority:e}),this}off(t,e){return t.removeEventListener(this,e),this}once(t,e,n){let s=e=>(this.off(t,s),n(e));return this.on(t,e,s)}*poll(t,e){e=Math.min(e,t.count(this));for(let n=0;n<e;++n)yield t.poll(this)}retain(t,e){t.retain(this,e)}*pollAndRetain(t,e){this.retain(t,e);for(let n of this.poll(t,e))yield n}}function p(t,e){return t.priority-e.priority}class y{constructor(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}addEventListener(t,e,n){const{priority:s=0}=n;let i=this.callbacksOf(t);i.push({callback:e,priority:s}),i.sort(p)}removeEventListener(t,e){let n=this.callbacksOf(t),s=n.findIndex((t=>t.callback===e));s>=0&&n.splice(s,1)}countEventListeners(t){return this.callbacksOf(t).length}dispatch(t,e){this.incomingOf(t).push(e)}dispatchImmediately(t,e){let n=this.callbacksOf(t);for(let{callback:t}of n){if(!0===t(e))return}this.outgoingOf(t).push(e)}async dispatchImmediatelyAndWait(t,e){let n=this.callbacksOf(t);for(let{callback:t}of n){if(!0===await t(e))return}this.outgoingOf(t).push(e)}count(t){return this.outgoingOf(t).length}poll(t){let e=this.outgoingOf(t);return e.length<=0?null:e.shift()}retain(t,e){const n=t.name;let s=Math.max(e,this.maxRetains[n]||0);this.maxRetains[n]=s}flush(t=100){for(const e of Object.keys(this.cachedIn)){const n=this.nameTopicMapping[e],s=this.cachedIn[e],i=this.cachedOut[e],r=this.maxRetains[e]||0;r<i.length&&i.splice(0,i.length-r);let o=Math.min(t,s.length);for(let t=0;t<o;++t){let t=s.shift();this.dispatchImmediately(n,t)}}}getPendingRetainCount(t){return this.maxRetains[t.name]||0}getPendingFlushCount(t){return this.incomingOf(t).length}reset(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}incomingOf(t){const e=t.name;if(e in this.cachedIn)return this.cachedIn[e];{let n=[];return this.cachedIn[e]=n,this.cachedOut[e]=[],this.nameTopicMapping[e]=t,n}}outgoingOf(t){const e=t.name;if(e in this.cachedOut)return this.cachedOut[e];{let n=[];return this.cachedIn[e]=[],this.cachedOut[e]=n,this.nameTopicMapping[e]=t,n}}callbacksOf(t){const e=t.name;if(e in this.callbacks)return this.callbacks[e];{let t=[];return this.callbacks[e]=t,t}}}class v{constructor(t,e){const{animationFrameHandler:n=window}=e||{};this.handle=0,this.detail={prevTime:-1,currentTime:-1,deltaTime:0},this.animationFrameHandler=n,this.callback=t,this.next=this.next.bind(this),this.start=this.start.bind(this),this.cancel=this.cancel.bind(this)}next(t=performance.now()){this.handle=this.animationFrameHandler.requestAnimationFrame(this.next);let e=this.detail;e.prevTime=e.currentTime,e.currentTime=t,e.deltaTime=e.currentTime-e.prevTime,this.callback(this)}start(){return this.handle=this.animationFrameHandler.requestAnimationFrame(this.next),this}cancel(){return this.animationFrameHandler.cancelAnimationFrame(this.handle),this}}function g(t,e){let n=w(t),s=e.name;if(s in n.contexts){let{value:i}=n.contexts[s];if(i)return i;throw x(t).name===e.name?new Error("Cannot useProvider() on self during initialization!"):new Error("This is not a provider.")}throw new Error(`Missing assigned dependent provider '${s}' in context.`)}function x(t){let e=k(t);if(!e)throw new Error("This is not a provider.");return e.current}const b=Symbol("providers");function w(t){return b in t?t[b]:t[b]={contexts:{},current:null}}function k(t){return b in t?t[b]:null}function O(t,e){const n=x(t);if(!n)throw new Error("Not a provider.");I(n,A(t).contexts).befores.push(e)}async function C(t,e){let n=function(t){if(M in t)return t[M];return null}(t);if(!n)return t;for(let t of e.slice().reverse()){let e=E(t,n.contexts);if(!e)throw new Error("Cannot revert context for non-existent provider.");let s=e.afters.slice();e.afters.length=0,await Promise.all(s.map((t=>t&&t())))}return t}const M=Symbol("effectors");function A(t){return M in t?t[M]:t[M]={contexts:{}}}function I(t,e){const n=t.name;return n in e?e[n]:e[n]={befores:[],afters:[]}}function E(t,e){const n=t.name;return n in e?e[n]:null}const N=new m("main.update");function T(t,e,n){O(t,(()=>(N.on(e,0,n),()=>{N.off(e,n)})))}function S(t){const e=new y;return T(t,e,(()=>{e.flush()})),e}function q(t){const e=g(t,S),n=new v((t=>{N.dispatchImmediately(e,t)}));return O(t,(()=>{n.start()})),n}var j=Object.freeze({__proto__:null,AnimationFrameLoopProvider:q,TopicsProvider:S,toast:function(t,e,n=[]){const s=[S,q,...n,function(t){const n=g(t,S);O(t,(async()=>(e.load&&await e.load(t),e.main&&await e.main(t),e.init&&e.init(t),async()=>{e.dead&&e.dead(t),e.unload&&await e.unload(t)}))),T(t,n,(()=>{e.update&&e.update(t),e.draw&&e.draw(t)}))}];return{async start(){return function(t,e){let n=w(t);for(let s of e){let e={handle:s,value:null};n.contexts[s.name]=e,n.current=s,e.value=s(t)}}(t,s),await async function(t,e){let n=A(t);for(let t of e){let e=I(t,n.contexts),s=e.befores.slice();e.befores.length=0;let i=await Promise.all(s.map((t=>t&&t())));e.afters.push(...i)}return t}(t,s),this},async stop(){return await C(t,s),function(t,e){let n=k(t);if(!n)return t;for(let t of e.slice().reverse())n.contexts[t.name].value=null,delete n.contexts[t.name]}(t,s),this}}},useDocumentEventListener:function(t,e,n){O(t,(()=>{const t=window.document;return t.addEventListener(e,n),()=>{t.removeEventListener(e,n)}}))},useEffect:O,useHTMLElementEventListener:function(t,e,n,s){O(t,(()=>(e.addEventListener(n,s),()=>{e.removeEventListener(n,s)})))},useProvider:g,useSystemUpdate:T,useTopic:function(t,e,n,s){const i=g(t,S);O(t,(()=>(e.on(i,n,s),()=>{e.off(i,s)})))},useWindowEventListener:function(t,e,n){O(t,(()=>{const t=window;return t.addEventListener(e,n),()=>{t.removeEventListener(e,n)}}))}});exports.AnimationFrameLoop=v,exports.Camera=n,exports.ComponentClass=class{constructor(t,e=(()=>null),n=(()=>{})){this.name=t,this.new=e,this.delete=n}},exports.EntityManager=class{constructor(){this.components={},this.nameClassMapping={},this.nextAvailableEntityId=1,this.queue=[],this.listeners=[],this.queries=new h}entityComponentChangedCallback(t,e,n,s){this.queries.onEntityComponentChanged(this,t,e,n,s);for(let i of this.listeners)i(this,t,e,n,s)}addEventListener(t,e){"change"===t&&this.listeners.push(e)}removeEventListener(t,e){if("change"===t){let t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}}flush(){for(;this.queue.length>0;){let[t,...e]=this.queue.shift();switch(t){case"attach":{let[t,n,s]=e;this.attachImmediately(t,n,s)}break;case"detach":{let[t,n]=e;this.detachImmediately(t,n)}break;case"clear":{let[t]=e;this.clearImmediately(t)}}}}create(){let t=this.nextAvailableEntityId++;return this.entityComponentChangedCallback(t,null,null,!1),t}destroy(t){const e=this.components;for(const n of Object.keys(e)){const s=e[n];t in s&&(delete s[t],this.entityComponentChangedCallback(t,null,this.nameClassMapping[n],!1))}this.entityComponentChangedCallback(t,null,null,!0)}exists(t,...e){if(e.length>0){for(const n of e){if(!(t in this.mapOf(n)))return!1}return!0}for(let e of Object.values(this.components))if(t in e)return!0;return!1}attach(t,e,n){return void 0===n&&(n=e.new()),this.queue.push(["attach",t,e,n]),n}attachImmediately(t,e,n){return void 0===n&&(n=e.new()),this.mapOf(e)[t]=n,this.entityComponentChangedCallback(t,e,null,!1),n}detach(t,e){this.queue.push(["detach",t,e])}detachImmediately(t,e){let n=this.mapOf(e),s=n[t];delete n[t],e.delete(s),this.entityComponentChangedCallback(t,null,e,!1)}clear(t){this.queue.push(["clear",t])}clearImmediately(t){const e=t.name,n=this.components,s=n[e];let i=Object.keys(s).map(Number),r=Object.values(s);n[e]={},this.nameClassMapping[e]=t;for(let e of r)t.delete(e);for(let e of i)this.entityComponentChangedCallback(e,null,t,!1)}get(t,e){return this.mapOf(e)[t]||null}count(t){return Object.keys(this.mapOf(t)).length}keysOf(t){return Object.keys(this.mapOf(t)).map(Number)}valuesOf(t){return Object.values(this.mapOf(t))}mapOf(t){const e=t.name,n=this.components;if(e in n)return n[e];{let s={};return n[e]=s,this.nameClassMapping[e]=t,s}}entityIds(){let t=new Set;for(let e of Object.values(this.components))for(let n of Object.keys(e))t.add(n);return t}componentClasses(){return Object.values(this.nameClassMapping)}reset(){const t=this.components;let e=new Set;for(const n of Object.keys(t)){const s=this.nameClassMapping[n],i=t[n];for(let t of Object.keys(i))e.add(Number(t));this.clearImmediately(s)}for(let t of e)this.entityComponentChangedCallback(t,null,null,!0);e.clear(),this.queries.reset(),this.components={},this.nextAvailableEntityId=1,this.queue.length=0,this.listeners.length=0}},exports.EntityTemplate=class{constructor(...t){this.componentClasses=t}create(t){let e=t.create(),n=[e];for(let s of this.componentClasses){let i=t.attach(e,s);n.push(i)}return n}destroy(t,e){for(let n of this.componentClasses)t.detach(e,n)}},exports.FirstPersonCameraController=class{constructor(e={locky:!1}){this.locky=e.locky,this.position=t.vec3.create(),this.forward=t.vec3.fromValues(0,0,-1),this.right=t.vec3.fromValues(1,0,0),this.up=t.vec3.fromValues(0,1,0),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.pitch=0,this.yaw=-90}look(t,e,n=1){return n*=1e3,this.pitch=Math.min(89.9,Math.max(-89.9,this.pitch+e*n)),this.yaw=(this.yaw+t*n)%360,this}move(t,e=0,n=0,s=1){return this.forwardAmount+=t*s,this.rightAmount+=e*s,this.upAmount+=n*s,this}apply(e){let{position:n,forward:s,right:r,up:o,forwardAmount:a,rightAmount:l,upAmount:c,pitch:h,yaw:u}=this,d=u*i,f=h*i,m=Math.cos(d),p=Math.cos(f),y=Math.sin(d),v=m*p,g=Math.sin(f),x=y*p;t.vec3.normalize(s,t.vec3.set(s,v,this.locky?0:g,x)),t.vec3.normalize(r,t.vec3.cross(r,s,o));let b=t.vec3.create();t.vec3.scale(b,s,a),t.vec3.add(n,n,b),t.vec3.scale(b,r,l),t.vec3.add(n,n,b),t.vec3.scale(b,o,c),t.vec3.add(n,n,b),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.locky&&t.vec3.set(s,v,g,x);let w=t.vec3.add(b,n,s);return t.mat4.lookAt(e,n,w,o),e}},exports.Not=u,exports.OrthographicCamera=class extends n{constructor(e,n,s,i,r=-1e3,o=1e3){super(t.mat4.create(),t.mat4.create()),this.orthoBounds={left:void 0===e?void 0:Number(e),top:void 0===n?void 0:Number(n),right:void 0===s?void 0:Number(s),bottom:void 0===i?void 0:Number(i)},this.clippingPlane={near:Number(r),far:Number(o)}}resize(e,n){const{near:s,far:i}=this.clippingPlane,{left:r,top:o,right:a,bottom:l}=this.orthoBounds;let c=this.projectionMatrix,h=void 0!==r;if(void 0!==e)if(h){const h=e/n;t.mat4.ortho(c,r*h,a*h,l,o,s,i)}else t.mat4.ortho(c,0,e,n,0,s,i);else h?t.mat4.ortho(c,r,a,l,o,s,i):t.mat4.ortho(c,-1,1,1,-1,-1,1);return this}},exports.PerspectiveCamera=class extends n{constructor(e=s,n=.1,i=1e3){super(t.mat4.create(),t.mat4.create()),this.fieldOfView=Number(e),this.clippingPlane={near:Number(n),far:Number(i)}}resize(e,n){const s=void 0===e?1:e/n,{near:i,far:r}=this.clippingPlane;return t.mat4.perspective(this.projectionMatrix,this.fieldOfView,s,i,r),this}},exports.Query=class{constructor(...t){if(t.length<=0)throw new Error("Must have at least 1 selector for query.");this.selectors=t,this.key=t.map((t=>d(t)?`!${t.name}`:t.name)).sort().join("&")}hasSelector(t){return d(t)?this.selectors.findIndex((e=>d(e)&&e.name===t.name))>=0:this.selectors.findIndex((e=>e.name===t.name))>=0}test(t,e){for(let n of this.selectors)if(d(n)){const s=n.value;if(t.exists(e,s))return!1}else{const s=n;if(!t.exists(e,s))return!1}return!0}hydrate(t,e){if(this.selectors.length<=0)return e.length=0,e;let n=t.entityIds();for(let s of n)this.test(t,s)&&e.push(s);return e}count(t){return t.queries.count(t,this)}findAny(t){const e=t.queries;let n=new Array(this.selectors.length+1),s=e.findAny(t,this);return null===s?n.fill(void 0):(f(n,t,s,this.selectors),n)}*findAll(t){const e=t.queries;let n=new Array(this.selectors.length+1),s=e.findAll(t,this);for(let e of s)f(n,t,e,this.selectors),yield n}},exports.QueryManager=h,exports.SceneGraph=class{constructor(){this.nodes={},this.roots=[],this._nextAvailableSceneNodeId=1}createSceneNode(t){let e=this._nextAvailableSceneNodeId++,n={parent:0,children:[]};return this.nodes[e]=n,o(t,e,this),e}createSceneNodes(t,e){let n=[];for(let s=0;s<t;++s)n.push(this.createSceneNode(e));return n}deleteSceneNode(t){if(!(t in this.nodes))throw new Error("Cannot delete non-existant scene node for scene graph.");a(this.nodes[t].parent,t,this),l(this,t,0,c)}deleteSceneNodes(t){for(let e of t)this.deleteSceneNode(e)}getSceneNodeInfo(t){return this.nodes[t]}parentSceneNode(t,e){a(this.nodes[t].parent,t,this),o(e,t,this)}replaceSceneNode(t,e){let n=this.nodes[t],s=n.parent,i=n.children.slice();if(a(s,t,this),n.children.length=0,e){let t=this.nodes[e];a(t.parent,e,this),t.children.push(...i),o(s,e,this)}else if(s){this.nodes[s].children.push(...i)}else this.roots.push(...i);for(let t of i)this.nodes[t].parent=s}walk(t,e={}){const{from:n,childFilter:s}=e;let i;i=n?Array.isArray(n)?n:[n]:this.roots,s&&(i=s(i,0,this));for(let e of i)l(this,e,0,t,s)}},exports.Toaster=j,exports.Topic=m,exports.TopicManager=y,exports.isSelectorNot=d,exports.lookAt=function(n,s,i,r=0,o=1){let a=t.vec3.create(),l=t.quat.create();t.mat4.getTranslation(a,n),t.mat4.getRotation(l,n);let c=t.vec3.fromValues(s,i,r);t.mat4.lookAt(n,a,c,e);let h=t.quat.create();t.mat4.getRotation(h,n),t.quat.slerp(l,l,h,o),t.mat4.fromRotationTranslation(n,l,a)},exports.panTo=function(e,n,s,i=0,r=1){let o=t.vec3.create();t.mat4.getTranslation(o,e);let a=t.vec3.fromValues((n-o[0])*r,(s-o[1])*r,(i-o[2])*r);t.mat4.translate(e,e,a)},exports.screenToWorldRay=function(e,n,s,i,r,o=!1){let a=t.vec4.fromValues(n,s,-1,1),l=t.mat4.create();return t.mat4.invert(l,i),t.vec4.transformMat4(a,a,l),a[2]=-1,a[3]=0,t.mat4.invert(l,r),t.vec4.transformMat4(a,a,l),e[0]=a[0],e[1]=a[1],e[2]=a[2],o&&t.vec3.normalize(e,e),e};
//# sourceMappingURL=milque-scene.cjs.js.map
