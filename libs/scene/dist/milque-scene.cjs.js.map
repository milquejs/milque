{"version":3,"file":"milque-scene.cjs.js","sources":["../src/camera/CameraHelper.js","../src/camera/Camera.js","../src/camera/PerspectiveCamera.js","../src/camera/FirstPersonCameraController.js","../src/scenegraph/SceneGraph.js","../src/entity/QueryManager.js","../src/entity/Query.js","../src/topic/Topic.js","../src/topic/TopicManager.js","../src/loop/AnimationFrameLoop.js","../src/toaster/ProviderHook.js","../src/toaster/EffectHook.js","../src/toaster/SystemUpdateHook.js","../src/toaster/TopicHook.js","../src/toaster/Toaster.js","../src/toaster/EventListenerHook.js","../src/entity/ComponentClass.js","../src/entity/EntityManager.js","../src/entity/EntityTemplate.js","../src/camera/OrthographicCamera.js"],"sourcesContent":["import { mat4, quat, vec3, vec4 } from 'gl-matrix';\n\nconst UP = vec3.fromValues(0, 1, 0);\n\nexport function panTo(viewMatrix, x, y, z = 0, dt = 1) {\n  let position = vec3.create();\n  mat4.getTranslation(position, viewMatrix);\n  let translation = vec3.fromValues(\n    (x - position[0]) * dt,\n    (y - position[1]) * dt,\n    (z - position[2]) * dt\n  );\n  mat4.translate(viewMatrix, viewMatrix, translation);\n}\n\nexport function lookAt(viewMatrix, x, y, z = 0, dt = 1) {\n  let position = vec3.create();\n  let rotation = quat.create();\n  mat4.getTranslation(position, viewMatrix);\n  mat4.getRotation(rotation, viewMatrix);\n  let target = vec3.fromValues(x, y, z);\n\n  mat4.lookAt(viewMatrix, position, target, UP);\n\n  let targetRotation = quat.create();\n  mat4.getRotation(targetRotation, viewMatrix);\n  quat.slerp(rotation, rotation, targetRotation, dt);\n\n  mat4.fromRotationTranslation(viewMatrix, rotation, position);\n}\n\n/**\n * Gets a directional ray in the world space from the given normalized\n * screen coordinates and camera matrices.\n *\n * NOTE: In addition to some scaling, the y component from a pointer's\n * position usually has to be flipped to match the normalized screen\n * coordinate space, which assumes a range of [-1, 1] for both x and y,\n * where (0, 0) is the center and (-1, -1) is the bottom-left of the\n * screen.\n *\n * ### Typical Device Screen Coordinate Space:\n * ```\n * (0,0)------------(w,0)\n *    |               |\n *    |   (w/2,h/2)   |\n *    |               |\n * (0,w)------------(w,h)\n * ```\n *\n * ### Normalized Screen Coordinate Space:\n * ```\n * (-1,+1)---------(+1,+1)\n *    |               |\n *    |     (0,0)     |\n *    |               |\n * (-1,-1)---------(+1,-1)\n * ```\n *\n * ### Example Conversion from Device to Normalized:\n * ```\n * let normalizedScreenX = (canvasClientX / canvasWidth) * 2 - 1;\n * let normalizedScreenY = 1 - (canvasClientY / canvasHeight) * 2;\n * ```\n *\n * @param {vec3} out The output vector.\n * @param {number} normalizedScreenCoordX The X screen coordinate normalized to [-1, 1], where -1 is the left side of the screen.\n * @param {number} normalizedScreenCoordY The Y screen coordinate normalized to [-1, 1], where -1 is the bottom side of the screen.\n * @param {mat4} projectionMatrix The projection matrix of the world camera.\n * @param {mat4} viewMatrix The view matrix of the world camera.\n * @param {boolean} [normalized=false] Whether to normalize the result. Usually true for non-orthogonal projections.\n * @returns {vec3} The ray direction in the world space. By default, this is not normalized.\n */\nexport function screenToWorldRay(\n  out,\n  normalizedScreenCoordX,\n  normalizedScreenCoordY,\n  projectionMatrix,\n  viewMatrix,\n  normalized = false\n) {\n  // https://antongerdelan.net/opengl/raycasting.html\n  // To homogeneous clip coords\n  let v = vec4.fromValues(\n    normalizedScreenCoordX,\n    normalizedScreenCoordY,\n    -1,\n    1\n  );\n  // To camera coords\n  let m = mat4.create();\n  mat4.invert(m, projectionMatrix);\n  vec4.transformMat4(v, v, m);\n  v[2] = -1;\n  v[3] = 0;\n  // To world coords\n  mat4.invert(m, viewMatrix);\n  vec4.transformMat4(v, v, m);\n  out[0] = v[0];\n  out[1] = v[1];\n  out[2] = v[2];\n  // Normalized as directional ray\n  if (normalized) {\n    vec3.normalize(out, out);\n  }\n  return out;\n}\n","export class Camera {\n  constructor(projectionMatrix, viewMatrix) {\n    this.projectionMatrix = projectionMatrix;\n    this.viewMatrix = viewMatrix;\n  }\n\n  /**\n   * @abstract\n   * @param {number} [viewportWidth]\n   * @param {number} [viewportHeight]\n   * @returns {Camera}\n   */\n  // eslint-disable-next-line no-unused-vars\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    return this;\n  }\n}\n","import { mat4 } from 'gl-matrix';\nimport { Camera } from './Camera.js';\n\nconst DEFAULT_FOVY = Math.PI / 3;\n\nexport class PerspectiveCamera extends Camera {\n  constructor(fieldOfView = DEFAULT_FOVY, near = 0.1, far = 1000) {\n    super(mat4.create(), mat4.create());\n\n    this.fieldOfView = Number(fieldOfView);\n    this.clippingPlane = {\n      near: Number(near),\n      far: Number(far),\n    };\n  }\n\n  /** @override */\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    const aspectRatio =\n      typeof viewportWidth === 'undefined' ? 1 : viewportWidth / viewportHeight;\n    const { near, far } = this.clippingPlane;\n    mat4.perspective(\n      this.projectionMatrix,\n      this.fieldOfView,\n      aspectRatio,\n      near,\n      far\n    );\n    return this;\n  }\n}\n","import { vec3, mat4 } from 'gl-matrix';\n\nconst TO_RAD_FACTOR = Math.PI / 180;\n\n/**\n * A camera controller that behaves like a traditional first person camera.\n * Pitch is restricted to prevent gimbal lock and roll is ignored.\n *\n * NOTE: Don't forget to lock your pointer, i.e. `canvas.requestPointerLock()`.\n */\nexport class FirstPersonCameraController {\n  constructor(opts = { locky: false }) {\n    this.locky = opts.locky;\n\n    this.position = vec3.create();\n    this.forward = vec3.fromValues(0, 0, -1);\n    this.right = vec3.fromValues(1, 0, 0);\n    this.up = vec3.fromValues(0, 1, 0);\n\n    this.forwardAmount = 0;\n    this.rightAmount = 0;\n    this.upAmount = 0;\n\n    this.pitch = 0;\n    this.yaw = -90;\n  }\n\n  look(dx, dy, dt = 1) {\n    // NOTE: Increase sensitivity to relatively match movement.\n    dt *= 1000;\n    this.pitch = Math.min(89.9, Math.max(-89.9, this.pitch + dy * dt));\n    this.yaw = (this.yaw + dx * dt) % 360;\n    return this;\n  }\n\n  move(forward, right = 0, up = 0, dt = 1) {\n    this.forwardAmount += forward * dt;\n    this.rightAmount += right * dt;\n    this.upAmount += up * dt;\n    return this;\n  }\n\n  apply(viewMatrix) {\n    let {\n      position,\n      forward,\n      right,\n      up,\n      forwardAmount,\n      rightAmount,\n      upAmount,\n      pitch,\n      yaw,\n    } = this;\n\n    // Calculate forward and right vectors\n    let rady = yaw * TO_RAD_FACTOR;\n    let radp = pitch * TO_RAD_FACTOR;\n    let cosy = Math.cos(rady);\n    let cosp = Math.cos(radp);\n    let siny = Math.sin(rady);\n    let sinp = Math.sin(radp);\n    let dx = cosy * cosp;\n    let dy = sinp;\n    let dz = siny * cosp;\n\n    // Set forward for move vector\n    vec3.normalize(forward, vec3.set(forward, dx, this.locky ? 0 : dy, dz));\n    vec3.normalize(right, vec3.cross(right, forward, up));\n\n    let move = vec3.create();\n    // Move forward\n    vec3.scale(move, forward, forwardAmount);\n    vec3.add(position, position, move);\n    // Move right\n    vec3.scale(move, right, rightAmount);\n    vec3.add(position, position, move);\n    // Move up\n    vec3.scale(move, up, upAmount);\n    vec3.add(position, position, move);\n    // Reset movement\n    this.forwardAmount = 0;\n    this.rightAmount = 0;\n    this.upAmount = 0;\n\n    // Reset forward for look vector\n    if (this.locky) vec3.set(forward, dx, dy, dz);\n\n    let target = vec3.add(move, position, forward);\n    mat4.lookAt(viewMatrix, position, target, up);\n    return viewMatrix;\n  }\n}\n","const MAX_DEPTH_LEVEL = 100;\n\n/**\n * @typedef {Number} SceneNode\n *\n * @typedef SceneNodeInfo\n * @property {SceneNode} parent The parent node. If the node does not have a parent,\n * it will be 0.\n * @property {Array<SceneNode>} children The list of child nodes.\n *\n * @callback WalkCallback Called for each node, before traversing its children.\n * @param {SceneNode} sceneNode The current scene node.\n * @param {SceneGraph} sceneGraph The current scene graph.\n * @returns {WalkBackCallback|Boolean} If false, the walk will skip\n * the current node's children and all of its descendents. If a function,\n * it will be called after traversing down all of its children.\n *\n * @callback WalkBackCallback Called if returned by {@link WalkCallback}, after\n * traversing the current node's children.\n * @param {SceneNode} sceneNode The current scene node.\n * @param {SceneGraph} sceneGraph The current scene graph.\n *\n * @callback WalkChildrenCallback Called for each level of children, before\n * traversing them. This is usually used to determine visit order.\n * @param {Array<SceneNode>} childNodes A list of child nodes to be visited.\n * @param {SceneNode} parentNode The current parent node of these children.\n * @param {SceneGraph} sceneGraph The current scene graph.\n * @returns {Array<SceneNode>} The list of children to traverse for this parent.\n */\n\n/**\n * A tree-like graph of nodes with n-children.\n */\nexport class SceneGraph {\n  /**\n   * Constructs an empty scene graph.\n   */\n  constructor() {\n    this.nodes = {};\n    this.roots = [];\n\n    this._nextAvailableSceneNodeId = 1;\n  }\n\n  /**\n   * Creates a scene node in the scene graph.\n   *\n   * @param {SceneNode} [parentNode] The parent node for the created scene\n   * node.\n   * @returns {SceneNode} The created scene node.\n   */\n  createSceneNode(parentNode = undefined) {\n    let sceneNode = this._nextAvailableSceneNodeId++;\n    let info = createSceneNodeInfo();\n    this.nodes[sceneNode] = info;\n    attach(parentNode, sceneNode, this);\n    return sceneNode;\n  }\n\n  /**\n   * Creates multiple scene nodes in the scene graph.\n   *\n   * @param {Number} count The number of scene nodes to create.\n   * @param {SceneNode} [parentNode] The parent node for the created scene\n   * nodes.\n   * @returns {Array<SceneNode>} A list of created scene nodes.\n   */\n  createSceneNodes(count, parentNode = undefined) {\n    let result = [];\n    for (let i = 0; i < count; ++i) {\n      result.push(this.createSceneNode(parentNode));\n    }\n    return result;\n  }\n\n  /**\n   * Deletes a scene node from the scene graph, along with all\n   * of its descendents.\n   *\n   * @param {SceneNode} sceneNode The scene node to remove.\n   */\n  deleteSceneNode(sceneNode) {\n    if (sceneNode in this.nodes) {\n      let info = this.nodes[sceneNode];\n      detach(info.parent, sceneNode, this);\n      walkImpl(this, sceneNode, 0, walkDeleteCallback);\n    } else {\n      throw new Error('Cannot delete non-existant scene node for scene graph.');\n    }\n  }\n\n  /**\n   * Deletes all given scene nodes from the scene graph, along with all\n   * of their descendents.\n   *\n   * @param {Array<SceneNode>} sceneNodes A list of scene nodes to remove.\n   */\n  deleteSceneNodes(sceneNodes) {\n    for (let sceneNode of sceneNodes) {\n      this.deleteSceneNode(sceneNode);\n    }\n  }\n\n  /**\n   * Get the scene node's info.\n   *\n   * @param {SceneNode} sceneNode The scene node to get info for.\n   * @returns {SceneNodeInfo} The info for the given scene node.\n   */\n  getSceneNodeInfo(sceneNode) {\n    return this.nodes[sceneNode];\n  }\n\n  /**\n   * Changes the parent of the scene node with the new parent node in\n   * the graph.\n   *\n   * @param {SceneNode} sceneNode The target scene node to change.\n   * @param {SceneNode} parentNode The scene node to set as the parent.\n   */\n  parentSceneNode(sceneNode, parentNode) {\n    let info = this.nodes[sceneNode];\n    detach(info.parent, sceneNode, this);\n    attach(parentNode, sceneNode, this);\n  }\n\n  /**\n   * Replaces the scene node with the new replacement node in the graph,\n   * inheriting its parent and children.\n   *\n   * @param {SceneNode} sceneNode The target scene node to replace.\n   * @param {SceneNode} replacementNode The scene node to replace with. If falsey,\n   * it will remove the target scene node and the target's parent will adopt\n   * its grandchildren. If the target did not have parents, the grandchildren will\n   * become root nodes in the graph.\n   */\n  replaceSceneNode(sceneNode, replacementNode) {\n    let info = this.nodes[sceneNode];\n    let parentNode = info.parent;\n    let grandChildren = info.children.slice();\n\n    // Remove the target node from graph\n    detach(parentNode, sceneNode, this);\n\n    // Begin grafting the grandchildren by removing them...\n    info.children.length = 0;\n\n    if (replacementNode) {\n      // Reattach all grandchildren to new replacement node.\n      let replacementInfo = this.nodes[replacementNode];\n      let replacementParent = replacementInfo.parent;\n\n      // Remove replacement node from previous parent\n      detach(replacementParent, replacementNode, this);\n\n      // ...and graft them back.\n      replacementInfo.children.push(...grandChildren);\n\n      // And reattach target parent to new child.\n      attach(parentNode, replacementNode, this);\n    } else {\n      // Reattach all grandchildren to target parent...\n      if (parentNode) {\n        //...as regular children.\n        let parentInfo = this.nodes[parentNode];\n        parentInfo.children.push(...grandChildren);\n      } else {\n        //...as root children.\n        this.roots.push(...grandChildren);\n      }\n    }\n\n    // ...and repair their parent relations.\n    for (let childNode of grandChildren) {\n      this.nodes[childNode].parent = parentNode;\n    }\n  }\n\n  /**\n   * Walks through every child node in the graph.\n   *\n   * @param {WalkCallback} callback The function called for each node\n   * in the graph, in ordered traversal from parent to child.\n   * @param {Object} [opts={}] Any additional options.\n   * @param {SceneNode|Array<SceneNode>} [opts.from] The parent node to\n   * start walking from, inclusive. By default, it will start from the root\n   * nodes.\n   * @param {WalkChildrenCallback} [opts.childfilter] The function called before\n   * walking through the children. This is usually used to determine the\n   * visiting order.\n   */\n  walk(callback, opts = {}) {\n    const { from = undefined, childFilter = undefined } = opts;\n\n    let fromNodes;\n    if (!from) fromNodes = this.roots;\n    else if (!Array.isArray(from)) fromNodes = [from];\n    else fromNodes = from;\n\n    if (childFilter) fromNodes = childFilter(fromNodes, 0, this);\n    for (let fromNode of fromNodes) {\n      walkImpl(this, fromNode, 0, callback, childFilter);\n    }\n  }\n}\n\n/**\n * @param {SceneNode} key The scene node handle.\n * @returns {SceneNodeInfo} The scene node metadata.\n */\nfunction createSceneNodeInfo() {\n  return {\n    parent: 0,\n    children: [],\n  };\n}\n\n/**\n * Attaches a child node to a parent in the scene graph. If parentNode is\n * null, then it will attach as a root node.\n *\n * @param {SceneNode} parentNode The parent node to attach to. Can be null.\n * @param {SceneNode} childNode The child node to attach from.\n * @param {SceneGraph} sceneGraph The scene graph to attach in.\n */\nfunction attach(parentNode, childNode, sceneGraph) {\n  if (parentNode) {\n    // Has new parent; attach to parent. It is now in the graph.\n    sceneGraph.nodes[parentNode].children.push(childNode);\n    sceneGraph.nodes[childNode].parent = parentNode;\n  } else {\n    // No parent; move to root. It is now in the graph.\n    sceneGraph.roots.push(childNode);\n    sceneGraph.nodes[childNode].parent = 0;\n  }\n}\n\n/**\n * Detaches a child node from its parent in the scene graph. If parentNode is\n * null, then it will detach as a root node.\n *\n * @param {SceneNode} parentNode The parent node to attach to. Can be null.\n * @param {SceneNode} childNode The child node to attach from.\n * @param {SceneGraph} sceneGraph The scene graph to attach in.\n */\nfunction detach(parentNode, childNode, sceneGraph) {\n  if (parentNode) {\n    // Has parent; detach from parent. It is now a free node.\n    let children = sceneGraph.nodes[parentNode].children;\n    let childIndex = children.indexOf(childNode);\n    children.splice(childIndex, 1);\n    sceneGraph.nodes[childNode].parentNode = 0;\n  } else {\n    // No parent; remove from root. It is now a free node.\n    let roots = sceneGraph.roots;\n    let rootIndex = roots.indexOf(childNode);\n    roots.splice(rootIndex, 1);\n    sceneGraph.nodes[childNode].parentNode = 0;\n  }\n}\n\n/**\n * Walk down from the parent and through all its descendents.\n *\n * @param {SceneGraph} sceneGraph The scene graph containing the nodes to be visited.\n * @param {SceneNode} parentNode The parent node to start walking from.\n * @param {Number} level The current call depth level. This is used to limit the call stack.\n * @param {WalkCallback} nodeCallback The function called on each visited node.\n * @param {WalkChildrenCallback} [filterCallback] The function called before\n * walking through the children. This is usually used to determine the visiting order.\n */\nfunction walkImpl(\n  sceneGraph,\n  parentNode,\n  level,\n  nodeCallback,\n  filterCallback = undefined\n) {\n  if (level >= MAX_DEPTH_LEVEL) return;\n\n  let result = nodeCallback(parentNode, sceneGraph);\n  if (result === false) return;\n\n  let parentInfo = sceneGraph.nodes[parentNode];\n  let nextNodes = filterCallback\n    ? filterCallback(parentInfo.children, parentNode, sceneGraph)\n    : parentInfo.children;\n\n  for (let childNode of nextNodes) {\n    walkImpl(sceneGraph, childNode, level + 1, nodeCallback, filterCallback);\n  }\n\n  if (typeof result === 'function') {\n    result(parentNode, sceneGraph);\n  }\n}\n\nfunction walkDeleteCallback(sceneNode, sceneGraph) {\n  delete sceneGraph.nodes[sceneNode];\n}\n","import { ComponentClass } from './ComponentClass';\n\n/** @typedef {import('./EntityManager').EntityManager} EntityManager */\n/** @typedef {import('./EntityManager').EntityId} EntityId */\n\n/**\n * @template T\n * @typedef {import('./Query').Query<T>} Query<T>\n */\n\nexport class QueryManager {\n\n    constructor() {\n        /**\n         * @protected\n         * @type {Record<string, Array<EntityId>>}\n         */\n        this.cachedResults = {};\n        /**\n         * @private\n         * @type {Record<string, Query<?>>}\n         */\n        this.keyQueryMapping = {};\n\n        this.onEntityComponentChanged = this.onEntityComponentChanged.bind(this);\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @param {EntityId} entityId\n     * @param {ComponentClass<?>} added\n     * @param {ComponentClass<?>} removed\n     * @param {boolean} dead\n     */\n    onEntityComponentChanged(entityManager, entityId, added, removed, dead) {\n        for(let query of Object.values(this.keyQueryMapping)) {\n            let entities = this.cachedResults[query.key];\n            if (dead) {\n                let i = entities.indexOf(entityId);\n                if (i >= 0) {\n                    entities.splice(i, 1);\n                }\n            } else if (added) {\n                if (query.hasSelector(Not(added))) {\n                    let i = entities.indexOf(entityId);\n                    if (i >= 0) {\n                        entities.splice(i, 1);\n                    }\n                } else if (query.hasSelector(added) && query.test(entityManager, entityId)) {\n                    let i = entities.indexOf(entityId);\n                    if (i < 0) {\n                        entities.push(entityId);\n                    }\n                }\n            } else if (removed) {\n                if (query.hasSelector(Not(removed)) && query.test(entityManager, entityId)) {\n                    let i = entities.indexOf(entityId);\n                    if (i < 0) {\n                        entities.push(entityId);\n                    }\n                } else if (query.hasSelector(removed) && query.test(entityManager, entityId)) {\n                    let i = entities.indexOf(entityId);\n                    if (i >= 0) {\n                        entities.splice(i, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @param {Query<?>} query \n     * @returns {EntityId}\n     */\n    findAny(entityManager, query) {\n        let result = this.findAll(entityManager, query);\n        if (result.length <= 0) {\n            return null;\n        } else {\n            return result[Math.floor(Math.random() * result.length)];\n        }\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @param {Query<?>} query\n     * @returns {Array<EntityId>}\n     */\n    findAll(entityManager, query) {\n        const queryKey = query.key;\n        let result;\n        if (!(queryKey in this.keyQueryMapping)) {\n            result = [];\n            this.keyQueryMapping[queryKey] = query;\n            this.cachedResults[queryKey] = result;\n            query.hydrate(entityManager, result);\n        } else {\n            result = this.cachedResults[queryKey];\n        }\n        return result;\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @param {Query<?>} query \n     */\n    count(entityManager, query) {\n        let result = this.findAll(entityManager, query);\n        return result.length;\n    }\n\n    /**\n     * @param {Query<?>} query\n     */\n    clear(query) {\n        const queryKey = query.key;\n        if (!(queryKey in this.keyQueryMapping)) {\n            return;\n        }\n        delete this.keyQueryMapping[queryKey];\n        delete this.cachedResults[queryKey];\n    }\n    \n    reset() {\n        this.keyQueryMapping = {};\n        this.cachedResults = {};\n    }\n}\n\n/**\n * @template T\n * @typedef {SelectorNot<T>|ComponentClass<T>} Selector<T>\n */\n\n/**\n * @template T\n * @typedef SelectorNot<T>\n * @property {'not'} type\n * @property {string} name\n * @property {ComponentClass<T>} value\n */\n\n/**\n * @template T\n * @param {ComponentClass<T>} componentClass \n * @returns {ComponentClass<T>}\n */\nexport function Not(componentClass) {\n    return {\n        // @ts-ignore\n        type: 'not',\n        name: componentClass.name,\n        value: componentClass,\n    };\n}\n\nexport function isSelectorNot(selector) {\n    return 'type' in selector && selector.type === 'not';\n}\n","import { ComponentClass } from './ComponentClass';\nimport { EntityManager } from './EntityManager';\nimport { isSelectorNot } from './QueryManager';\n\n/** @typedef {import('./EntityManager').EntityId} EntityId */\n\n/**\n * @template T\n * @typedef {import('./QueryManager').Selector<T>} Selector<T>\n */\n\n/**\n * @template T\n * @typedef {import('./QueryManager').SelectorNot<T>} SelectorNot<T>\n */\n\n/**\n * @template T\n * @typedef {import('./EntityTemplate').ComponentInstancesOf<T>} ComponentInstancesOf<T>\n */\n\n/**\n * @template {ComponentClass<any>[]} T\n */\nexport class Query {\n\n    /**\n     * @param {T} selectors \n     */\n    constructor(...selectors) {\n        if (selectors.length <= 0) {\n            throw new Error('Must have at least 1 selector for query.');\n        }\n        this.selectors = selectors;\n        this.key = selectors.map(s => isSelectorNot(s) ? `!${s.name}` : s.name).sort().join('&');\n    }\n\n    /**\n     * @param {Selector<?>} selector\n     */\n    hasSelector(selector) {\n        if (isSelectorNot(selector)) {\n            return this.selectors.findIndex(v => isSelectorNot(v) && v.name === selector.name) >= 0;\n        } else {\n            return this.selectors.findIndex(v => v.name === selector.name) >= 0;\n        }\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @param {EntityId} entityId\n     */\n    test(entityManager, entityId) {\n        for(let selector of this.selectors) {\n            if (isSelectorNot(selector)) {\n                const componentClass = /** @type {SelectorNot<?>} */ (/** @type {unknown} */ (selector)).value;\n                if (entityManager.exists(entityId, componentClass)) {\n                    return false;\n                }\n            } else {\n                const componentClass = /** @type {ComponentClass<?>} */ (/** @type {unknown} */ (selector));\n                if (!entityManager.exists(entityId, componentClass)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @param {Array<EntityId>} result \n     */\n    hydrate(entityManager, result) {\n        if (this.selectors.length <= 0) {\n            result.length = 0;\n            return result;\n        }\n        let entities = entityManager.entityIds();\n        for(let entityId of entities) {\n            if (this.test(entityManager, entityId)) {\n                result.push(entityId);\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param {EntityManager} entityManager \n     * @returns {number}\n     */\n    count(entityManager) {\n        return entityManager.queries.count(entityManager, this);\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n     */\n    findAny(entityManager) {\n        const queryManager = entityManager.queries;\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (new Array(this.selectors.length + 1));\n        let entityId = queryManager.findAny(entityManager, this);\n        if (entityId === null) {\n            return result.fill(undefined);\n        }\n        computeResult(result, entityManager, entityId, this.selectors);\n        return result;\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @returns {Generator<[EntityId, ...ComponentInstancesOf<T>]>}\n     */\n    *findAll(entityManager) {\n        const queryManager = entityManager.queries;\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (new Array(this.selectors.length + 1));\n        let entities = queryManager.findAll(entityManager, this);\n        for(let entityId of entities) {\n            computeResult(result, entityManager, entityId, this.selectors);\n            yield result;\n        }\n    }\n}\n\n/**\n * @template {ComponentClass<any>[]} T\n * @param {[EntityId, ...ComponentInstancesOf<T>]} out\n * @param {EntityManager} entityManager  \n * @param {EntityId} entityId\n * @param {T} selectors\n * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n */\nfunction computeResult(out, entityManager, entityId, selectors) {\n    out[0] = entityId;\n    let i = 1;\n    for(let selector of selectors) {\n        if (isSelectorNot(selector)) {\n            out[i] = null;\n        } else {\n            out[i] = entityManager.get(entityId, selector);\n        }\n        ++i;\n    }\n    return out;\n}\n","/** @typedef {import('./TopicManager').TopicManager} TopicManager */\n\n/**\n * @template T\n * @typedef {import('./TopicManager').TopicCallback<T>} TopicCallback<T>\n */\n\n/**\n * @template T\n */\nexport class Topic {\n\n    /**\n     * @param {string} name \n     */\n    constructor(name) {\n        this.name = name;\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {T} attachment\n     */\n    dispatch(topicManager, attachment) {\n        topicManager.dispatch(this, attachment);\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {T} attachment\n     */\n    dispatchImmediately(topicManager, attachment) {\n        topicManager.dispatchImmediately(this, attachment);\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {T} attachment\n     */\n    async dispatchImmediatelyAndWait(topicManager, attachment) {\n        await topicManager.dispatchImmediatelyAndWait(this, attachment);\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {number} priority\n     * @param {TopicCallback<T>} callback\n     */\n    on(topicManager, priority, callback) {\n        topicManager.addEventListener(this, callback, { priority });\n        return this;\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {TopicCallback<T>} callback\n     */\n    off(topicManager, callback) {\n        topicManager.removeEventListener(this, callback);\n        return this;\n    }\n\n    /**\n     * @param {TopicManager} topicManager\n     * @param {number} priority\n     * @param {TopicCallback<T>} callback\n     */\n    once(topicManager, priority, callback) {\n        let wrapper = (attachment) => {\n            this.off(topicManager, wrapper);\n            return callback(attachment);\n        };\n        return this.on(topicManager, priority, wrapper);\n    }\n\n    /**\n     * @param {TopicManager} topicManager \n     * @param {number} amount \n     */\n    *poll(topicManager, amount) {\n        amount = Math.min(amount, topicManager.count(this));\n        for(let i = 0; i < amount; ++i) {\n            yield topicManager.poll(this);\n        }\n    }\n\n    /**\n     * @param {TopicManager} topicManager \n     * @param {number} amount \n     */\n    retain(topicManager, amount) {\n        topicManager.retain(this, amount);\n    }\n\n    /**\n     * @param {TopicManager} topicManager \n     * @param {number} amount \n     */\n    *pollAndRetain(topicManager, amount) {\n        this.retain(topicManager, amount);\n        for(let result of this.poll(topicManager, amount)) {\n            yield result;\n        }\n    }\n}\n","/**\n * @template T\n * @typedef {import('./Topic').Topic<T>} Topic<T>\n */\n\n/**\n * @template T\n * @typedef {(attachment: T) => void|boolean} TopicCallback<T>\n */\n\n/**\n * @template T\n * @typedef TopicCallbackEntry\n * @property {TopicCallback<T>} callback\n * @property {number} priority\n */\n\n/**\n * @template T\n * @param {TopicCallbackEntry<T>} a\n * @param {TopicCallbackEntry<T>} b\n */\nfunction comparator(a, b) {\n    return a.priority - b.priority;\n}\n\n/**\n * A manager for topic states. You should call `flush()` regularly to\n * process dispatched events or use `dispatchImmediately()`.\n */\nexport class TopicManager {\n\n    constructor() {\n        /**\n         * @protected\n         * @type {Record<string, Array<object>>}\n         */\n        this.cachedIn = {};\n        /**\n         * @protected\n         * @type {Record<string, Array<object>>}\n         */\n        this.cachedOut = {};\n        /**\n         * @protected\n         * @type {Record<string, Array<TopicCallbackEntry<?>>>}\n         */\n        this.callbacks = {};\n        /**\n         * @protected\n         * @type {Record<string, number>}\n         */\n        this.maxRetains = {};\n        /**\n         * @private\n         * @type {Record<string, Topic<?>>}\n         */\n        this.nameTopicMapping = {};\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     * @param {TopicCallback<T>} callback \n     * @param {object} [opts]\n     * @param {number} [opts.priority]\n     */\n    addEventListener(topic, callback, opts = undefined) {\n        const { priority = 0 } = opts;\n        let callbacks = this.callbacksOf(topic);\n        callbacks.push({\n            callback,\n            priority,\n        });\n        callbacks.sort(comparator);\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     * @param {TopicCallback<T>} callback \n     */\n    removeEventListener(topic, callback) {\n        let callbacks = this.callbacksOf(topic);\n        let i = callbacks.findIndex(v => v.callback === callback);\n        if (i >= 0) {\n            callbacks.splice(i, 1);\n        }\n    }\n\n    /**\n     * @param {Topic<?>} topic\n     */\n    countEventListeners(topic) {\n        return this.callbacksOf(topic).length;\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     * @param {T} attachment \n     */\n    dispatch(topic, attachment) {\n        let incoming = this.incomingOf(topic);\n        incoming.push(attachment);\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     * @param {T} attachment\n     */\n    dispatchImmediately(topic, attachment) {\n        let callbacks = this.callbacksOf(topic);\n        for(let { callback } of callbacks) {\n            let result = callback(attachment);\n            if (result === true) {\n                return;\n            }\n        }\n        let outgoing = this.outgoingOf(topic);\n        outgoing.push(attachment);\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     * @param {T} attachment \n     */\n    async dispatchImmediatelyAndWait(topic, attachment) {\n        let callbacks = this.callbacksOf(topic);\n        for(let { callback } of callbacks) {\n            let result = await callback(attachment);\n            if (result === true) {\n                return;\n            }\n        }\n        let outgoing = this.outgoingOf(topic);\n        outgoing.push(attachment);\n    }\n\n    /**\n     * @param {Topic<?>} topic\n     */\n    count(topic) {\n        let outgoing = this.outgoingOf(topic);\n        return outgoing.length;\n    }\n\n    /**\n     * @template T\n     * @param {Topic<T>} topic \n     */\n    poll(topic) {\n        let outgoing = this.outgoingOf(topic);\n        if (outgoing.length <= 0) {\n            return null;\n        }\n        let result = outgoing.shift();\n        return result;\n    }\n\n    /**\n     * @param {Topic<?>} topic\n     * @param {number} amount\n     */\n    retain(topic, amount) {\n        const topicName = topic.name;\n        let max = Math.max(amount, this.maxRetains[topicName] || 0);\n        this.maxRetains[topicName] = max;\n    }\n\n    /**\n     * @param {number} [maxPerTopic]\n     */\n    flush(maxPerTopic = 100) {\n        for(const topicName of Object.keys(this.cachedIn)) {\n            const topic = this.nameTopicMapping[topicName];\n            const incoming = this.cachedIn[topicName];\n            const outgoing = this.cachedOut[topicName];\n            const retain = this.maxRetains[topicName] || 0;\n            if (retain < outgoing.length) {\n                outgoing.splice(0, outgoing.length - retain);\n            }\n            let max = Math.min(maxPerTopic, incoming.length);\n            for(let i = 0; i < max; ++i) {\n                let attachment = incoming.shift();\n                if (typeof attachment === 'object' && attachment instanceof Promise) {\n                    this.dispatchImmediately(topic, attachment);\n                } else {\n                    this.dispatchImmediately(topic, attachment);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {Topic<?>} topic \n     */\n    getPendingRetainCount(topic) {\n        return this.maxRetains[topic.name] || 0;\n    }\n\n    /**\n     * @param {Topic<?>} topic\n     */\n    getPendingFlushCount(topic) {\n        let incoming = this.incomingOf(topic);\n        return incoming.length;\n    }\n\n    reset() {\n        this.cachedIn = {};\n        this.cachedOut = {};\n        this.callbacks = {};\n        this.maxRetains = {};\n        this.nameTopicMapping = {};\n    }\n\n    /**\n     * @protected\n     * @template T\n     * @param {Topic<T>} topic \n     * @returns {Array<T>}\n     */\n    incomingOf(topic) {\n        const topicName = topic.name;\n        if (topicName in this.cachedIn) {\n            return this.cachedIn[topicName];\n        } else {\n            let result = [];\n            this.cachedIn[topicName] = result;\n            this.cachedOut[topicName] = [];\n            this.nameTopicMapping[topicName] = topic;\n            return result;\n        }\n    }\n\n    /**\n     * @protected\n     * @template T\n     * @param {Topic<T>} topic \n     * @returns {Array<T>}\n     */\n    outgoingOf(topic) {\n        const topicName = topic.name;\n        if (topicName in this.cachedOut) {\n            return this.cachedOut[topicName];\n        } else {\n            let result = [];\n            this.cachedIn[topicName] = [];\n            this.cachedOut[topicName] = result;\n            this.nameTopicMapping[topicName] = topic;\n            return result;\n        }\n    }\n\n    /**\n     * @protected\n     * @template T\n     * @param {Topic<T>} topic \n     * @returns {Array<TopicCallbackEntry<T>>}\n     */\n    callbacksOf(topic) {\n        const topicName = topic.name;\n        if (topicName in this.callbacks) {\n            return this.callbacks[topicName];\n        } else {\n            let result = [];\n            this.callbacks[topicName] = result;\n            return result;\n        }\n    }\n}\n","/** @typedef {(frameDetail: AnimationFrameLoop) => void} AnimationFrameLoopCallback */\n\nexport class AnimationFrameLoop {\n    \n    /**\n     * @param {AnimationFrameLoopCallback} callback \n     * @param {object} [opts]\n     * @param {Window} [opts.animationFrameHandler]\n     */\n    constructor(callback, opts = undefined) {\n        const { animationFrameHandler = window } = opts || {};\n\n        /** @type {ReturnType<requestAnimationFrame>} */\n        this.handle = 0;\n        this.detail = {\n            prevTime: -1,\n            currentTime: -1,\n            deltaTime: 0,\n        };\n\n        /** @protected */\n        this.animationFrameHandler = animationFrameHandler;\n\n        /** @protected */\n        this.callback = callback;\n\n        this.next = this.next.bind(this);\n        this.start = this.start.bind(this);\n        this.cancel = this.cancel.bind(this);\n    }\n    \n    next(now = performance.now()) {\n        this.handle = this.animationFrameHandler.requestAnimationFrame(this.next);\n        let d = this.detail;\n        d.prevTime = d.currentTime;\n        d.currentTime = now;\n        d.deltaTime = d.currentTime - d.prevTime;\n        this.callback(this);\n    }\n\n    start() {\n        this.handle = this.animationFrameHandler.requestAnimationFrame(this.next);\n        return this;\n    }\n\n    cancel() {\n        this.animationFrameHandler.cancelAnimationFrame(this.handle);\n        return this;\n    }\n}\n","/**\n * @template M, T\n * @typedef {(m: M, [opts]: object) => T} Provider\n */\n\n/**\n * @template M, T\n * @typedef ProviderContext\n * @property {Provider<M, T>} handle\n * @property {T} value\n */\n\n/**\n * @template M, T\n * @param {M} m \n * @param {Provider<M, T>} provider \n * @returns {T}\n */\nexport function useProvider(m, provider) {\n    let state = resolveState(m);\n    let handle = provider.name;\n    if (handle in state.contexts) {\n        /** @type {ProviderContext<M, T>} */\n        let { value } = state.contexts[handle];\n        if (value) {\n            return value;\n        } else {\n            let current = getCurrentProvider(m);\n            if (current.name === provider.name) {\n                throw new Error(`Cannot useProvider() on self during initialization!`);\n            } else {\n                throw new Error('This is not a provider.');\n            }\n        }\n    }\n    throw new Error(`Missing assigned dependent provider '${handle}' in context.`);\n}\n\n/**\n * @template M\n * @param {M} m \n * @param {Array<Provider<?, ?>>} providers\n * @returns {M}\n */\nexport function injectProviders(m, providers) {\n    let state = resolveState(m);\n    for(let provider of providers) {\n        /** @type {ProviderContext<?, ?>} */\n        let context = {\n            handle: provider,\n            value: null,\n        };\n        state.contexts[provider.name] = context;\n        state.current = provider;\n        context.value = provider(m);\n    }\n    return m;\n}\n\n/**\n * @template M\n * @param {M} m \n * @param {Array<Provider<?, ?>>} providers\n * @returns {M}\n */\nexport function ejectProviders(m, providers) {\n    let state = getStateIfExists(m);\n    if (!state) {\n        return m;\n    }\n    for(let provider of providers.slice().reverse()) {\n        let context = state.contexts[provider.name];\n        context.value = null;\n        delete state.contexts[provider.name];\n    }\n    return m;\n}\n\n/**\n * @template M\n * @param {M} m\n */\nexport function getProviders(m) {\n    let state = getStateIfExists(m);\n    if (!state) {\n        return [];\n    }\n    return Object.values(state.contexts).map(ctx => ctx.handle);\n}\n\n/**\n * @template M\n * @param {M} m\n */\nexport function getCurrentProvider(m) {\n    let state = getStateIfExists(m);\n    if (!state) {\n        throw new Error('This is not a provider.');\n    }\n    return state.current;\n}\n\nconst KEY = Symbol('providers');\n\nfunction createState() {\n    return {\n        /** @type {Record<string, ProviderContext<?, ?>>} */\n        contexts: {},\n        /** @type {Provider<?, ?>} */\n        current: null,\n    };\n}\n\n/**\n * @param {object} target\n * @returns {ReturnType<createState>}\n */\nfunction resolveState(target) {\n    if (KEY in target) {\n        return target[KEY];\n    }\n    return target[KEY] = createState();\n}\n\n/**\n * @param {object} target\n * @returns {ReturnType<createState>|null}\n */\nfunction getStateIfExists(target) {\n    if (KEY in target) {\n        return target[KEY];\n    }\n    return null;\n}\n","import { getCurrentProvider } from './ProviderHook';\n\n/**\n * @callback EffectHandler\n * @returns {AfterEffectHandler|Promise<AfterEffectHandler>|Promise<void>|void}\n */\n\n/**\n * @callback AfterEffectHandler\n * @returns {Promise<void>|void}\n */\n\n/**\n * @typedef EffectorContext\n * @property {Array<EffectHandler>} befores\n * @property {Array<AfterEffectHandler|void>} afters\n */\n\n/**\n * @template M\n * @param {M} m \n * @param {EffectHandler} handler\n */\nexport function useEffect(m, handler) {\n    const provider = getCurrentProvider(m);\n    if (!provider) {\n        throw new Error('Not a provider.');\n    }\n    let state = resolveState(m);\n    let context = resolveContext(provider, state.contexts);\n    context.befores.push(handler);\n}\n\n/**\n * @template M\n * @param {M} m \n * @param {Array<import('./ProviderHook').Provider<M, ?>>} providers \n */\nexport async function applyEffects(m, providers) {\n    let state = resolveState(m);\n    for(let provider of providers) {\n        let context = resolveContext(provider, state.contexts);\n        let befores = context.befores.slice();\n        context.befores.length = 0;\n        let result = await Promise.all(befores.map(handler => handler && handler()));\n        context.afters.push(...result);\n    }\n    return m;\n}\n\n/**\n * @template M\n * @param {M} m \n * @param {Array<import('./ProviderHook').Provider<M, ?>>} providers \n */\nexport async function revertEffects(m, providers) {\n    let state = getStateIfExists(m);\n    if (!state) {\n        return m;\n    }\n    for(let provider of providers.slice().reverse()) {\n        let context = getContextIfExists(provider, state.contexts);\n        if (!context) {\n            throw new Error('Cannot revert context for non-existent provider.');\n        }\n        let afters = context.afters.slice();\n        context.afters.length = 0;\n        await Promise.all(afters.map(handler => handler && handler()));\n    }\n    return m;\n}\n\nconst KEY = Symbol('effectors');\n\nfunction createState() {\n    return {\n        /** @type {Record<string, EffectorContext>} */\n        contexts: {},\n    };\n}\n\n/**\n * @param {object} target\n * @returns {ReturnType<createState>}\n */\nfunction resolveState(target) {\n    if (KEY in target) {\n        return target[KEY];\n    }\n    return target[KEY] = createState();\n}\n\n/**\n * @param {object} target\n * @returns {ReturnType<createState>|null}\n */\nfunction getStateIfExists(target) {\n    if (KEY in target) {\n        return target[KEY];\n    }\n    return null;\n}\n\n/**\n * @returns {EffectorContext}\n */\nfunction createContext() {\n    return {\n        befores: [],\n        afters: [],\n    };\n}\n\n/**\n * @param {import('./ProviderHook').Provider<?, ?>} provider\n * @param {ReturnType<createState>['contexts']} target\n * @returns {ReturnType<createContext>}\n */\nfunction resolveContext(provider, target) {\n    const key = provider.name;\n    if (key in target) {\n        return target[key];\n    }\n    return target[key] = createContext();\n}\n\n/**\n * @param {import('./ProviderHook').Provider<?, ?>} provider\n * @param {ReturnType<createState>['contexts']} target\n * @returns {ReturnType<createContext>|null}\n */\nfunction getContextIfExists(provider, target) {\n    const key = provider.name;\n    if (key in target) {\n        return target[key];\n    }\n    return null;\n}\n","import { Topic } from '../topic/Topic';\nimport { useEffect } from './EffectHook';\n\n/**\n * @type {Topic<import('../loop/AnimationFrameLoop').AnimationFrameLoop>}\n */\nexport const SystemUpdateTopic = new Topic('main.update');\n\n/**\n * @template M\n * @param {M} m \n * @param {import('../topic/TopicManager').TopicManager} topics \n * @param {import('../topic/TopicManager').TopicCallback<import('../loop/AnimationFrameLoop').AnimationFrameLoop>} callback \n */\nexport function useSystemUpdate(m, topics, callback) {\n    useEffect(m, () => {\n        SystemUpdateTopic.on(topics, 0, callback);\n        return () => {\n            SystemUpdateTopic.off(topics, callback);\n        };\n    });\n}\n","import { useProvider } from './ProviderHook';\nimport { useEffect } from './EffectHook';\nimport { TopicManager } from '../topic/TopicManager';\nimport { useSystemUpdate } from './SystemUpdateHook';\n\n/**\n * @template M, T\n * @param {M} m \n * @param {import('../topic/Topic').Topic<T>} topic \n * @param {number} priority \n * @param {import('../topic/Topic').TopicCallback<T>} callback \n */\nexport function useTopic(m, topic, priority, callback) {\n    const topics = useProvider(m, TopicsProvider);\n    useEffect(m, () => {\n        topic.on(topics, priority, callback);\n        return () => {\n            topic.off(topics, callback);\n        };\n    });\n}\n\n/**\n * @template M\n * @param {M} m\n */\nexport function TopicsProvider(m) {\n    const topics = new TopicManager();\n    useSystemUpdate(m, topics, () => {\n        topics.flush();\n    });\n    return topics;\n}\n","import { AnimationFrameLoop } from '../loop/AnimationFrameLoop';\nimport { applyEffects, revertEffects, useEffect } from './EffectHook';\nimport { ejectProviders, injectProviders, useProvider } from './ProviderHook';\nimport { TopicsProvider } from './TopicHook';\nimport { SystemUpdateTopic, useSystemUpdate } from './SystemUpdateHook';\n\n/**\n * @template M\n * @typedef ToastHandler\n * @property {(m: M) => Promise<void>} [load]\n * @property {(m: M) => Promise<void>} [unload]\n * @property {(m: M) => Promise<void>} [main]\n * @property {(m: M) => void} init\n * @property {(m: M) => void} [dead]\n * @property {(m: M) => void} [update]\n * @property {(m: M) => void} [draw]\n */\n\n/**\n * @template M\n * @param {M} m\n * @param {ToastHandler<M>} handler\n */\nexport function toast(m, handler, providers = []) {\n    function GameSystem(m) {\n        const topics = useProvider(m, TopicsProvider);\n        useEffect(m, async () => {\n            if (handler.load) await handler.load(m);\n            if (handler.main) await handler.main(m);\n            if (handler.init) handler.init(m);\n            return async () => {\n                if (handler.dead) handler.dead(m);\n                if (handler.unload) await handler.unload(m);\n            };\n        });\n        useSystemUpdate(m, topics, () => {\n            if (handler.update) handler.update(m);\n            if (handler.draw) handler.draw(m);\n        });\n    }\n    const result = [\n        TopicsProvider,\n        AnimationFrameLoopProvider,\n        ...providers,\n        GameSystem,\n    ];\n    return {\n        async start() {\n            injectProviders(m, result);\n            await applyEffects(m, result);\n            return this;\n        },\n        async stop() {\n            await revertEffects(m, result);\n            ejectProviders(m, result);\n            return this;\n        },\n    }\n}\n\n/**\n * @template M\n * @param {M} m\n */\nexport function AnimationFrameLoopProvider(m) {\n    const topics = useProvider(m, TopicsProvider);\n    const loop = new AnimationFrameLoop((e) => {\n        SystemUpdateTopic.dispatchImmediately(topics, e);\n    });\n    useEffect(m, () => {\n        loop.start();\n    });\n    return loop;\n}\n","import { useEffect } from './EffectHook';\n\n/**\n * @template M\n * @template {keyof WindowEventHandlersEventMap} K\n * @param {M} m \n * @param {keyof WindowEventMap} event\n * @param {(this: WindowEventHandlers, ev: WindowEventHandlersEventMap[K]) => any} listener\n */\nexport function useWindowEventListener(m, event, listener) {\n    useEffect(m, () => {\n        const root = window;\n        root.addEventListener(event, listener);\n        return () => {\n            root.removeEventListener(event, listener);\n        };\n    });\n}\n\n/**\n * @template M\n * @template {keyof DocumentAndElementEventHandlersEventMap} K\n * @param {M} m \n * @param {keyof DocumentEventMap} event\n * @param {(this: DocumentAndElementEventHandlers, ev: DocumentAndElementEventHandlersEventMap[K]) => any} listener\n */\nexport function useDocumentEventListener(m, event, listener) {\n    useEffect(m, () => {\n        const root = window.document;\n        root.addEventListener(event, listener);\n        return () => {\n            root.removeEventListener(event, listener);\n        };\n    });\n}\n\n/**\n * @template M\n * @template {keyof DocumentAndElementEventHandlersEventMap} K\n * @param {M} m \n * @param {HTMLElement} element\n * @param {keyof ElementEventMap} event\n * @param {(this: DocumentAndElementEventHandlers, ev: DocumentAndElementEventHandlersEventMap[K]) => any} listener\n */\nexport function useHTMLElementEventListener(m, element, event, listener) {\n    useEffect(m, () => {\n        element.addEventListener(event, listener);\n        return () => {\n            element.removeEventListener(event, listener);\n        };\n    });\n}\n","/**\n * @template T\n */\nexport class ComponentClass {\n    /**\n     * @param {string} name \n     * @param {() => T} newCallback\n     * @param {(component: T) => void} [deleteCallback] \n     */\n    constructor(name, newCallback = () => null, deleteCallback = () => {}) {\n        this.name = name;\n        this.new = newCallback;\n        this.delete = deleteCallback;\n    }\n}\n","import { ComponentClass } from './ComponentClass';\nimport { QueryManager } from './QueryManager';\n\n/**\n * @template T\n * @typedef {Record<number, T>} ComponentInstanceMap<T>\n */\n\n/**\n * @typedef {Record<string, ComponentInstanceMap<?>>} ComponentClassMap\n * @typedef {number} EntityId\n * @typedef {string} ComponentName\n */\n\n/**\n * @callback EntityComponentChangedCallback\n * @param {EntityManager} entityManager\n * @param {EntityId} entityId\n * @param {ComponentClass<?>} attached\n * @param {ComponentClass<?>} detached\n * @param {boolean} dead\n */\n\nexport class EntityManager {\n\n    constructor() {\n        /**\n         * @protected\n         * @type {ComponentClassMap}\n         */\n        this.components = {};\n        /** @private */\n        this.nameClassMapping = {};\n        /**\n         * @private\n         * @type {EntityId}\n         */\n        this.nextAvailableEntityId = 1;\n        /**\n         * @protected\n         * @type {Array<[string, ...any]>}\n         */\n        this.queue = [];\n        /** @private */\n        this.listeners = [];\n        this.queries = new QueryManager();\n    }\n\n    /**\n     * @protected\n     * @param {EntityId} entityId\n     * @param {ComponentClass<?>} attached\n     * @param {ComponentClass<?>} detached\n     * @param {boolean} dead\n     */\n    entityComponentChangedCallback(entityId, attached, detached, dead) {\n        this.queries.onEntityComponentChanged(this, entityId, attached, detached, dead);\n        for(let callback of this.listeners) {\n            callback(this, entityId, attached, detached, dead);\n        }\n    }\n\n    /**\n     * @param {'change'} event \n     * @param {EntityComponentChangedCallback} callback \n     */\n    addEventListener(event, callback) {\n        if (event === 'change') {\n            this.listeners.push(callback);\n        }\n    }\n\n    /**\n     * @param {'change'} event \n     * @param {EntityComponentChangedCallback} callback \n     */\n    removeEventListener(event, callback) {\n        if (event === 'change') {\n            let i = this.listeners.indexOf(callback);\n            if (i >= 0) {\n                this.listeners.splice(i, 1);\n            }\n        }\n    }\n\n    flush() {\n        while (this.queue.length > 0) {\n            let [type, ...args] = this.queue.shift();\n            switch (type) {\n                case 'attach': {\n                    let [entityId, componentClass, instance] = args;\n                    this.attachImmediately(entityId, componentClass, instance);\n                } break;\n                case 'detach': {\n                    let [entityId, componentClass] = args;\n                    this.detachImmediately(entityId, componentClass);\n                } break;\n                case 'clear': {\n                    let [componentClass] = args;\n                    this.clearImmediately(componentClass);\n                } break;\n            }\n        }\n    }\n\n    /**\n     * @returns {EntityId}\n     */\n    create() {\n        let entityId = this.nextAvailableEntityId++;\n        this.entityComponentChangedCallback(entityId, null, null, false);\n        return entityId;\n    }\n\n    /**\n     * @param {EntityId} entityId \n     */\n    destroy(entityId) {\n        const components = this.components;\n        for (const componentName of Object.keys(components)) {\n            const instanceMap = components[componentName];\n            if (entityId in instanceMap) {\n                delete instanceMap[entityId];\n                this.entityComponentChangedCallback(entityId, null, this.nameClassMapping[componentName], false);\n            }\n        }\n        this.entityComponentChangedCallback(entityId, null, null, true);\n    }\n\n    /**\n     * Whether the entity exists with all provided component classes.\n     * \n     * @param {EntityId} entityId \n     * @param {...ComponentClass<?>} componentClasses\n     */\n    exists(entityId, ...componentClasses) {\n        if (componentClasses.length > 0) {\n            for(const componentClass of componentClasses) {\n                let instanceMap = this.mapOf(componentClass);\n                if (!(entityId in instanceMap)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            for (let instanceMap of Object.values(this.components)) {\n                if (entityId in instanceMap) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass\n     * @param {T} [instance]\n     * @returns {T}\n     */\n    attach(entityId, componentClass, instance = undefined) {\n        if (typeof instance === 'undefined') {\n            instance = componentClass.new();\n        }\n        this.queue.push(['attach', entityId, componentClass, instance]);\n        return instance;\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     * @param {T} [instance]\n     * @returns {T}\n     */\n    attachImmediately(entityId, componentClass, instance = undefined) {\n        if (typeof instance === 'undefined') {\n            instance = componentClass.new();\n        }\n        let instanceMap = this.mapOf(componentClass);\n        instanceMap[entityId] = instance;\n        this.entityComponentChangedCallback(entityId, componentClass, null, false);\n        return instance;\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass\n     */\n    detach(entityId, componentClass) {\n        this.queue.push(['detach', entityId, componentClass]);\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     */\n    detachImmediately(entityId, componentClass) {\n        let instanceMap = this.mapOf(componentClass);\n        let instance = instanceMap[entityId];\n        delete instanceMap[entityId];\n        componentClass.delete(instance);\n        this.entityComponentChangedCallback(entityId, null, componentClass, false);\n    }\n\n    /**\n     * @param {ComponentClass<?>} componentClass \n     */\n    clear(componentClass) {\n        this.queue.push(['clear', componentClass]);\n    }\n\n    /**\n     * @param {ComponentClass<any>} componentClass \n     */\n    clearImmediately(componentClass) {\n        const componentName = componentClass.name;\n        const components = this.components;\n        const instanceMap = components[componentName];\n        let entities = Object.keys(instanceMap).map(Number);\n        let instances = Object.values(instanceMap);\n        components[componentName] = {};\n        this.nameClassMapping[componentName] = componentClass;\n        for(let instance of instances) {\n            componentClass.delete(instance);\n        }\n        for(let entityId of entities) {\n            this.entityComponentChangedCallback(entityId, null, componentClass, false);\n        }\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     * @returns {T}\n     */\n    get(entityId, componentClass) {\n        return this.mapOf(componentClass)[entityId] || null;\n    }\n\n    /**\n     * @param {ComponentClass<?>} componentClass \n     * @returns {number}\n     */\n    count(componentClass) {\n        return Object.keys(this.mapOf(componentClass)).length;\n    }\n\n    /**\n     * @param {ComponentClass<?>} componentClass\n     */\n    keysOf(componentClass) {\n        return Object.keys(this.mapOf(componentClass)).map(Number);\n    }\n\n    /**\n     * @template T\n     * @param {ComponentClass<T>} componentClass \n     * @returns {Array<T>}\n     */\n    valuesOf(componentClass) {\n        return Object.values(this.mapOf(componentClass));\n    }\n\n    /**\n     * @protected\n     * @template T\n     * @param {ComponentClass<T>} componentClass\n     * @returns {ComponentInstanceMap<T>} A map of entity ids to component instance data.\n     */\n    mapOf(componentClass) {\n        const componentName = componentClass.name;\n        const components = this.components;\n        if (!(componentName in components)) {\n            /** @type {ComponentInstanceMap<T>} */\n            let map = {};\n            components[componentName] = map;\n            this.nameClassMapping[componentName] = componentClass;\n            return map;\n        } else {\n            return components[componentName];\n        }\n    }\n\n    /** @returns {Set<EntityId>} */\n    entityIds() {\n        let result = new Set();\n        for (let instanceMap of Object.values(this.components)) {\n            for(let entityId of Object.keys(instanceMap)) {\n                result.add(entityId);\n            }\n        }\n        return result;\n    }\n\n    /** @returns {Array<ComponentClass<?>>} */\n    componentClasses() {\n        return Object.values(this.nameClassMapping);\n    }\n\n    reset() {\n        const components = this.components;\n        /** @type {Set<EntityId>} */\n        let entities = new Set();\n        for(const componentName of Object.keys(components)) {\n            const componentClass = this.nameClassMapping[componentName];\n            const instanceMap = components[componentName];\n            for(let entityId of Object.keys(instanceMap)) {\n                entities.add(Number(entityId));\n            }\n            this.clearImmediately(componentClass);\n        }\n        for(let entityId of entities) {\n            this.entityComponentChangedCallback(entityId, null, null, true);\n        }\n        entities.clear();\n        this.queries.reset();\n        this.components = {};\n        this.nextAvailableEntityId = 1;\n        this.queue.length = 0;\n        this.listeners.length = 0;\n    }\n}\n","import { EntityManager } from './EntityManager';\nimport { ComponentClass } from './ComponentClass';\n\n/** @typedef {import('./EntityManager').EntityId} EntityId */\n\n/**\n * @template {ComponentClass<any>[]} T\n * @typedef {{[K in keyof T]: T[K] extends ComponentClass<infer V> ? V : never}} ComponentInstancesOf<T>\n */\n\n/**\n * @template {ComponentClass<any>[]} T\n */\nexport class EntityTemplate {\n    /**\n     * @param {T} componentClasses \n     */\n    constructor(...componentClasses) {\n        /** @private */\n        this.componentClasses = componentClasses;\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n     */\n    create(entityManager) {\n        let entityId = entityManager.create();\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (/** @type {unknown} */ ([entityId]));\n        for (let componentClass of this.componentClasses) {\n            let instance = entityManager.attach(entityId, componentClass);\n            result.push(instance);\n        }\n        return result;\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @param {EntityId} entityId \n     */\n    destroy(entityManager, entityId) {\n        for (let componentClass of this.componentClasses) {\n            entityManager.detach(entityId, componentClass);\n        }\n    }\n}\n","import { mat4 } from 'gl-matrix';\nimport { Camera } from './Camera.js';\n\nexport class OrthographicCamera extends Camera {\n  /**\n   * @param {number} [left]\n   * @param {number} [top]\n   * @param {number} [right]\n   * @param {number} [bottom]\n   * @param {number} [near]\n   * @param {number} [far]\n   */\n  constructor(\n    left = undefined,\n    top = undefined,\n    right = undefined,\n    bottom = undefined,\n    near = -1000,\n    far = 1000\n  ) {\n    super(mat4.create(), mat4.create());\n\n    this.orthoBounds = {\n      left: typeof left === 'undefined' ? undefined : Number(left),\n      top: typeof top === 'undefined' ? undefined : Number(top),\n      right: typeof right === 'undefined' ? undefined : Number(right),\n      bottom: typeof bottom === 'undefined' ? undefined : Number(bottom),\n    };\n    this.clippingPlane = {\n      near: Number(near),\n      far: Number(far),\n    };\n  }\n\n  /**\n   * If both the bounds and viewport dimensions are defined, the orthographic\n   * projection will be set the defined bounds adjusted with respect to\n   * the aspect ratio. This is usually the desired behavior.\n   *\n   * If the bounds are `undefined`, the orthographic projection will\n   * be set to the viewport dimensions. This is useful for pixel-perfect\n   * projections.\n   *\n   * If viewport dimensions are `undefined`, the orthographic projection\n   * will only use the defined bounds. This is useful if you are already\n   * performing your own calculations for the bounds or desire a static\n   * projection.\n   *\n   * @override\n   * @param {number} [viewportWidth]\n   * @param {number} [viewportHeight]\n   */\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    const { near, far } = this.clippingPlane;\n    const { left, top, right, bottom } = this.orthoBounds;\n\n    let projectionMatrix = this.projectionMatrix;\n    let hasViewport = typeof viewportWidth !== 'undefined';\n    let hasBounds = typeof left !== 'undefined';\n\n    if (hasViewport) {\n      if (hasBounds) {\n        // Use the defined bounds with respect to the viewport aspect ratio\n        const aspectRatio = viewportWidth / viewportHeight;\n        mat4.ortho(\n          projectionMatrix,\n          left * aspectRatio,\n          right * aspectRatio,\n          bottom,\n          top,\n          near,\n          far\n        );\n      } else {\n        // Use the viewport dimensions as bounds\n        mat4.ortho(\n          projectionMatrix,\n          0,\n          viewportWidth,\n          viewportHeight,\n          0,\n          near,\n          far\n        );\n      }\n    } else {\n      if (hasBounds) {\n        // Use the defined bounds as-is\n        mat4.ortho(projectionMatrix, left, right, bottom, top, near, far);\n      } else {\n        // Use default bounds (since nothing else exists)\n        mat4.ortho(projectionMatrix, -1, 1, 1, -1, -1, 1);\n      }\n    }\n    return this;\n  }\n}\n"],"names":["UP","vec3","fromValues","Camera","constructor","projectionMatrix","viewMatrix","this","resize","viewportWidth","viewportHeight","DEFAULT_FOVY","Math","PI","TO_RAD_FACTOR","MAX_DEPTH_LEVEL","attach","parentNode","childNode","sceneGraph","nodes","children","push","parent","roots","detach","childIndex","indexOf","splice","rootIndex","walkImpl","level","nodeCallback","filterCallback","result","parentInfo","nextNodes","walkDeleteCallback","sceneNode","QueryManager","cachedResults","keyQueryMapping","onEntityComponentChanged","bind","entityManager","entityId","added","removed","dead","query","Object","values","entities","key","i","hasSelector","Not","test","findAny","findAll","length","floor","random","queryKey","hydrate","count","clear","reset","componentClass","type","name","value","isSelectorNot","selector","computeResult","out","selectors","get","Topic","dispatch","topicManager","attachment","dispatchImmediately","async","dispatchImmediatelyAndWait","on","priority","callback","addEventListener","off","removeEventListener","once","wrapper","poll","amount","min","retain","pollAndRetain","comparator","a","b","TopicManager","cachedIn","cachedOut","callbacks","maxRetains","nameTopicMapping","topic","opts","callbacksOf","sort","findIndex","v","countEventListeners","incomingOf","outgoingOf","outgoing","shift","topicName","max","flush","maxPerTopic","keys","incoming","getPendingRetainCount","getPendingFlushCount","AnimationFrameLoop","animationFrameHandler","window","handle","detail","prevTime","currentTime","deltaTime","next","start","cancel","now","performance","requestAnimationFrame","d","cancelAnimationFrame","useProvider","m","provider","state","resolveState","contexts","getCurrentProvider","Error","getStateIfExists","current","KEY","Symbol","target","useEffect","handler","resolveContext","befores","revertEffects","providers","slice","reverse","context","getContextIfExists","afters","Promise","all","map","SystemUpdateTopic","useSystemUpdate","topics","TopicsProvider","AnimationFrameLoopProvider","loop","e","load","main","init","unload","update","draw","injectProviders","applyEffects","ejectProviders","event","listener","root","document","element","newCallback","deleteCallback","new","delete","components","nameClassMapping","nextAvailableEntityId","queue","listeners","queries","entityComponentChangedCallback","attached","detached","args","instance","attachImmediately","detachImmediately","clearImmediately","create","destroy","componentName","instanceMap","exists","componentClasses","mapOf","Number","instances","keysOf","valuesOf","entityIds","Set","add","locky","position","forward","right","up","forwardAmount","rightAmount","upAmount","pitch","yaw","look","dx","dy","dt","move","apply","rady","radp","cosy","cos","cosp","siny","sin","dz","normalize","set","cross","scale","mat4","lookAt","left","top","bottom","near","far","super","orthoBounds","undefined","clippingPlane","hasBounds","aspectRatio","ortho","fieldOfView","perspective","s","join","queryManager","Array","fill","_nextAvailableSceneNodeId","createSceneNode","info","createSceneNodes","deleteSceneNode","deleteSceneNodes","sceneNodes","getSceneNodeInfo","parentSceneNode","replaceSceneNode","replacementNode","grandChildren","replacementInfo","walk","from","childFilter","fromNodes","isArray","fromNode","x","y","z","rotation","quat","getTranslation","getRotation","targetRotation","slerp","fromRotationTranslation","translation","translate","normalizedScreenCoordX","normalizedScreenCoordY","normalized","vec4","invert","transformMat4"],"mappings":"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"}