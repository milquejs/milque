{"version":3,"file":"milque-scene.umd.js","sources":["../src/camera/CameraHelper.js","../src/camera/Camera.js","../src/camera/PerspectiveCamera.js","../src/camera/FirstPersonCameraController.js","../src/scenegraph/SceneGraph.js","../src/entity/EntityManager.js","../src/topic/Topic.js","../src/topic/PriorityEventTopic.js","../src/loop/AnimationFrameLoop.js","../src/topic/CommandTopic.js","../src/entity/ComponentClass.js","../src/topic/EventTopic.js","../src/camera/OrthographicCamera.js"],"sourcesContent":["import { mat4, quat, vec3, vec4 } from 'gl-matrix';\n\nconst UP = vec3.fromValues(0, 1, 0);\n\nexport function panTo(viewMatrix, x, y, z = 0, dt = 1) {\n  let position = vec3.create();\n  mat4.getTranslation(position, viewMatrix);\n  let translation = vec3.fromValues(\n    (x - position[0]) * dt,\n    (y - position[1]) * dt,\n    (z - position[2]) * dt\n  );\n  mat4.translate(viewMatrix, viewMatrix, translation);\n}\n\nexport function lookAt(viewMatrix, x, y, z = 0, dt = 1) {\n  let position = vec3.create();\n  let rotation = quat.create();\n  mat4.getTranslation(position, viewMatrix);\n  mat4.getRotation(rotation, viewMatrix);\n  let target = vec3.fromValues(x, y, z);\n\n  mat4.lookAt(viewMatrix, position, target, UP);\n\n  let targetRotation = quat.create();\n  mat4.getRotation(targetRotation, viewMatrix);\n  quat.slerp(rotation, rotation, targetRotation, dt);\n\n  mat4.fromRotationTranslation(viewMatrix, rotation, position);\n}\n\n/**\n * Gets a directional ray in the world space from the given normalized\n * screen coordinates and camera matrices.\n *\n * NOTE: In addition to some scaling, the y component from a pointer's\n * position usually has to be flipped to match the normalized screen\n * coordinate space, which assumes a range of [-1, 1] for both x and y,\n * where (0, 0) is the center and (-1, -1) is the bottom-left of the\n * screen.\n *\n * ### Typical Device Screen Coordinate Space:\n * ```\n * (0,0)------------(w,0)\n *    |               |\n *    |   (w/2,h/2)   |\n *    |               |\n * (0,w)------------(w,h)\n * ```\n *\n * ### Normalized Screen Coordinate Space:\n * ```\n * (-1,+1)---------(+1,+1)\n *    |               |\n *    |     (0,0)     |\n *    |               |\n * (-1,-1)---------(+1,-1)\n * ```\n *\n * ### Example Conversion from Device to Normalized:\n * ```\n * let normalizedScreenX = (canvasClientX / canvasWidth) * 2 - 1;\n * let normalizedScreenY = 1 - (canvasClientY / canvasHeight) * 2;\n * ```\n *\n * @param {vec3} out The output vector.\n * @param {number} normalizedScreenCoordX The X screen coordinate normalized to [-1, 1], where -1 is the left side of the screen.\n * @param {number} normalizedScreenCoordY The Y screen coordinate normalized to [-1, 1], where -1 is the bottom side of the screen.\n * @param {mat4} projectionMatrix The projection matrix of the world camera.\n * @param {mat4} viewMatrix The view matrix of the world camera.\n * @param {boolean} [normalized=false] Whether to normalize the result. Usually true for non-orthogonal projections.\n * @returns {vec3} The ray direction in the world space. By default, this is not normalized.\n */\nexport function screenToWorldRay(\n  out,\n  normalizedScreenCoordX,\n  normalizedScreenCoordY,\n  projectionMatrix,\n  viewMatrix,\n  normalized = false\n) {\n  // https://antongerdelan.net/opengl/raycasting.html\n  // To homogeneous clip coords\n  let v = vec4.fromValues(\n    normalizedScreenCoordX,\n    normalizedScreenCoordY,\n    -1,\n    1\n  );\n  // To camera coords\n  let m = mat4.create();\n  mat4.invert(m, projectionMatrix);\n  vec4.transformMat4(v, v, m);\n  v[2] = -1;\n  v[3] = 0;\n  // To world coords\n  mat4.invert(m, viewMatrix);\n  vec4.transformMat4(v, v, m);\n  out[0] = v[0];\n  out[1] = v[1];\n  out[2] = v[2];\n  // Normalized as directional ray\n  if (normalized) {\n    vec3.normalize(out, out);\n  }\n  return out;\n}\n","export class Camera {\n  constructor(projectionMatrix, viewMatrix) {\n    this.projectionMatrix = projectionMatrix;\n    this.viewMatrix = viewMatrix;\n  }\n\n  /**\n   * @abstract\n   * @param {number} [viewportWidth]\n   * @param {number} [viewportHeight]\n   * @returns {Camera}\n   */\n  // eslint-disable-next-line no-unused-vars\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    return this;\n  }\n}\n","import { mat4 } from 'gl-matrix';\nimport { Camera } from './Camera.js';\n\nconst DEFAULT_FOVY = Math.PI / 3;\n\nexport class PerspectiveCamera extends Camera {\n  constructor(fieldOfView = DEFAULT_FOVY, near = 0.1, far = 1000) {\n    super(mat4.create(), mat4.create());\n\n    this.fieldOfView = Number(fieldOfView);\n    this.clippingPlane = {\n      near: Number(near),\n      far: Number(far),\n    };\n  }\n\n  /** @override */\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    const aspectRatio =\n      typeof viewportWidth === 'undefined' ? 1 : viewportWidth / viewportHeight;\n    const { near, far } = this.clippingPlane;\n    mat4.perspective(\n      this.projectionMatrix,\n      this.fieldOfView,\n      aspectRatio,\n      near,\n      far\n    );\n    return this;\n  }\n}\n","import { vec3, mat4 } from 'gl-matrix';\n\nconst TO_RAD_FACTOR = Math.PI / 180;\n\n/**\n * A camera controller that behaves like a traditional first person camera.\n * Pitch is restricted to prevent gimbal lock and roll is ignored.\n *\n * NOTE: Don't forget to lock your pointer, i.e. `canvas.requestPointerLock()`.\n */\nexport class FirstPersonCameraController {\n  constructor(opts = { locky: false }) {\n    this.locky = opts.locky;\n\n    this.position = vec3.create();\n    this.forward = vec3.fromValues(0, 0, -1);\n    this.right = vec3.fromValues(1, 0, 0);\n    this.up = vec3.fromValues(0, 1, 0);\n\n    this.forwardAmount = 0;\n    this.rightAmount = 0;\n    this.upAmount = 0;\n\n    this.pitch = 0;\n    this.yaw = -90;\n  }\n\n  look(dx, dy, dt = 1) {\n    // NOTE: Increase sensitivity to relatively match movement.\n    dt *= 1000;\n    this.pitch = Math.min(89.9, Math.max(-89.9, this.pitch + dy * dt));\n    this.yaw = (this.yaw + dx * dt) % 360;\n    return this;\n  }\n\n  move(forward, right = 0, up = 0, dt = 1) {\n    this.forwardAmount += forward * dt;\n    this.rightAmount += right * dt;\n    this.upAmount += up * dt;\n    return this;\n  }\n\n  apply(viewMatrix) {\n    let {\n      position,\n      forward,\n      right,\n      up,\n      forwardAmount,\n      rightAmount,\n      upAmount,\n      pitch,\n      yaw,\n    } = this;\n\n    // Calculate forward and right vectors\n    let rady = yaw * TO_RAD_FACTOR;\n    let radp = pitch * TO_RAD_FACTOR;\n    let cosy = Math.cos(rady);\n    let cosp = Math.cos(radp);\n    let siny = Math.sin(rady);\n    let sinp = Math.sin(radp);\n    let dx = cosy * cosp;\n    let dy = sinp;\n    let dz = siny * cosp;\n\n    // Set forward for move vector\n    vec3.normalize(forward, vec3.set(forward, dx, this.locky ? 0 : dy, dz));\n    vec3.normalize(right, vec3.cross(right, forward, up));\n\n    let move = vec3.create();\n    // Move forward\n    vec3.scale(move, forward, forwardAmount);\n    vec3.add(position, position, move);\n    // Move right\n    vec3.scale(move, right, rightAmount);\n    vec3.add(position, position, move);\n    // Move up\n    vec3.scale(move, up, upAmount);\n    vec3.add(position, position, move);\n    // Reset movement\n    this.forwardAmount = 0;\n    this.rightAmount = 0;\n    this.upAmount = 0;\n\n    // Reset forward for look vector\n    if (this.locky) vec3.set(forward, dx, dy, dz);\n\n    let target = vec3.add(move, position, forward);\n    mat4.lookAt(viewMatrix, position, target, up);\n    return viewMatrix;\n  }\n}\n","const MAX_DEPTH_LEVEL = 100;\n\n/**\n * @typedef {Number} SceneNode\n *\n * @typedef SceneNodeInfo\n * @property {SceneNode} parent The parent node. If the node does not have a parent,\n * it will be 0.\n * @property {Array<SceneNode>} children The list of child nodes.\n *\n * @callback WalkCallback Called for each node, before traversing its children.\n * @param {SceneNode} sceneNode The current scene node.\n * @param {SceneGraph} sceneGraph The current scene graph.\n * @returns {WalkBackCallback|Boolean} If false, the walk will skip\n * the current node's children and all of its descendents. If a function,\n * it will be called after traversing down all of its children.\n *\n * @callback WalkBackCallback Called if returned by {@link WalkCallback}, after\n * traversing the current node's children.\n * @param {SceneNode} sceneNode The current scene node.\n * @param {SceneGraph} sceneGraph The current scene graph.\n *\n * @callback WalkChildrenCallback Called for each level of children, before\n * traversing them. This is usually used to determine visit order.\n * @param {Array<SceneNode>} childNodes A list of child nodes to be visited.\n * @param {SceneNode} parentNode The current parent node of these children.\n * @param {SceneGraph} sceneGraph The current scene graph.\n * @returns {Array<SceneNode>} The list of children to traverse for this parent.\n */\n\n/**\n * A tree-like graph of nodes with n-children.\n */\nexport class SceneGraph {\n  /**\n   * Constructs an empty scene graph.\n   */\n  constructor() {\n    this.nodes = {};\n    this.roots = [];\n\n    this._nextAvailableSceneNodeId = 1;\n  }\n\n  /**\n   * Creates a scene node in the scene graph.\n   *\n   * @param {SceneNode} [parentNode] The parent node for the created scene\n   * node.\n   * @returns {SceneNode} The created scene node.\n   */\n  createSceneNode(parentNode = undefined) {\n    let sceneNode = this._nextAvailableSceneNodeId++;\n    let info = createSceneNodeInfo();\n    this.nodes[sceneNode] = info;\n    attach(parentNode, sceneNode, this);\n    return sceneNode;\n  }\n\n  /**\n   * Creates multiple scene nodes in the scene graph.\n   *\n   * @param {Number} count The number of scene nodes to create.\n   * @param {SceneNode} [parentNode] The parent node for the created scene\n   * nodes.\n   * @returns {Array<SceneNode>} A list of created scene nodes.\n   */\n  createSceneNodes(count, parentNode = undefined) {\n    let result = [];\n    for (let i = 0; i < count; ++i) {\n      result.push(this.createSceneNode(parentNode));\n    }\n    return result;\n  }\n\n  /**\n   * Deletes a scene node from the scene graph, along with all\n   * of its descendents.\n   *\n   * @param {SceneNode} sceneNode The scene node to remove.\n   */\n  deleteSceneNode(sceneNode) {\n    if (sceneNode in this.nodes) {\n      let info = this.nodes[sceneNode];\n      detach(info.parent, sceneNode, this);\n      walkImpl(this, sceneNode, 0, walkDeleteCallback);\n    } else {\n      throw new Error('Cannot delete non-existant scene node for scene graph.');\n    }\n  }\n\n  /**\n   * Deletes all given scene nodes from the scene graph, along with all\n   * of their descendents.\n   *\n   * @param {Array<SceneNode>} sceneNodes A list of scene nodes to remove.\n   */\n  deleteSceneNodes(sceneNodes) {\n    for (let sceneNode of sceneNodes) {\n      this.deleteSceneNode(sceneNode);\n    }\n  }\n\n  /**\n   * Get the scene node's info.\n   *\n   * @param {SceneNode} sceneNode The scene node to get info for.\n   * @returns {SceneNodeInfo} The info for the given scene node.\n   */\n  getSceneNodeInfo(sceneNode) {\n    return this.nodes[sceneNode];\n  }\n\n  /**\n   * Changes the parent of the scene node with the new parent node in\n   * the graph.\n   *\n   * @param {SceneNode} sceneNode The target scene node to change.\n   * @param {SceneNode} parentNode The scene node to set as the parent.\n   */\n  parentSceneNode(sceneNode, parentNode) {\n    let info = this.nodes[sceneNode];\n    detach(info.parent, sceneNode, this);\n    attach(parentNode, sceneNode, this);\n  }\n\n  /**\n   * Replaces the scene node with the new replacement node in the graph,\n   * inheriting its parent and children.\n   *\n   * @param {SceneNode} sceneNode The target scene node to replace.\n   * @param {SceneNode} replacementNode The scene node to replace with. If falsey,\n   * it will remove the target scene node and the target's parent will adopt\n   * its grandchildren. If the target did not have parents, the grandchildren will\n   * become root nodes in the graph.\n   */\n  replaceSceneNode(sceneNode, replacementNode) {\n    let info = this.nodes[sceneNode];\n    let parentNode = info.parent;\n    let grandChildren = info.children.slice();\n\n    // Remove the target node from graph\n    detach(parentNode, sceneNode, this);\n\n    // Begin grafting the grandchildren by removing them...\n    info.children.length = 0;\n\n    if (replacementNode) {\n      // Reattach all grandchildren to new replacement node.\n      let replacementInfo = this.nodes[replacementNode];\n      let replacementParent = replacementInfo.parent;\n\n      // Remove replacement node from previous parent\n      detach(replacementParent, replacementNode, this);\n\n      // ...and graft them back.\n      replacementInfo.children.push(...grandChildren);\n\n      // And reattach target parent to new child.\n      attach(parentNode, replacementNode, this);\n    } else {\n      // Reattach all grandchildren to target parent...\n      if (parentNode) {\n        //...as regular children.\n        let parentInfo = this.nodes[parentNode];\n        parentInfo.children.push(...grandChildren);\n      } else {\n        //...as root children.\n        this.roots.push(...grandChildren);\n      }\n    }\n\n    // ...and repair their parent relations.\n    for (let childNode of grandChildren) {\n      this.nodes[childNode].parent = parentNode;\n    }\n  }\n\n  /**\n   * Walks through every child node in the graph.\n   *\n   * @param {WalkCallback} callback The function called for each node\n   * in the graph, in ordered traversal from parent to child.\n   * @param {Object} [opts={}] Any additional options.\n   * @param {SceneNode|Array<SceneNode>} [opts.from] The parent node to\n   * start walking from, inclusive. By default, it will start from the root\n   * nodes.\n   * @param {WalkChildrenCallback} [opts.childfilter] The function called before\n   * walking through the children. This is usually used to determine the\n   * visiting order.\n   */\n  walk(callback, opts = {}) {\n    const { from = undefined, childFilter = undefined } = opts;\n\n    let fromNodes;\n    if (!from) fromNodes = this.roots;\n    else if (!Array.isArray(from)) fromNodes = [from];\n    else fromNodes = from;\n\n    if (childFilter) fromNodes = childFilter(fromNodes, 0, this);\n    for (let fromNode of fromNodes) {\n      walkImpl(this, fromNode, 0, callback, childFilter);\n    }\n  }\n}\n\n/**\n * @param {SceneNode} key The scene node handle.\n * @returns {SceneNodeInfo} The scene node metadata.\n */\nfunction createSceneNodeInfo() {\n  return {\n    parent: 0,\n    children: [],\n  };\n}\n\n/**\n * Attaches a child node to a parent in the scene graph. If parentNode is\n * null, then it will attach as a root node.\n *\n * @param {SceneNode} parentNode The parent node to attach to. Can be null.\n * @param {SceneNode} childNode The child node to attach from.\n * @param {SceneGraph} sceneGraph The scene graph to attach in.\n */\nfunction attach(parentNode, childNode, sceneGraph) {\n  if (parentNode) {\n    // Has new parent; attach to parent. It is now in the graph.\n    sceneGraph.nodes[parentNode].children.push(childNode);\n    sceneGraph.nodes[childNode].parent = parentNode;\n  } else {\n    // No parent; move to root. It is now in the graph.\n    sceneGraph.roots.push(childNode);\n    sceneGraph.nodes[childNode].parent = 0;\n  }\n}\n\n/**\n * Detaches a child node from its parent in the scene graph. If parentNode is\n * null, then it will detach as a root node.\n *\n * @param {SceneNode} parentNode The parent node to attach to. Can be null.\n * @param {SceneNode} childNode The child node to attach from.\n * @param {SceneGraph} sceneGraph The scene graph to attach in.\n */\nfunction detach(parentNode, childNode, sceneGraph) {\n  if (parentNode) {\n    // Has parent; detach from parent. It is now a free node.\n    let children = sceneGraph.nodes[parentNode].children;\n    let childIndex = children.indexOf(childNode);\n    children.splice(childIndex, 1);\n    sceneGraph.nodes[childNode].parentNode = 0;\n  } else {\n    // No parent; remove from root. It is now a free node.\n    let roots = sceneGraph.roots;\n    let rootIndex = roots.indexOf(childNode);\n    roots.splice(rootIndex, 1);\n    sceneGraph.nodes[childNode].parentNode = 0;\n  }\n}\n\n/**\n * Walk down from the parent and through all its descendents.\n *\n * @param {SceneGraph} sceneGraph The scene graph containing the nodes to be visited.\n * @param {SceneNode} parentNode The parent node to start walking from.\n * @param {Number} level The current call depth level. This is used to limit the call stack.\n * @param {WalkCallback} nodeCallback The function called on each visited node.\n * @param {WalkChildrenCallback} [filterCallback] The function called before\n * walking through the children. This is usually used to determine the visiting order.\n */\nfunction walkImpl(\n  sceneGraph,\n  parentNode,\n  level,\n  nodeCallback,\n  filterCallback = undefined\n) {\n  if (level >= MAX_DEPTH_LEVEL) return;\n\n  let result = nodeCallback(parentNode, sceneGraph);\n  if (result === false) return;\n\n  let parentInfo = sceneGraph.nodes[parentNode];\n  let nextNodes = filterCallback\n    ? filterCallback(parentInfo.children, parentNode, sceneGraph)\n    : parentInfo.children;\n\n  for (let childNode of nextNodes) {\n    walkImpl(sceneGraph, childNode, level + 1, nodeCallback, filterCallback);\n  }\n\n  if (typeof result === 'function') {\n    result(parentNode, sceneGraph);\n  }\n}\n\nfunction walkDeleteCallback(sceneNode, sceneGraph) {\n  delete sceneGraph.nodes[sceneNode];\n}\n","import { ComponentClass } from './ComponentClass';\n\n/**\n * @typedef {Record<number, object>} ComponentInstanceMap\n * @typedef {Record<string, ComponentInstanceMap>} ComponentClassMap\n * @typedef {number} EntityId\n * @typedef {string} ComponentName\n */\n\n/**\n * @template {ComponentClass<any>[]} T\n * @typedef {{[K in keyof T]: T[K] extends ComponentClass<infer V> ? V : never}} ComponentInstancesOf<T>\n */\n\n/**\n * @param {EntityManager} entityManager \n * @param {ComponentName} componentName\n * @returns {ComponentInstanceMap} A map of entity ids to component instance data.\n */\nfunction resolveComponentInstanceMap(entityManager, componentName) {\n    // @ts-ignore\n    let components = entityManager.components;\n    if (!(componentName in components)) {\n        /** @type {ComponentInstanceMap} */\n        let map = {};\n        components[componentName] = map;\n        return map;\n    } else {\n        return components[componentName];\n    }\n}\n\n/**\n * @param {EntityManager} entityManager \n * @param {ComponentName} componentName\n * @returns {ComponentInstanceMap} A map of entity ids to component instance data.\n */\nfunction resetComponentInstanceMap(entityManager, componentName) {\n    // @ts-ignore\n    let components = entityManager.components;\n    /** @type {ComponentInstanceMap} */\n    let map = {};\n    components[componentName] = map;\n    return map;\n}\n\n/**\n * @template T\n * @param {EntityManager} entityManager \n * @param {EntityId} entityId \n * @param {ComponentClass<T>} componentClass\n * @param {T} instance\n * @returns {T}\n */\nfunction attachComponent(entityManager, entityId, componentClass, instance) {\n    let componentName = componentClass.name;\n    let instanceMap = resolveComponentInstanceMap(entityManager, componentName);\n    instanceMap[entityId] = instance;\n    return instance;\n}\n\n/**\n * @template T\n * @param {EntityManager} entityManager \n * @param {EntityId} entityId \n * @param {ComponentClass<T>} componentClass\n */\nfunction detachComponent(entityManager, entityId, componentClass) {\n    let componentName = componentClass.name;\n    let instanceMap = resolveComponentInstanceMap(entityManager, componentName);\n    let instance = instanceMap[entityId];\n    delete instanceMap[entityId];\n    componentClass.delete(instance);\n}\n\n/**\n * @template T\n * @param {EntityManager} entityManager\n * @param {ComponentClass<T>} componentClass\n */\nfunction clearComponents(entityManager, componentClass) {\n    let componentName = componentClass.name;\n    let instanceMap = resolveComponentInstanceMap(entityManager, componentName);\n    let instances = Object.values(instanceMap);\n    resetComponentInstanceMap(entityManager, componentName);\n    for(let instance of instances) {\n        componentClass.delete(instance);\n    }\n}\n\nconst NEXT_AVAILABLE_ENTITY_ID = Symbol('nextAvailableEntityId');\n\n/**\n * @param {EntityManager} entityManager \n * @returns {EntityId}\n */\nfunction nextAvailableEntityId(entityManager) {\n    return ++entityManager[NEXT_AVAILABLE_ENTITY_ID];\n}\n\nexport class EntityManager {\n    constructor() {\n        /**\n         * @protected\n         * @type {ComponentClassMap}\n         */\n        this.components = {};\n        /** @type {EntityId} */\n        this[NEXT_AVAILABLE_ENTITY_ID] = 1;\n        /**\n         * @protected\n         * @type {Array<[string, ...any]>}\n         */\n        this.queue = [];\n    }\n\n    flush() {\n        while (this.queue.length > 0) {\n            let [type, ...args] = this.queue.shift();\n            switch (type) {\n                case 'attach': {\n                    let [entityId, componentClass, instance] = args;\n                    attachComponent(this, entityId, componentClass, instance);\n                } break;\n                case 'detach': {\n                    let [entityId, componentClass] = args;\n                    detachComponent(this, entityId, componentClass);\n                } break;\n                case 'clear': {\n                    let [componentClass] = args;\n                    clearComponents(this, componentClass);\n                } break;\n            }\n        }\n    }\n\n    /**\n     * @template {ComponentClass<any>[]}T\n     * @param {T} componentClasses \n     * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n     */\n    createAndAttach(...componentClasses) {\n        let entityId = nextAvailableEntityId(this);\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (/** @type {unknown} */ ([entityId]));\n        for (let componentClass of componentClasses) {\n            let instance = this.attach(entityId, componentClass);\n            result.push(instance);\n        }\n        return result;\n    }\n\n    /**\n     * @returns {EntityId}\n     */\n    create() {\n        return nextAvailableEntityId(this);\n    }\n\n    /**\n     * @param {EntityId} entityId \n     */\n    destroy(entityId) {\n        for (let instanceMap of Object.values(this.components)) {\n            if (entityId in instanceMap) {\n                delete instanceMap[entityId];\n            }\n        }\n    }\n\n    /**\n     * @param {EntityId} entityId \n     */\n    exists(entityId) {\n        for (let instanceMap of Object.values(this.components)) {\n            if (entityId in instanceMap) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass\n     * @returns {T}\n     */\n    attach(entityId, componentClass) {\n        let instance = componentClass.new();\n        this.queue.push(['attach', entityId, componentClass, instance]);\n        return instance;\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     * @returns {T}\n     */\n    attachImmediately(entityId, componentClass) {\n        let instance = componentClass.new();\n        return attachComponent(this, entityId, componentClass, instance);\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass\n     */\n    detach(entityId, componentClass) {\n        this.queue.push(['detach', entityId, componentClass]);\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     */\n    detachImmediately(entityId, componentClass) {\n        detachComponent(this, entityId, componentClass);\n    }\n\n    /**\n     * @template T\n     * @param {ComponentClass<T>} componentClass \n     */\n    clear(componentClass) {\n        this.queue.push(['clear', componentClass]);\n    }\n\n    /**\n     * @param {ComponentClass<any>} componentClass \n     */\n    clearImmediately(componentClass) {\n        clearComponents(this, componentClass);\n    }\n\n    /**\n     * @template T\n     * @param {EntityId} entityId \n     * @param {ComponentClass<T>} componentClass \n     * @returns {T}\n     */\n    get(entityId, componentClass) {\n        let componentName = componentClass.name;\n        let instanceMap = resolveComponentInstanceMap(this, componentName);\n        if (instanceMap) {\n            return null;\n        } else {\n            return instanceMap[entityId] || null;\n        }\n    }\n\n    /**\n     * @param {ComponentClass<?>} componentClass \n     * @returns {number}\n     */\n    count(componentClass) {\n        let componentName = componentClass.name;\n        let instanceMap = resolveComponentInstanceMap(this, componentName);\n        if (instanceMap) {\n            return 0;\n        } else {\n            return Object.keys(instanceMap).length;\n        }\n    }\n\n    reset() {\n        this.components = {};\n        this[NEXT_AVAILABLE_ENTITY_ID] = 1;\n        this.queue.length = 0;\n    }\n}\n\n/**\n * @template {ComponentClass<any>[]} T\n */\nexport class EntityTemplate {\n    /**\n     * @param {T} componentClasses \n     */\n    constructor(...componentClasses) {\n        /** @private */\n        this.componentClasses = componentClasses;\n    }\n\n    /**\n     * @param {EntityManager} entityManager\n     * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n     */\n    create(entityManager) {\n        let entityId = nextAvailableEntityId(entityManager);\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (/** @type {unknown} */ ([entityId]));\n        for (let componentClass of this.componentClasses) {\n            let instance = entityManager.attach(entityId, componentClass);\n            result.push(instance);\n        }\n        return result;\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @param {EntityId} entityId \n     */\n    destroy(entityManager, entityId) {\n        for (let componentClass of this.componentClasses) {\n            entityManager.detach(entityId, componentClass);\n        }\n    }\n}\n\n/**\n * @template {ComponentClass<any>[]} T\n */\nexport class EntityQuery {\n    /**\n     * @param {T} selectors \n     */\n    constructor(...selectors) {\n        /** @private */\n        this.selectors = selectors;\n    }\n    \n    /**\n     * @param {EntityManager} entityManager \n     * @returns {number}\n     */\n    count(entityManager) {\n        let count = 0;\n        let iter = this.findAll(entityManager);\n        while(!iter.next().done) {\n            ++count;\n        }\n        return count;\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @returns {[EntityId, ...ComponentInstancesOf<T>]}\n     */\n    find(entityManager) {\n        let entities = this.findAll(entityManager);\n        let result = entities.next();\n        if (result.done) {\n            // @ts-ignore\n            return [];\n        } else {\n            return result.value;\n        }\n    }\n\n    /**\n     * @param {EntityManager} entityManager \n     * @returns {Generator<[EntityId, ...ComponentInstancesOf<T>]>}\n     */\n    *findAll(entityManager) {\n        if (this.selectors.length <= 0) {\n            return;\n        }\n        let componentClass = this.selectors[0];\n        let componentName = componentClass.name;\n        let instanceMap = resolveComponentInstanceMap(entityManager, componentName);\n        let result = /** @type {[EntityId, ...ComponentInstancesOf<T>]} */ (new Array(this.selectors.length + 1));\n        for (let key of Object.keys(instanceMap)) {\n            let entityId = Number(key);\n            let flag = true;\n            result[0] = entityId;\n            let index = 1;\n            for (let otherClass of this.selectors) {\n                let otherName = otherClass.name;\n                let otherMap = resolveComponentInstanceMap(entityManager, otherName);\n                if (!(entityId in otherMap)) {\n                    flag = false;\n                    break;\n                }\n                let other = otherMap[entityId];\n                result[index++] = other;\n            }\n            if (flag) {\n                yield result;\n            }\n        }\n    }\n}\n","/**\n * @template T\n */\nexport class Topic {\n\n    /**\n     * @abstract\n     * @param {T} [attachment] \n     */\n    dispatch(attachment = null) {}\n\n    /**\n     * @abstract\n     * @param {T} [attachment] \n     */\n    dispatchImmediately(attachment = null) {}\n\n    /**\n     * @abstract\n     * @param {number} max \n     */\n    flush(max = 1000) {}\n}\n","import { Topic } from './Topic.js';\n\n/**\n * @template T\n * @typedef {(t: T) => void|boolean} PriorityTopicCallback<T>\n */\n\n/**\n * @template T\n * @typedef PriorityTopicOptions\n * @property {number} priority\n * @property {PriorityTopicCallback<T>} callback\n */\n\n/**\n * @param {PriorityTopicOptions<?>} a \n * @param {PriorityTopicOptions<?>} b \n */\nfunction comparator(a, b) {\n    return a.priority - b.priority;\n}\n\n/**\n * @template T\n */\nexport class PriorityEventTopic extends Topic {\n\n    constructor() {\n        super();\n\n        /**\n         * @private\n         * @type {Array<PriorityTopicOptions<T>>}\n         */\n        this.listeners = [];\n\n        /**\n         * @private\n         * @type {Array<T>}\n         */\n        this.queued = [];\n    }\n\n    /**\n     * @param {number} priority \n     * @param {PriorityTopicCallback<T>} callback \n     */\n    on(priority, callback) {\n        this.listeners.push({ priority, callback });\n        this.listeners.sort(comparator);\n        return this;\n    }\n\n    /**\n     * @param {PriorityTopicCallback<T>} callback \n     */\n    off(callback) {\n        for(let i = 0; i < this.listeners.length; ++i) {\n            if (this.listeners.at(i).callback === callback) {\n                this.listeners.splice(i, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * @param {number} priority \n     * @param {PriorityTopicCallback<T>} callback \n     */\n    once(priority, callback) {\n        let wrapper = (attachment) => {\n            this.off(wrapper);\n            return callback(attachment);\n        };\n        return this.on(priority, wrapper);\n    }\n\n    count() {\n        return this.listeners.length;\n    }\n\n    /**\n     * @override\n     * @param {T} [attachment]\n     */\n    dispatch(attachment = null) {\n        this.queued.push(attachment);\n        return this;\n    }\n\n    /**\n     * @override\n     * @param {T} [attachment] \n     */\n    dispatchImmediately(attachment = null) {\n        for(let listener of this.listeners) {\n            let result = listener.callback(attachment);\n            // Consume the event if return true.\n            if (result === true) {\n                break;\n            }\n        }\n        return this;\n    }\n\n    /** @override */\n    flush(max = 1000) {\n        let i = 0;\n        while(this.queued.length > 0 && i++ < max) {\n            let attachment = this.queued.shift();\n            this.dispatchImmediately(attachment);\n        }\n        return this;\n    }\n}\n","/** @typedef {(frameDetail: AnimationFrameLoop) => void} AnimationFrameLoopCallback */\n\nexport class AnimationFrameLoop {\n    \n    /**\n     * @param {AnimationFrameLoopCallback} callback \n     * @param {object} [opts]\n     * @param {Window} [opts.animationFrameHandler]\n     */\n    constructor(callback, opts = undefined) {\n        const { animationFrameHandler = window } = opts || {};\n\n        /** @type {ReturnType<requestAnimationFrame>} */\n        this.handle = 0;\n        this.detail = {\n            prevTime: -1,\n            currentTime: -1,\n            deltaTime: 0,\n        };\n\n        /** @protected */\n        this.animationFrameHandler = animationFrameHandler;\n\n        /** @protected */\n        this.callback = callback;\n\n        this.next = this.next.bind(this);\n        this.start = this.start.bind(this);\n        this.cancel = this.cancel.bind(this);\n    }\n    \n    next(now = performance.now()) {\n        this.handle = this.animationFrameHandler.requestAnimationFrame(this.next);\n        let d = this.detail;\n        d.prevTime = d.currentTime;\n        d.currentTime = now;\n        d.deltaTime = d.currentTime - d.prevTime;\n        this.callback(this);\n    }\n\n    start() {\n        this.handle = this.animationFrameHandler.requestAnimationFrame(this.next);\n        return this;\n    }\n\n    cancel() {\n        this.animationFrameHandler.cancelAnimationFrame(this.handle);\n        return this;\n    }\n}\n","import { Topic } from './Topic.js';\n\n/**\n * @template T\n */\nexport class CommandTopic extends Topic {\n    \n    constructor() {\n        super();\n\n        /**\n         * @private\n         * @type {Array<T>}\n         */\n        this.messages = [];\n        \n        /**\n         * @private\n         * @type {Array<T>}\n         */\n        this.queued = [];\n    }\n\n    /**\n     * @override\n     * @param {T} message \n     */\n    dispatch(message) {\n        this.queued.push(message);\n    }\n\n    /**\n     * @override\n     * @param {T} message \n     */\n    dispatchImmediately(message) {\n        this.messages.push(message);\n    }\n\n    /** @override */\n    flush(max = 1000) {\n        let result = this.queued.splice(0, Math.min(max, this.queued.length));\n        this.messages.push(...result);\n    }\n\n    /**\n     * @param {number} [max]\n     * @return {Iterable<T>}\n     */\n    *poll(max = 1000) {\n        let iterations = 0;\n        while(iterations < max && this.messages.length > 0) {\n            let message = this.messages.shift();\n            yield message;\n            ++iterations;\n        }\n    }\n}\n","/**\n * @template T\n */\nexport class ComponentClass {\n    /**\n     * @param {string} name \n     * @param {() => T} newCallback\n     * @param {(component: T) => void} [deleteCallback] \n     */\n    constructor(name, newCallback = () => null, deleteCallback = () => { }) {\n        this.name = name;\n        this.new = newCallback;\n        this.delete = deleteCallback;\n    }\n}\n","import { Topic } from './Topic.js';\n\n/**\n * @template T\n * @typedef {(t: T) => void|boolean} EventTopicCallback\n */\n\n/** @template T */\nexport class EventTopic extends Topic {\n\n    constructor() {\n        super();\n\n        /**\n         * @private\n         * @type {Array<EventTopicCallback<T>>}\n         */\n        this.listeners = [];\n\n        /**\n         * @private\n         * @type {Array<T>}\n         */\n        this.queued = [];\n    }\n\n    /**\n     * @param {EventTopicCallback<T>} callback \n     */\n    on(callback) {\n        this.listeners.push(callback);\n        return this;\n    }\n\n    /**\n     * @param {EventTopicCallback<T>} callback \n     */\n    off(callback) {\n        let i = this.listeners.indexOf(callback);\n        if (i >= 0) {\n            this.listeners.splice(i, 1);\n        }\n        return this;\n    }\n\n    /**\n     * @param {EventTopicCallback<T>} callback \n     */\n    once(callback) {\n        let wrapper = (attachment) => {\n            this.off(wrapper);\n            return callback(attachment);\n        };\n        this.on(wrapper);\n        return this;\n    }\n\n    /**\n     * @override\n     * @param {T} [attachment]\n     */\n    dispatch(attachment = null) {\n        this.queued.push(attachment);\n    }\n\n    /**\n     * @override\n     * @param {T} [attachment] \n     */\n    dispatchImmediately(attachment = null) {\n        for(let listener of this.listeners) {\n            let result = listener(attachment);\n            // Consume the event if return true.\n            if (result === true) {\n                break;\n            }\n        }\n    }\n\n    /** @override */\n    flush(max = 1000) {\n        let i = 0;\n        while(this.queued.length > 0 && i++ < max) {\n            let attachment = this.queued.shift();\n            this.dispatchImmediately(attachment);\n        }\n    }\n\n    count() {\n        return this.listeners.length;\n    }\n}\n","import { mat4 } from 'gl-matrix';\nimport { Camera } from './Camera.js';\n\nexport class OrthographicCamera extends Camera {\n  /**\n   * @param {number} [left]\n   * @param {number} [top]\n   * @param {number} [right]\n   * @param {number} [bottom]\n   * @param {number} [near]\n   * @param {number} [far]\n   */\n  constructor(\n    left = undefined,\n    top = undefined,\n    right = undefined,\n    bottom = undefined,\n    near = -1000,\n    far = 1000\n  ) {\n    super(mat4.create(), mat4.create());\n\n    this.orthoBounds = {\n      left: typeof left === 'undefined' ? undefined : Number(left),\n      top: typeof top === 'undefined' ? undefined : Number(top),\n      right: typeof right === 'undefined' ? undefined : Number(right),\n      bottom: typeof bottom === 'undefined' ? undefined : Number(bottom),\n    };\n    this.clippingPlane = {\n      near: Number(near),\n      far: Number(far),\n    };\n  }\n\n  /**\n   * If both the bounds and viewport dimensions are defined, the orthographic\n   * projection will be set the defined bounds adjusted with respect to\n   * the aspect ratio. This is usually the desired behavior.\n   *\n   * If the bounds are `undefined`, the orthographic projection will\n   * be set to the viewport dimensions. This is useful for pixel-perfect\n   * projections.\n   *\n   * If viewport dimensions are `undefined`, the orthographic projection\n   * will only use the defined bounds. This is useful if you are already\n   * performing your own calculations for the bounds or desire a static\n   * projection.\n   *\n   * @override\n   * @param {number} [viewportWidth]\n   * @param {number} [viewportHeight]\n   */\n  resize(viewportWidth = undefined, viewportHeight = undefined) {\n    const { near, far } = this.clippingPlane;\n    const { left, top, right, bottom } = this.orthoBounds;\n\n    let projectionMatrix = this.projectionMatrix;\n    let hasViewport = typeof viewportWidth !== 'undefined';\n    let hasBounds = typeof left !== 'undefined';\n\n    if (hasViewport) {\n      if (hasBounds) {\n        // Use the defined bounds with respect to the viewport aspect ratio\n        const aspectRatio = viewportWidth / viewportHeight;\n        mat4.ortho(\n          projectionMatrix,\n          left * aspectRatio,\n          right * aspectRatio,\n          bottom,\n          top,\n          near,\n          far\n        );\n      } else {\n        // Use the viewport dimensions as bounds\n        mat4.ortho(\n          projectionMatrix,\n          0,\n          viewportWidth,\n          viewportHeight,\n          0,\n          near,\n          far\n        );\n      }\n    } else {\n      if (hasBounds) {\n        // Use the defined bounds as-is\n        mat4.ortho(projectionMatrix, left, right, bottom, top, near, far);\n      } else {\n        // Use default bounds (since nothing else exists)\n        mat4.ortho(projectionMatrix, -1, 1, 1, -1, -1, 1);\n      }\n    }\n    return this;\n  }\n}\n"],"names":["UP","vec3","fromValues","Camera","constructor","projectionMatrix","viewMatrix","this","resize","viewportWidth","viewportHeight","DEFAULT_FOVY","Math","PI","TO_RAD_FACTOR","MAX_DEPTH_LEVEL","attach","parentNode","childNode","sceneGraph","nodes","children","push","parent","roots","detach","childIndex","indexOf","splice","rootIndex","walkImpl","level","nodeCallback","filterCallback","result","parentInfo","nextNodes","walkDeleteCallback","sceneNode","resolveComponentInstanceMap","entityManager","componentName","components","map","attachComponent","entityId","componentClass","instance","name","detachComponent","instanceMap","delete","clearComponents","instances","Object","values","resetComponentInstanceMap","NEXT_AVAILABLE_ENTITY_ID","Symbol","nextAvailableEntityId","Topic","dispatch","attachment","dispatchImmediately","flush","max","comparator","a","b","priority","callback","opts","animationFrameHandler","window","handle","detail","prevTime","currentTime","deltaTime","next","bind","start","cancel","now","performance","requestAnimationFrame","d","cancelAnimationFrame","super","messages","queued","message","min","length","poll","iterations","shift","newCallback","deleteCallback","new","queue","type","args","createAndAttach","componentClasses","create","destroy","exists","attachImmediately","detachImmediately","clear","clearImmediately","get","count","keys","reset","selectors","iter","findAll","done","find","value","Array","key","Number","flag","index","otherClass","otherMap","other","listeners","on","off","i","once","wrapper","listener","locky","position","forward","right","up","forwardAmount","rightAmount","upAmount","pitch","yaw","look","dx","dy","dt","move","apply","rady","radp","cosy","cos","cosp","siny","sin","dz","normalize","set","cross","scale","add","target","mat4","lookAt","left","top","bottom","near","far","orthoBounds","undefined","clippingPlane","hasBounds","aspectRatio","ortho","fieldOfView","perspective","sort","at","_nextAvailableSceneNodeId","createSceneNode","info","createSceneNodes","deleteSceneNode","Error","deleteSceneNodes","sceneNodes","getSceneNodeInfo","parentSceneNode","replaceSceneNode","replacementNode","grandChildren","slice","replacementInfo","walk","from","childFilter","fromNodes","isArray","fromNode","x","y","z","rotation","quat","getTranslation","getRotation","targetRotation","slerp","fromRotationTranslation","translation","translate","out","normalizedScreenCoordX","normalizedScreenCoordY","normalized","v","vec4","m","invert","transformMat4"],"mappings":"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"}