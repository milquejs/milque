!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("gl-matrix")):"function"==typeof define&&define.amd?define(["exports","gl-matrix"],t):t(((e="undefined"!=typeof globalThis?globalThis:e||self).milque=e.milque||{},e.milque.scene={}),e.glMatrix)}(this,(function(e,t){"use strict";const n=t.vec3.fromValues(0,1,0);class i{constructor(e,t){this.projectionMatrix=e,this.viewMatrix=t}resize(e,t){return this}}const s=Math.PI/3;const r=Math.PI/180;const o=100;function a(e,t,n){e?(n.nodes[e].children.push(t),n.nodes[t].parent=e):(n.roots.push(t),n.nodes[t].parent=0)}function l(e,t,n){if(e){let i=n.nodes[e].children,s=i.indexOf(t);i.splice(s,1),n.nodes[t].parentNode=0}else{let e=n.roots,i=e.indexOf(t);e.splice(i,1),n.nodes[t].parentNode=0}}function c(e,t,n,i,s){if(n>=o)return;let r=i(t,e);if(!1===r)return;let a=e.nodes[t],l=s?s(a.children,t,e):a.children;for(let t of l)c(e,t,n+1,i,s);"function"==typeof r&&r(t,e)}function h(e,t){delete t.nodes[e]}class u{constructor(){this.cachedResults={},this.keyQueryMapping={},this.onEntityComponentChanged=this.onEntityComponentChanged.bind(this)}onEntityComponentChanged(e,t,n,i,s){for(let r of Object.values(this.keyQueryMapping)){let o=this.cachedResults[r.key];if(s){let e=o.indexOf(t);e>=0&&o.splice(e,1)}else if(n){if(r.hasSelector(d(n))){let e=o.indexOf(t);e>=0&&o.splice(e,1)}else if(r.hasSelector(n)&&r.test(e,t)){o.indexOf(t)<0&&o.push(t)}}else if(i)if(r.hasSelector(d(i))&&r.test(e,t)){o.indexOf(t)<0&&o.push(t)}else if(r.hasSelector(i)&&r.test(e,t)){let e=o.indexOf(t);e>=0&&o.splice(e,1)}}}findAny(e,t){let n=this.findAll(e,t);return n.length<=0?null:n[Math.floor(Math.random()*n.length)]}findAll(e,t){const n=t.key;let i;return n in this.keyQueryMapping?i=this.cachedResults[n]:(i=[],this.keyQueryMapping[n]=t,this.cachedResults[n]=i,t.hydrate(e,i)),i}count(e,t){return this.findAll(e,t).length}clear(e){const t=e.key;t in this.keyQueryMapping&&(delete this.keyQueryMapping[t],delete this.cachedResults[t])}reset(){this.keyQueryMapping={},this.cachedResults={}}}function d(e){return{type:"not",name:e.name,value:e}}function f(e){return"type"in e&&"not"===e.type}function m(e,t,n,i){e[0]=n;let s=1;for(let r of i)f(r)?e[s]=null:e[s]=t.get(n,r),++s;return e}class p{constructor(e){this.name=e}dispatch(e,t){e.dispatch(this,t)}dispatchImmediately(e,t){e.dispatchImmediately(this,t)}on(e,t,n){return e.addEventListener(this,n,{priority:t}),this}off(e,t){return e.removeEventListener(this,t),this}once(e,t,n){let i=t=>(this.off(e,i),n(t));return this.on(e,t,i)}*poll(e,t){t=Math.min(t,e.count(this));for(let n=0;n<t;++n)yield e.poll(this)}retain(e,t){e.retain(this,t)}*pollAndRetain(e,t){this.retain(e,t);for(let n of this.poll(e,t))yield n}}function y(e,t){return e.priority-t.priority}class v{constructor(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}addEventListener(e,t,n){const{priority:i=0}=n;let s=this.callbacksOf(e);s.push({callback:t,priority:i}),s.sort(y)}removeEventListener(e,t){let n=this.callbacksOf(e),i=n.findIndex((e=>e.callback===t));i>=0&&n.splice(i,1)}countEventListeners(e){return this.callbacksOf(e).length}dispatch(e,t){this.incomingOf(e).push(t)}dispatchImmediately(e,t){let n=this.callbacksOf(e);for(let{callback:e}of n){if(!0===e(t))return}this.outgoingOf(e).push(t)}count(e){return this.outgoingOf(e).length}poll(e){let t=this.outgoingOf(e);return t.length<=0?null:t.shift()}retain(e,t){const n=e.name;let i=Math.max(t,this.maxRetains[n]||0);this.maxRetains[n]=i}flush(e=100){for(const t of Object.keys(this.cachedIn)){const n=this.nameTopicMapping[t],i=this.cachedIn[t],s=this.cachedOut[t],r=this.maxRetains[t]||0;r<s.length&&s.splice(0,s.length-r);let o=Math.min(e,i.length);for(let e=0;e<o;++e){let e=i.shift();this.dispatchImmediately(n,e)}}}getPendingRetainCount(e){return this.maxRetains[e.name]||0}getPendingFlushCount(e){return this.incomingOf(e).length}reset(){this.cachedIn={},this.cachedOut={},this.callbacks={},this.maxRetains={},this.nameTopicMapping={}}incomingOf(e){const t=e.name;if(t in this.cachedIn)return this.cachedIn[t];{let n=[];return this.cachedIn[t]=n,this.cachedOut[t]=[],this.nameTopicMapping[t]=e,n}}outgoingOf(e){const t=e.name;if(t in this.cachedOut)return this.cachedOut[t];{let n=[];return this.cachedIn[t]=[],this.cachedOut[t]=n,this.nameTopicMapping[t]=e,n}}callbacksOf(e){const t=e.name;if(t in this.callbacks)return this.callbacks[t];{let e=[];return this.callbacks[t]=e,e}}}class g{constructor(e,t){const{animationFrameHandler:n=window}=t||{};this.handle=0,this.detail={prevTime:-1,currentTime:-1,deltaTime:0},this.animationFrameHandler=n,this.callback=e,this.next=this.next.bind(this),this.start=this.start.bind(this),this.cancel=this.cancel.bind(this)}next(e=performance.now()){this.handle=this.animationFrameHandler.requestAnimationFrame(this.next);let t=this.detail;t.prevTime=t.currentTime,t.currentTime=e,t.deltaTime=t.currentTime-t.prevTime,this.callback(this)}start(){return this.handle=this.animationFrameHandler.requestAnimationFrame(this.next),this}cancel(){return this.animationFrameHandler.cancelAnimationFrame(this.handle),this}}function b(e,t){let n=k(e),i=t.name;if(i in n.contexts){let{value:s}=n.contexts[i];if(s)return s;throw x(e).name===t.name?new Error("Cannot useProvider() on self during initialization!"):new Error("This is not a provider.")}throw new Error(`Missing assigned dependent provider '${i}' in context.`)}function x(e){let t=O(e);if(!t)throw new Error("This is not a provider.");return t.current}const w=Symbol("providers");function k(e){return w in e?e[w]:e[w]={contexts:{},current:null}}function O(e){return w in e?e[w]:null}function C(e,t){const n=x(e);if(!n)throw new Error("Not a provider.");I(n,E(e).contexts).befores.push(t)}async function M(e,t){let n=function(e){if(A in e)return e[A];return null}(e);if(!n)return e;for(let e of t.slice().reverse()){let t=T(e,n.contexts);if(!t)throw new Error("Cannot revert context for non-existent provider.");let i=t.afters.slice();t.afters.length=0,await Promise.all(i.map((e=>e&&e())))}return e}const A=Symbol("effectors");function E(e){return A in e?e[A]:e[A]={contexts:{}}}function I(e,t){const n=e.name;return n in t?t[n]:t[n]={befores:[],afters:[]}}function T(e,t){const n=e.name;return n in t?t[n]:null}const N=new p("main.update");function q(e,t,n){C(e,(()=>(N.on(t,0,n),()=>{N.off(t,n)})))}function S(e){const t=new v;return q(e,t,(()=>{t.flush()})),t}function j(e){const t=b(e,S),n=new g((e=>{N.dispatchImmediately(t,e)}));return C(e,(()=>{n.start()})),n}var L=Object.freeze({__proto__:null,AnimationFrameLoopProvider:j,TopicsProvider:S,toast:function(e,t,n=[]){const i=[S,j,...n,function(e){const n=b(e,S);C(e,(async()=>(t.load&&await t.load(e),t.init&&t.init(e),async()=>{t.dead&&t.dead(e),t.unload&&await t.unload(e)}))),q(e,n,(()=>{t.update&&t.update(e),t.draw&&t.draw(e)}))}];return{async start(){return function(e,t){let n=k(e);for(let i of t){let t={handle:i,value:null};n.contexts[i.name]=t,n.current=i,t.value=i(e)}}(e,i),await async function(e,t){let n=E(e);for(let e of t){let t=I(e,n.contexts),i=t.befores.slice();t.befores.length=0;let s=await Promise.all(i.map((e=>e&&e())));t.afters.push(...s)}return e}(e,i),this},async stop(){return await M(e,i),function(e,t){let n=O(e);if(!n)return e;for(let e of t.slice().reverse())n.contexts[e.name].value=null,delete n.contexts[e.name]}(e,i),this}}},useDocumentEventListener:function(e,t,n){C(e,(()=>{const e=window.document;return e.addEventListener(t,n),()=>{e.removeEventListener(t,n)}}))},useEffect:C,useHTMLElementEventListener:function(e,t,n,i){C(e,(()=>(t.addEventListener(n,i),()=>{t.removeEventListener(n,i)})))},useProvider:b,useSystemUpdate:q,useTopic:function(e,t,n,i){const s=b(e,S);C(e,(()=>(t.on(s,n,i),()=>{t.off(s,i)})))},useWindowEventListener:function(e,t,n){C(e,(()=>{const e=window;return e.addEventListener(t,n),()=>{e.removeEventListener(t,n)}}))}});e.AnimationFrameLoop=g,e.Camera=i,e.ComponentClass=class{constructor(e,t=(()=>null),n=(()=>{})){this.name=e,this.new=t,this.delete=n}},e.EntityManager=class{constructor(){this.components={},this.nameClassMapping={},this.nextAvailableEntityId=1,this.queue=[],this.listeners=[],this.queries=new u}entityComponentChangedCallback(e,t,n,i){this.queries.onEntityComponentChanged(this,e,t,n,i);for(let s of this.listeners)s(this,e,t,n,i)}addEventListener(e,t){"change"===e&&this.listeners.push(t)}removeEventListener(e,t){if("change"===e){let e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}}flush(){for(;this.queue.length>0;){let[e,...t]=this.queue.shift();switch(e){case"attach":{let[e,n,i]=t;this.attachImmediately(e,n,i)}break;case"detach":{let[e,n]=t;this.detachImmediately(e,n)}break;case"clear":{let[e]=t;this.clearImmediately(e)}}}}create(){let e=this.nextAvailableEntityId++;return this.entityComponentChangedCallback(e,null,null,!1),e}destroy(e){const t=this.components;for(const n of Object.keys(t)){const i=t[n];e in i&&(delete i[e],this.entityComponentChangedCallback(e,null,this.nameClassMapping[n],!1))}this.entityComponentChangedCallback(e,null,null,!0)}exists(e,...t){if(t.length>0){for(const n of t){if(!(e in this.mapOf(n)))return!1}return!0}for(let t of Object.values(this.components))if(e in t)return!0;return!1}attach(e,t,n){return void 0===n&&(n=t.new()),this.queue.push(["attach",e,t,n]),n}attachImmediately(e,t,n){return void 0===n&&(n=t.new()),this.mapOf(t)[e]=n,this.entityComponentChangedCallback(e,t,null,!1),n}detach(e,t){this.queue.push(["detach",e,t])}detachImmediately(e,t){let n=this.mapOf(t),i=n[e];delete n[e],t.delete(i),this.entityComponentChangedCallback(e,null,t,!1)}clear(e){this.queue.push(["clear",e])}clearImmediately(e){const t=e.name,n=this.components,i=n[t];let s=Object.keys(i).map(Number),r=Object.values(i);n[t]={},this.nameClassMapping[t]=e;for(let t of r)e.delete(t);for(let t of s)this.entityComponentChangedCallback(t,null,e,!1)}get(e,t){return this.mapOf(t)[e]||null}count(e){return Object.keys(this.mapOf(e)).length}keysOf(e){return Object.keys(this.mapOf(e)).map(Number)}valuesOf(e){return Object.values(this.mapOf(e))}mapOf(e){const t=e.name,n=this.components;if(t in n)return n[t];{let i={};return n[t]=i,this.nameClassMapping[t]=e,i}}entityIds(){let e=new Set;for(let t of Object.values(this.components))for(let n of Object.keys(t))e.add(n);return e}componentClasses(){return Object.values(this.nameClassMapping)}reset(){const e=this.components;let t=new Set;for(const n of Object.keys(e)){const i=this.nameClassMapping[n],s=e[n];for(let e of Object.keys(s))t.add(Number(e));this.clearImmediately(i)}for(let e of t)this.entityComponentChangedCallback(e,null,null,!0);t.clear(),this.queries.reset(),this.components={},this.nextAvailableEntityId=1,this.queue.length=0,this.listeners.length=0}},e.EntityTemplate=class{constructor(...e){this.componentClasses=e}create(e){let t=e.create(),n=[t];for(let i of this.componentClasses){let s=e.attach(t,i);n.push(s)}return n}destroy(e,t){for(let n of this.componentClasses)e.detach(t,n)}},e.FirstPersonCameraController=class{constructor(e={locky:!1}){this.locky=e.locky,this.position=t.vec3.create(),this.forward=t.vec3.fromValues(0,0,-1),this.right=t.vec3.fromValues(1,0,0),this.up=t.vec3.fromValues(0,1,0),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.pitch=0,this.yaw=-90}look(e,t,n=1){return n*=1e3,this.pitch=Math.min(89.9,Math.max(-89.9,this.pitch+t*n)),this.yaw=(this.yaw+e*n)%360,this}move(e,t=0,n=0,i=1){return this.forwardAmount+=e*i,this.rightAmount+=t*i,this.upAmount+=n*i,this}apply(e){let{position:n,forward:i,right:s,up:o,forwardAmount:a,rightAmount:l,upAmount:c,pitch:h,yaw:u}=this,d=u*r,f=h*r,m=Math.cos(d),p=Math.cos(f),y=Math.sin(d),v=m*p,g=Math.sin(f),b=y*p;t.vec3.normalize(i,t.vec3.set(i,v,this.locky?0:g,b)),t.vec3.normalize(s,t.vec3.cross(s,i,o));let x=t.vec3.create();t.vec3.scale(x,i,a),t.vec3.add(n,n,x),t.vec3.scale(x,s,l),t.vec3.add(n,n,x),t.vec3.scale(x,o,c),t.vec3.add(n,n,x),this.forwardAmount=0,this.rightAmount=0,this.upAmount=0,this.locky&&t.vec3.set(i,v,g,b);let w=t.vec3.add(x,n,i);return t.mat4.lookAt(e,n,w,o),e}},e.Not=d,e.OrthographicCamera=class extends i{constructor(e,n,i,s,r=-1e3,o=1e3){super(t.mat4.create(),t.mat4.create()),this.orthoBounds={left:void 0===e?void 0:Number(e),top:void 0===n?void 0:Number(n),right:void 0===i?void 0:Number(i),bottom:void 0===s?void 0:Number(s)},this.clippingPlane={near:Number(r),far:Number(o)}}resize(e,n){const{near:i,far:s}=this.clippingPlane,{left:r,top:o,right:a,bottom:l}=this.orthoBounds;let c=this.projectionMatrix,h=void 0!==r;if(void 0!==e)if(h){const h=e/n;t.mat4.ortho(c,r*h,a*h,l,o,i,s)}else t.mat4.ortho(c,0,e,n,0,i,s);else h?t.mat4.ortho(c,r,a,l,o,i,s):t.mat4.ortho(c,-1,1,1,-1,-1,1);return this}},e.PerspectiveCamera=class extends i{constructor(e=s,n=.1,i=1e3){super(t.mat4.create(),t.mat4.create()),this.fieldOfView=Number(e),this.clippingPlane={near:Number(n),far:Number(i)}}resize(e,n){const i=void 0===e?1:e/n,{near:s,far:r}=this.clippingPlane;return t.mat4.perspective(this.projectionMatrix,this.fieldOfView,i,s,r),this}},e.Query=class{constructor(...e){if(e.length<=0)throw new Error("Must have at least 1 selector for query.");this.selectors=e,this.key=e.map((e=>f(e)?`!${e.name}`:e.name)).sort().join("&")}hasSelector(e){return f(e)?this.selectors.findIndex((t=>f(t)&&t.name===e.name))>=0:this.selectors.findIndex((t=>t.name===e.name))>=0}test(e,t){for(let n of this.selectors)if(f(n)){const i=n.value;if(e.exists(t,i))return!1}else{const i=n;if(!e.exists(t,i))return!1}return!0}hydrate(e,t){if(this.selectors.length<=0)return t.length=0,t;let n=e.entityIds();for(let i of n)this.test(e,i)&&t.push(i);return t}count(e){return e.queries.count(e,this)}findAny(e){const t=e.queries;let n=new Array(this.selectors.length+1),i=t.findAny(e,this);return null===i?n.fill(void 0):(m(n,e,i,this.selectors),n)}*findAll(e){const t=e.queries;let n=new Array(this.selectors.length+1),i=t.findAll(e,this);for(let t of i)m(n,e,t,this.selectors),yield n}},e.QueryManager=u,e.SceneGraph=class{constructor(){this.nodes={},this.roots=[],this._nextAvailableSceneNodeId=1}createSceneNode(e){let t=this._nextAvailableSceneNodeId++,n={parent:0,children:[]};return this.nodes[t]=n,a(e,t,this),t}createSceneNodes(e,t){let n=[];for(let i=0;i<e;++i)n.push(this.createSceneNode(t));return n}deleteSceneNode(e){if(!(e in this.nodes))throw new Error("Cannot delete non-existant scene node for scene graph.");l(this.nodes[e].parent,e,this),c(this,e,0,h)}deleteSceneNodes(e){for(let t of e)this.deleteSceneNode(t)}getSceneNodeInfo(e){return this.nodes[e]}parentSceneNode(e,t){l(this.nodes[e].parent,e,this),a(t,e,this)}replaceSceneNode(e,t){let n=this.nodes[e],i=n.parent,s=n.children.slice();if(l(i,e,this),n.children.length=0,t){let e=this.nodes[t];l(e.parent,t,this),e.children.push(...s),a(i,t,this)}else if(i){this.nodes[i].children.push(...s)}else this.roots.push(...s);for(let e of s)this.nodes[e].parent=i}walk(e,t={}){const{from:n,childFilter:i}=t;let s;s=n?Array.isArray(n)?n:[n]:this.roots,i&&(s=i(s,0,this));for(let t of s)c(this,t,0,e,i)}},e.Toaster=L,e.Topic=p,e.TopicManager=v,e.isSelectorNot=f,e.lookAt=function(e,i,s,r=0,o=1){let a=t.vec3.create(),l=t.quat.create();t.mat4.getTranslation(a,e),t.mat4.getRotation(l,e);let c=t.vec3.fromValues(i,s,r);t.mat4.lookAt(e,a,c,n);let h=t.quat.create();t.mat4.getRotation(h,e),t.quat.slerp(l,l,h,o),t.mat4.fromRotationTranslation(e,l,a)},e.panTo=function(e,n,i,s=0,r=1){let o=t.vec3.create();t.mat4.getTranslation(o,e);let a=t.vec3.fromValues((n-o[0])*r,(i-o[1])*r,(s-o[2])*r);t.mat4.translate(e,e,a)},e.screenToWorldRay=function(e,n,i,s,r,o=!1){let a=t.vec4.fromValues(n,i,-1,1),l=t.mat4.create();return t.mat4.invert(l,s),t.vec4.transformMat4(a,a,l),a[2]=-1,a[3]=0,t.mat4.invert(l,r),t.vec4.transformMat4(a,a,l),e[0]=a[0],e[1]=a[1],e[2]=a[2],o&&t.vec3.normalize(e,e),e}}));
//# sourceMappingURL=milque-scene.umd.js.map
